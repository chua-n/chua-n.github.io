## 1、查询的概念

**查询**(query)——任何SQL语句都是查询，但此术语一般指SELECT语句。

**子查询**(subquery)——嵌套在其他查询中的查询。在SELECT语句中，子查询总是从内向外处理。

```sql
SELECT cus_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
                 FROM orders
                 WHERE order_num IN (SELECT order_num
                                    FROM orderitems
                                    WHERE prod_id = 'TNT2'));
```

如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。

## 2、SELECT基本用法

| 语法                                          | 说明     |
| --------------------------------------------- | -------- |
| `  SELECT * FROM <表名>  `                    | 基本查询 |
| `  SELECT * FROM <表名> WHERE <条件表达式>  ` | 条件查询 |
| `  SELECT 列1, 列2, 列3 FROM ...  `           | 投影查询 |
| `  SELECT * FROM <表1> <表2>  `               | 多表查询 |

- *表示“所有列”，FROM表示将要从哪个表查询

- `SELECT * FROM students`将查询出students表的所有数据。

    > 注意：查询结果也是一个二维表，它包含列名和每一行的数据。

- 这种多表查询又称**笛卡尔查询**，使用笛卡尔查询时要非常小心，结果集的列数是被查询表的列数之和，行数是被查询表的行数之积！对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录！       

使用`SELECT 列1, 列2, 列3 FROM ...`时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是`SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...`

## 3、LIMIT子句

| 语法                                | 说明                            |
| ----------------------------------- | ------------------------------- |
| `  LIMIT offset row_count  `        | 从offset开始返回row_count行数据 |
| `  LIMIT row_count OFFSET offset  ` | 同上，另一种写法                |

其中：

- OFFSET是可选的，如果只写`LIMIT row_count`，那么相当于`LIMIT M OFFSET 0`
- 使用`LIMIT <M> OFFSET <N>`分页时，随着N越来越大，查询效率也会越来越低

这种查询也叫分页查询，至于为什么这么叫，可以看廖雪峰的网站或百度一下。

## 4、JOIN子句

语法：

```sql
SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;
```

| ???的含义                        | 说明                         |
| -------------------------------- | ---------------------------- |
| INNER JOIN                       | 返回同时存在于两张表的行数据 |
| LEFT OUTER JOIN<br />LEFT JOIN   | 返回左表都存在的行           |
| RIGHT OUTER JOIN<br />RIGHT JOIN | 返回右表都存在的行           |
| FULL JOIN                        | 返回两张表的所有记录         |

## 5、连接查询详解

JOIN子句代表连接查询，连接查询是另一种类型的多表查询，其对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。

例如，对于两个表students和classes，如下。

```sql
-- 选出所有学生
SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;
```

| **id** | **name** | **class_id** | **gender** | **score** |
| ------ | -------- | ------------ | ---------- | --------- |
| 1      | 小明     | 1            | M          | 90        |
| 2      | 小红     | 1            | F          | 95        |
| 3      | 小军     | 1            | M          | 88        |
| 4      | 小米     | 1            | F          | 73        |
| 5      | 小白     | 2            | F          | 81        |
| 6      | 小兵     | 2            | M          | 55        |
| 7      | 小林     | 2            | M          | 85        |
| 8      | 小新     | 3            | F          | 91        |
| 9      | 小王     | 3            | M          | 89        |
| 10     | 小丽     | 3            | F          | 88        |

```sql
SELECT * FROM classes;
```

| **id** | **name** |
| ------ | -------- |
| 1      | 一班     |
| 2      | 二班     |
| 3      | 三班     |
| 4      | 四班     |

假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。而存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。这时，连接查询就派上了用场。

### 5.1 INNER JOIN

INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。

```sql
-- 选出所有学生，同时返回班级名称
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
```

| **id** | **name** | **class_id** | **class_name** | **gender** | **score** |
| ------ | -------- | ------------ | -------------- | ---------- | --------- |
| 1      | 小明     | 1            | 一班           | M          | 90        |
| 2      | 小红     | 1            | 一班           | F          | 95        |
| 3      | 小军     | 1            | 一班           | M          | 88        |
| 4      | 小米     | 1            | 一班           | F          | 73        |
| 5      | 小白     | 2            | 二班           | F          | 81        |
| 6      | 小兵     | 2            | 二班           | M          | 55        |
| 7      | 小林     | 2            | 二班           | M          | 85        |
| 8      | 小新     | 3            | 三班           | F          | 91        |
| 9      | 小王     | 3            | 三班           | M          | 89        |
| 10     | 小丽     | 3            | 三班           | F          | 88        |

注意INNER JOIN查询的写法是：

1. 先确定主表，仍然使用`FROM <表1>`的语法；
2. 再确定需要连接的表，使用`INNER JOIN <表2>`的语法；
3. 然后确定连接条件，使用`ON <条件...>`，这里的条件是`s.class_id = c.id`，表示`students`表的`class_id`列与`classes`表的`id`列相同的行需要连接；
4. 可选：加上`WHERE`子句、`ORDER BY`等子句。
5. 使用别名不是必须的，但可以更好地简化查询语句。       

### 5.2 RIGHT OUTER JOIN

RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。

```sql
-- 使用OUTER JOIN
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
```

| **id** | **name** | **class_id** | **class_name** | **gender** | **score** |
| ------ | -------- | ------------ | -------------- | ---------- | --------- |
| 1      | 小明     | 1            | 一班           | M          | 90        |
| 2      | 小红     | 1            | 一班           | F          | 95        |
| 3      | 小军     | 1            | 一班           | M          | 88        |
| 4      | 小米     | 1            | 一班           | F          | 73        |
| 5      | 小白     | 2            | 二班           | F          | 81        |
| 6      | 小兵     | 2            | 二班           | M          | 55        |
| 7      | 小林     | 2            | 二班           | M          | 85        |
| 8      | 小新     | 3            | 三班           | F          | 91        |
| 9      | 小王     | 3            | 三班           | M          | 89        |
| 10     | 小丽     | 3            | 三班           | F          | 88        |
| NULL   | NULL     | NULL         | 四班           | NULL       | NULL      |

和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。

这也容易理解，因为根据ON条件`s.class_id = c.id`，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。

### 5.3 LEFT OUTER JOIN

LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL

```sql
-- 先增加一列class_id=5:
INSERT INTO students (class_id, name, gender, score) values (5, '新生', 'M', 88);
-- 使用LEFT OUTER JOIN
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
LEFT OUTER JOIN classes c
ON s.class_id = c.id;
```

| **id** | **name** | **class_id** | **class_name** | **gender** | **score** |
| ------ | -------- | ------------ | -------------- | ---------- | --------- |
| 1      | 小明     | 1            | 一班           | M          | 90        |
| 2      | 小红     | 1            | 一班           | F          | 95        |
| 3      | 小军     | 1            | 一班           | M          | 88        |
| 4      | 小米     | 1            | 一班           | F          | 73        |
| 5      | 小白     | 2            | 二班           | F          | 81        |
| 6      | 小兵     | 2            | 二班           | M          | 55        |
| 7      | 小林     | 2            | 二班           | M          | 85        |
| 8      | 小新     | 3            | 三班           | F          | 91        |
| 9      | 小王     | 3            | 三班           | M          | 89        |
| 10     | 小丽     | 3            | 三班           | F          | 88        |
| 11     | 新生     | 5            | NULL           | M          | 88        |

RIGHT OUTER JOIN和INNER JOIN相比的差异同上。

### 5.4 FULL JOIN

```sql
-- 使用FULL OUTER JOIN
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
FULL OUTER JOIN classes c
ON s.class_id = c.id;
```

| **id** | **name** | **class_id** | **class_name** | **gender** | **score** |
| ------ | -------- | ------------ | -------------- | ---------- | --------- |
| 1      | 小明     | 1            | 一班           | M          | 90        |
| 2      | 小红     | 1            | 一班           | F          | 95        |
| 3      | 小军     | 1            | 一班           | M          | 88        |
| 4      | 小米     | 1            | 一班           | F          | 73        |
| 5      | 小白     | 2            | 二班           | F          | 81        |
| 6      | 小兵     | 2            | 二班           | M          | 55        |
| 7      | 小林     | 2            | 二班           | M          | 85        |
| 8      | 小新     | 3            | 三班           | F          | 91        |
| 9      | 小王     | 3            | 三班           | M          | 89        |
| 10     | 小丽     | 3            | 三班           | F          | 88        |
| 11     | 新生     | 5            | NULL           | M          | 88        |
| NULL   | NULL     | NULL         | 四班           | NULL       | NULL      |

最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL。

## 5.5 图解连接查询

假设查询语句如下，结合下图，我们把tableA看作左表，把tableB看成右表：

```sql
SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;
```

- INNER JOIN是选出两张表都存在的记录：

    ![inner-join](https://chua-n.gitee.io/blog-images/notebooks/数据库/1.png)

- LEFT OUTER JOIN是选出左表存在的记录：

    ![left-outer-join](https://chua-n.gitee.io/blog-images/notebooks/数据库/2.png)

- RIGHT OUTER JOIN是选出右表存在的记录：

    ![right-outer-join](https://chua-n.gitee.io/blog-images/notebooks/数据库/3.png)

- FULL OUTER JOIN则是选出左右表都存在的记录：

    ![full-outer-join](https://chua-n.gitee.io/blog-images/notebooks/数据库/4.png)

要意识到连接只是一种机制，用来在一条SELECT语句中关联表，其不是物理实体，换句话说，它在实际的数据库表中不存在，仅存在于查询的执行当中。

## 6、笛卡尔查询示例

由没有连接条件的表关系返回的结果为笛卡尔积，即一个表中中的每一个将与另一个表中的每个配对而不管它们是否逻辑上可以在一起，如同时从students表和classes表查询数据：

```sql
-- FROM students, classes:
```

| **id** | **class_id** | **name** | **gender** | **score** | **id** | **name** |
| ------ | ------------ | -------- | ---------- | --------- | ------ | -------- |
| 1      | 1            | 小明     | M          | 90        | 1      | 一班     |
| 1      | 1            | 小明     | M          | 90        | 2      | 二班     |
| 1      | 1            | 小明     | M          | 90        | 3      | 三班     |
| 1      | 1            | 小明     | M          | 90        | 4      | 四班     |
| 2      | 1            | 小红     | F          | 95        | 1      | 一班     |
| 2      | 1            | 小红     | F          | 95        | 2      | 二班     |
| 2      | 1            | 小红     | F          | 95        | 3      | 三班     |
| 2      | 1            | 小红     | F          | 95        | 4      | 四班     |
| 3      | 1            | 小军     | M          | 88        | 1      | 一班     |
| 3      | 1            | 小军     | M          | 88        | 2      | 二班     |
| 3      | 1            | 小军     | M          | 88        | 3      | 三班     |
| 3      | 1            | 小军     | M          | 88        | 4      | 四班     |
| 4      | 1            | 小米     | F          | 73        | 1      | 一班     |
| 4      | 1            | 小米     | F          | 73        | 2      | 二班     |
| 4      | 1            | 小米     | F          | 73        | 3      | 三班     |
| 4      | 1            | 小米     | F          | 73        | 4      | 四班     |
| 5      | 2            | 小白     | F          | 81        | 1      | 一班     |
| 5      | 2            | 小白     | F          | 81        | 2      | 二班     |
| 5      | 2            | 小白     | F          | 81        | 3      | 三班     |
| 5      | 2            | 小白     | F          | 81        | 4      | 四班     |
| 6      | 2            | 小兵     | M          | 55        | 1      | 一班     |
| 6      | 2            | 小兵     | M          | 55        | 2      | 二班     |
| 6      | 2            | 小兵     | M          | 55        | 3      | 三班     |
| 6      | 2            | 小兵     | M          | 55        | 4      | 四班     |
| 7      | 2            | 小林     | M          | 85        | 1      | 一班     |
| 7      | 2            | 小林     | M          | 85        | 2      | 二班     |
| 7      | 2            | 小林     | M          | 85        | 3      | 三班     |
| 7      | 2            | 小林     | M          | 85        | 4      | 四班     |
| 8      | 3            | 小新     | F          | 91        | 1      | 一班     |
| 8      | 3            | 小新     | F          | 91        | 2      | 二班     |
| 8      | 3            | 小新     | F          | 91        | 3      | 三班     |
| 8      | 3            | 小新     | F          | 91        | 4      | 四班     |
| 9      | 3            | 小王     | M          | 89        | 1      | 一班     |
| 9      | 3            | 小王     | M          | 89        | 2      | 二班     |
| 9      | 3            | 小王     | M          | 89        | 3      | 三班     |
| 9      | 3            | 小王     | M          | 89        | 4      | 四班     |
| 10     | 3            | 小丽     | F          | 88        | 1      | 一班     |
| 10     | 3            | 小丽     | F          | 88        | 2      | 二班     |
| 10     | 3            | 小丽     | F          | 88        | 3      | 三班     |
| 10     | 3            | 小丽     | F          | 88        | 4      | 四班     |

上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理。要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：

```sql
SELECT
    students.id sid,
    students.name,
    students.gender,
    students.score,
    classes.id cid,
    classes.name cname
FROM students, classes;

-- 以下也可

SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;
```

## 7、注意事项

为执行一个查询，通常也不一定只有一种实现方法，很少有绝对正确或绝对错误的方法，性能可能会受操作类型、表中数据量、是否存在索引或键等一些条件的影响，因此，有必要对不同的选择机制进行实验，以找出最适合具体情况的办法。