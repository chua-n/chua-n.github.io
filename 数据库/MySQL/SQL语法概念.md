## 1. 基础语法

- 大小写：SQL语句**不区分大小写**，因此SELECT与select，甚至与Select是等价的。

    > 一些SQL的开发习惯：
    >
    > 1. 对所有SQL关键字使用大写；
    >
    > 2. 对所有列和表名使用小写。

- 空格：在处理SQL语句时，其中所有的空格都被忽略，SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。

- 关键字：作为MySQL语言组成部分的一个保留字，决不可用关键字命名一个表或列。

- 语句：

    - 子句(clause)——SQL语句由子句构成，有些子句是必需的，有的是可选的。一个子句通常由一个关键字和所提供的数据组成，如SELECT语句的FROM子句。
    - 多条SQL语句必须以 **分号(;)** 分隔；在MySQL命令行内，单条SQL语句也必须加上分号来结束。

- 自动增量：在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值，此即所谓的自动增量。

    - 如果需要它，则必须在CREATE语句创建表时把它作为表定义的组成部分。
    - 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）

- 完全限定的名字：

    - 完全限定的列名：`  SELECT products.prod_name FROM products;  `
    - 完全限定的表名：`  SELECT products.prod_name FROM crashcourse.products;  `

- 更改语句分割符：如果命令行实用程序要解释存储过程自身内的`;`字符，需如下解决，临时更改命令行实用程序的语句分隔符：

    ```sql
    DELIMITRE //
    
    CREATE PROCEDURE productpricing()
    BEGIN
    	SELECT Avg(prod_price) AS priceaverage
    	FROM products;
    END //
    
    DELIMITER ;
    ```

    > 其中，`DELIMITER //` 告诉命令行实用程序用`//`作为新的语句结束分隔符，可以看到标志存储过程结束的`END`定义为`END //`而不是`END`;
    > 最后，为恢复为原来的语句分隔符，可使用`DELIMITER ;`
    > 除`\`符号外，任何字符都可以用作语句分隔符。

- 字符串：字符串用单引号`''`来限定。

- 注释：MySQL中注释符号为`--`

- 日期格式：MySQL使用的日期格式为：`yyyy-mm-dd`。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性。

- 简化字符：MySQL不支持简化字符`*=`和`=*`等的使用，虽然这两种操作符在其他DBMS中很流行。

- 数据的格式化：这是一个表示问题，而不是一个检索问题，表示一般在显示该数据的应用程序中规定。

- 字典排序：在**字典排序**顺序中，A被视为与a相同，这是MySQL和大多数DBMS的默认行为。如果在排序时确实需要不按这种字典排序，用简单的ORDER BY子句是做不到的，必须请求数据库管理员的帮助。

- 计算字段：有时，存储在表中的数据不是应用程序直接需要的，我们需要在从数据库中查询出数据时进行计算或格式化上的转化；尽管你也可以先检索出数据然后在客户机上重新完成你需要的转换，但通常不建议这么做，因为DBMS能完成的相应工作都进行过相应的优化，这就是计算字段发挥作用的所在。

    - 计算字段并不实际存在于数据库表中，其是运行时在SELECT语句内创建的。
    - 字段基本上与列的意思相同，也经常互换使用，不过还是应该认为它是计算过程中发挥着类似列的作用的虚拟产物。

## 2. 数据类型

对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：

|      名称      |      类型      | 说明                                                         |
| :------------: | :------------: | ------------------------------------------------------------ |
|     `INT`      |      整型      | 4字节整数类型，范围约+/-21亿                                 |
|    `BIGINT`    |     长整型     | 8字节整数类型，范围约+/-922亿亿                              |
|     `REAL`     |     浮点型     | 4字节浮点数，范围约+/-1038                                   |
|    `DOUBLE`    |     浮点型     | 8字节浮点数，范围约+/-10308                                  |
| `DECIMAL(M,N)` |   高精度小数   | 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 |
|   `CHAR(N)`    |   定长字符串   | 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 |
|  `VARCHAR(N)`  |   变长字符串   | 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 |
|   `BOOLEAN`    |    布尔类型    | 存储True或者False                                            |
|     `DATE`     |    日期类型    | 存储日期，例如，2018-06-22                                   |
|     `TIME`     |    时间类型    | 存储时间，例如，12:20:59                                     |
|   `DATETIME`   | 日期和时间类型 | 存储日期+时间，例如，2018-06-22 12:20:59                     |

上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，`REAL`又可以写成`FLOAT(24)`。还有一些不常用的数据类型，例如，`TINYINT`（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。

选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，`BIGINT`能满足整数存储的需求，`VARCHAR(N)`能满足字符串存储的需求，这两种类型是使用最广泛的。

## 3. 其他关键字

- `NULL`：NULL表示无值，但注意NULL非零、非空串、非空格串。

    ```sql
    SELECT prod_name
    FROM products
    WHERE prod_price IS NULL;
    ```

- `NOT/AND/OR`：逻辑操作符。

    - 优先级NOT >AND > OR

    - MySQL支持NOT对IN, BETWEEN, EXISTS子句取反

        ```sql
        SELECT prod_name, prod_price
        FROM products
        WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price >= 10;
        
        -- 以下与上等价
        SELECT prod_name, prod_price
        FROM products
        WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price >= 10;
        ```

        ```sql
        SELECT prod_name, prod_price
        FROM products
        WHERE vend_id NOT IN (1002, 1003)
        ORDER BY prod_name;
        ```

- `DESC/ASC`：降序/升序排序，默认为升序。

    > 其只应用到直接位于其前面的列；若想将多个列降序，必须挨个指定DESC。

    ```sql
    SELECT prod_id, prod_price, prod_name
    FROM products
    ORDER BY prod_price DESC, prod_name;
    ```

- `AS`：SQL允许给列和表赋予别名，有了别名后任何客户端应用都可以按别名引用这个列，就像它是一个实际的表列一样。

    ```sql
    SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ')') AS vend_title
    FROM vendors
    ORDER BY vend_name;
    ```

- `ALL/DISTINCT`：指示MySQL返回全部的值/对重复的值只返回唯一的代表值。

    - 默认总是ALL

    - DISTINCT关键字应用于所有列而不仅是前置它的列。

        ```sql
        SELECT DISTINCT vend_id, prod_price
        FROM products
        -- 也就是说这里的prod_price其实也相当于有前置的DISTINC
        ```

- `WITH ROLLUP`：可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。

    

    ```sql
    SELECT vend_id, COUNT(*) AS num_prods
    FROM products
    GROUP BY vend_id WITH ROLLUP;
    ```

- 通配符`%`与`_`：

    - `%`表示任意字符（不含NULL）出现任意次数（含0次）

        ```sql
        SELECT prod_name
        FROM products
        WHERE prod_name LIKE 's%e';
        ```

    - `_`表示只匹配单个字符

        ```sql
        SELECT prod_id, prod_name
        FROM products
        WHERE prod_name LIKE '_ ton anvil';
        ```

- `REGEXP`：指示使用正则表达式匹配（MySQL支持正则表达式实现的一个很小的子集）。

    ```sql
    SELECT prod_name
    FROM pdoducts
    WHERE prod_name REGEXP '1000'
    ORDER BY prod_name;
    ```

- `\\`：转义操作符。

    | 字符  | 说明        |
    | ----- | ----------- |
    | `\\.` | 匹配.       |
    | `\\\` | 匹配反斜杠\ |
    | `\\f` | 换页        |
    | `\\n` | 换行        |
    | `\\r` | 换车        |
    | `\\t` | 制表        |
    | `\\v` | 纵向制表    |

- 字符类：

    |     类     |                       说明                        |
    | :--------: | :-----------------------------------------------: |
    | [:alnum:]  |           任意字母和数字（同[a-zA-Z0-9]           |
    | [:alpha:]  |              任意字符（同[a-zA-Z]）               |
    | [:blank:]  |              空格和制表（同`[\\t]`）              |
    | [:cntrl:]  |         ASCII控制字符（ASCII 0到31和127）         |
    | [:digit:]  |                任意数字（同[0-9]）                |
    | [:graph:]  |           与[:print:]相同，但不包括空格           |
    | [:lower:]  |              任意小写字母（同[a-z]）              |
    | [:print:]  |                  任意可打印字符                   |
    | [:punct:]  |    既不在[:alnum:]又不在[:cntrl:]中的任意字符     |
    | [:space:]  | 包括空格在内的任意空白字符（同`[\\f\\n\\r\\t\\v]` |
    | [:upper:]  |              任意大写字母（同[A-Z]）              |
    | [:xdigit:] |         任意十六进制数字（同[a-fA-F0-9]）         |

- MySQL的算术操作符：

    | 操作符 | 说明 |
    | :----: | :--: |
    |   +    |  加  |
    |   -    |  减  |
    |   *    |  乘  |
    |   /    |  除  |

    > 虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便**简单地访问和处理表达式**。如
    >
    > - `SELECT 2*3;`：返回6
    > - `SELECT Trim('abc');`：返回'abc'
    > - `SELECT Now();`：返回当前日期和时间

## 4. 主键-外键-索引

### 4.1 主键

对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为**主键(primary key)** 。

对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。

1. 如果我们以学生的身份证号作为主键，似乎能唯一定位记录，然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。
2. 所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。
3. 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为**id**。常见的可作为**id**字段的类型有：
    1. 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
    2. 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。

主键值也不能为null.

**联合主键**——关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。

对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：

| **id_num** | **id_type** | **other columns...** |
| ---------- | ----------- | -------------------- |
| 1          | A           | ...                  |
| 2          | A           | ...                  |
| 2          | B           | ...                  |

> 1. 如果我们把上述表的id_num和id_type这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。
> 2. 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。

### 4.2 外键

**外键**是某个表中的一列，它包含另一个表的主键值，定义了两个表的关系。

如，当我们用主键唯一标识记录时，我们就可以在students表中确定任意一个学生的记录：

| **id** | **name** | **other columns...** |
| ------ | -------- | -------------------- |
| 1      | 小明     | ...                  |
| 2      | 小红     | ...                  |

我们还可以在classes表中确定任意一个班级记录：

| **id** | **name** | **other columns...** |
| ------ | -------- | -------------------- |
| 1      | 一班     | ...                  |
| 2      | 二班     | ...                  |

但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个classes的记录可以对应多个students表的记录。为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应，这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。

| **id** | **class_id** | **name** | **other columns...** |
| ------ | ------------ | -------- | -------------------- |
| 1      | 1            | 小明     | ...                  |
| 2      | 1            | 小红     | ...                  |
| 5      | 2            | 小白     | ...                  |

在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。

外键并不是通过列名实现的，而是通过定义外键约束实现的：

```sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

> 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）
>
> 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。

要删除一个外键约束，也是通过ALTER TABLE实现的：

```sql
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

> 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP  COLUMN ...实现的 。

### 4.3 索引

在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。

索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

例如，对于students表：

| **id** | **class_id** | **name** | **gender** | **score** |
| ------ | ------------ | -------- | ---------- | --------- |
| 1      | 1            | 小明     | M          | 90        |
| 2      | 1            | 小红     | F          | 95        |
| 3      | 1            | 小军     | M          | 88        |

如果要经常根据score列进行查询，就可以对score列创建索引：

```sql
ALTER TABLE students
ADD INDEX idx_score (score);
```

使用`ADD INDEX idx_score (score)`就创建了一个名称为idx_score、使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：

```sql
ALTER TABLE students
ADD INDEX idx_name_score (name, score);
```

索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。

可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。

对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。

在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复：

```sql
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);
```

> 通过UNIQUE关键字我们就添加了一个唯一索引。
>
> 也可以只对某一列添加一个唯一约束而不创建唯一索引：
>
> ```sql
> ALTER TABLE students
> ADD CONSTRAINT uni_name UNIQUE (name);
> ```
>
> 这种情况下，name列没有索引，但仍然具有唯一性保证。

无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。
