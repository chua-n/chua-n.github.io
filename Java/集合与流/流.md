> 谓词：一个返回boolean值的函数。

## 1. 介绍

### 1.1 感性认知

流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。

> 在认识流的初始阶段，可以把它们看作遍历数据集的高级迭代器。

流还可以透明地并行处理，你无需写任何多线程代码了！

- Java7的写法：

    ```java
    List<Dish> lowCaloricDishes = new ArrayList<>();
    for (Dish d : menu) {
        if (d.getCalories() < 400) {
            lowCaloricDishes.add(d);
        }
    }
    // 用匿名类对菜肴排序
    Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
        public int compare(Dish d1, Dish d2) {
            return Integer.compare(d1.getCalories(), d2.getCalories());
        }
    });
    // 处理排序后的菜名列表
    List<String> lowCaloricDishesName = new ArrayList<>();
    for (Dish d : lowCaloricDishes) {
        lowCaloricDishesName.add(d.getName());
    }
    ```

    > 在这段代码中，使用了一个垃圾变量lowCaloricDishes，它唯一的作用就是作为一次性的中间容器。而在Java8中，实现的细节被放在它本该归属的库里了。

- Java8的写法：

    ```java
    import static java.util.Comparator.comparing;
    import static java.util.stream.Collectors.toList;
    
    List<String> lowCaloricDishesName =
        menu.stream()
        .filter(d -> d.getCalories() < 400) // 选出300卡路里以下的菜肴
        .sorted(comparing(Dish::getCalories)) // 按照卡路里排序
        .map(Dish::getName) // 提取菜肴名称
        .collect(toList()); // 所有名称保存在List中
    ```

    更进一步地，如果希望利用多核架构并执行这段代码，只需要把stream()换成parallelStream()即可：

    ```java
    List<String> lowCaloricDishesName =
        menu.parallelStream()
        .filter(d -> d.getCalories() < 400) // 选出300卡路里以下的菜肴
        .sorted(comparing(Dish::getCalories)) // 按照卡路里排序
        .map(Dish::getName) // 提取菜肴名称
        .collect(toList()); // 所有名称保存在List中
    ```

    > 因为filter, sorted, map, collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可以透明地充分利用你的多核架构，这些Stream API都替你做好了！

Java8新方式的好处是：

- 声明性——更简洁、更易读
- 可复合（链式结构）——更灵活
- 可并行——性能更好

### 1.2 严谨认知

流是从支持数据处理操作的源生成的元素序列。

- 元素序列：集合讲的是数据，流讲的是计算。
- 源：流会使用一个提供数据的源，如集合、数组、输入/输出资源。
- 数据处理操作：流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作，如filter, map, reduce, find, match, sort等。流操作有两个重要特点：
    - 流水线：很多流本身会返回一个流，这样多个操作可以链接起来，形成一个大的流水线；
    
    - 内部迭代：与使用迭代器显示迭代的集合不同，流的迭代操作是在背后进行的。
    
        ```java
        /*
        	下面这段代码来显示集合的for-each迭代、集合的迭代器迭代、流的迭代
        */
        
        // 集合：使用for-each循环外部迭代
        List<String> names = new ArrayList<>();
        for (Dish d : menu) {
            names.add(d.getName());
        }
        
        // 集合：用背后的迭代器做外部迭代
        List<String> names = new ArrayList<>();
        Iterator<Dish> iterator = menu.iterator();
        while (iterator.hasNext()) {
            Dish d = iterator.next();
            names.add(d.getName());
        }
        
        // 流：内部迭代
        List<String> names = menu.stream()
            .map(Dish::getName)
            .collect(Collectors.toList());
        ```

流与集合：

- 粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，
    它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。
- 相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。这对编程有很大的好处。从另一个角度来说，流就像是一个延迟创建的集合：只有在消费者要求的时候才会计算值。

## 2. 流操作

中间操作如filter, sorted等会返回另一个流，这个多个操作可以连接起来形成一个查询，而且，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理——它们很懒，这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。

### 2.1 中间操作

这个结果很有意思，其中的好几种优化利用了流中间操作的延迟性质：

![image-20210905142525562](https://chua-n.gitee.io/blog-images/notebooks/Java/55.png)

| 中间操作 | 作用                                                         | 返回类型   | 使用的类型/函数式接口     | 函数描述符      |
| -------- | ------------------------------------------------------------ | ---------- | ------------------------- | --------------- |
| filter   | 用谓词筛选过滤                                               | Stream\<T> | Predict\<T>               | T -> boolean    |
| distinct | 筛选各异的元素                                               | Stream\<T> |                           |                 |
| skip     | 跳过前long n个元素，如果流中元素不足n，返回一个空流          |            | long                      |                 |
| limit    | 截断流。<br />注意limit也可以用在无序流上，如源为Set的流，此时limit的结果也是无序的 | Stream\<T> | long                      |                 |
| map      | 对流中的每一个元素应用函数                                   | Stream\<R> | Function\<T, R>           | T -> R          |
| flatMap  | 流的扁平化——该方法与map不同的是，让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。 | Stream\<R> | Function\<T, Streeam\<R>> | T -> Stream\<R> |
| sorted   |                                                              | Stream\<T> | Comparator\<T>            | (T, T) -> int   |

#### map与flatMap的比较

![image-20210905144928862](https://chua-n.gitee.io/blog-images/notebooks/Java/56.png)

### 2.2 终端操作

终端操作会从流的流水线生成结果，其结果不再是流，可以为List, Integer, void等任何其他值。

| 终端操作  | 作用                                                         | 返回类型     | 使用的类型/函数式接口 | 函数描述符   |
| --------- | ------------------------------------------------------------ | ------------ | --------------------- | ------------ |
| anyMatch  |                                                              | boolean      | Predict\<T>           | T -> boolean |
| noneMatch |                                                              | boolean      | Predict\<T>           | T -> boolean |
| allMatch  |                                                              | boolean      | Predict\<T>           | T -> boolean |
| findAny   |                                                              | Optional\<T> |                       |              |
| findFirst |                                                              | Optional\<T> |                       |              |
| forEach   | 消费流中的每个元素并对其应用Lambda                           | void         | Consumer\<T>          | T -> void    |
| collect   | 把流归约成一个集合，如List, Map甚至是Interger                | R            | Collector<T, A, R>    |              |
| reduce    | “归约操作”，使用Lambda反复结合每个元素，直到流被归约成一个值。<br />reduce还有一个重载的变化，它不接受初始值，返回一个Optional对象 | Optional\<T> | BinaryOperator\<T>    | (T, T) -> T  |
| count     | 返回流中元素的个数                                           | long         |                       |              |

> findAny相比findFirst显然更容易执行并行化。

## 3. 数值流

### 3.1 数值流API

为避免暗含的装箱成本，Stream API提供了原始类型流特化，专门支持处理数值流的方法。具体而言，包含三个原始类型流特化接口：

| 原始类型流特化接口 | 生成方法（和map方法相同） | OPtional原始类型特化版本 |
| ------------------ | ------------------------- | ------------------------ |
| IntStream          | mapToInt                  | OptionalInt              |
| DoubleStream       | mapToDouble               | OptionalDouble           |
| LongStream         | mapToLong                 | OptionalLong             |

如果想要把特化流转换回非特化流，可以使用`boxed()`方法。例如:

```java
// 将Stream转换为数值流
IntStream intStream = menu.stream().mapToInt(Dish::getCalories); 
// 将数值流转换为Stream
Stream<Integer> stream = intStream.boxed(); 
```

关于Optional原始类型特化版本的使用，例如要找到IntStream中的最大元素，可以调用max方法，它会返回一个OptionalInt：

```java
OptionalInt maxCalories = menu.stream()
    .mapToInt(Dish::getCalories)
    .max();
// 此时，如果没有最大值的话，就可以显示处理OptionalInt去定义一个默认值了：
int max = maxCalories.orElse(1);
```

### 3.2 生成数值范围

Java8在IntStream和LongStream中提供了两个静态方法，可以用来生成数值范围：

- range：左闭右开区间
- rangeClosed：闭区间

## 4. 流的构建

除了从集合中构建流之外，流还可以从值序列、数组、文件中来创建，此外由生成函数还可以创建无限流。

### 4.1 集合

不再贅述

### 4.2 值序列

使用静态方法`Stream.of`通过显示值创建

```java
Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);
```

此外，还可以使用`Stream.empty`来创建一个空流：

```java
Stream<String> stream = Stream.empty();
```

### 4.3 数组

使用静态方法`Arrays.stream`。

```java
int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();
```

### 4.4 文件

Java中用于处理文件等I/O操作的NIO API已经随着java8的更新而可以利用Stream API。

```java
long uniqueWords = 0;
try (Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
    uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" "))) // 生成单词流
        .distinct() // 删除重复项
        .count(); // 数一数有多少各不相同的单词
} catch (IOException e) { // 如果打开文件时出现异常在这里处理

}
```

### 4.5 函数

Stream API提供了两个静态方法来从函数生成流——`Stream.iterate`, `Stream.generate`，它们都可以生成所谓的无限流，但一般来说会使用`limit(n)`来对这种流加以限制，以避免无穷的危险。

#### 4.5.1 Stream.iterate

一般来说，在需要依次生成一系列值的时候应该使用iterate，比如一系列日期。

```java
// 示例1
Stream.iterate(0, n -> n + 2)
    .limit(10)
    .forEach(System.out::println);
// 示例2——斐波纳契数列
Stream.iterate(new int[]{0, 1}, t -> new int[]{t[1], t[0] + t[1]})
    .limit(10)
    .map(t -> t[0])
    .forEach(System.out::println);
```

#### 4.5.2 Stream.generate

generate不是依次对每个新生成的值应用函数的，而是接受一个`Supplier<T>`类型的Lambda提供的新的值。

```java
// 示例1
Stream.generate(Math::random)
    .limit(5)
    .forEach(System.out::println);
// 示例2——斐波纳契数列
IntSupplier fib = new IntSupplier() {
    private int previous = 0;
    private int current = 1;

    public int getAsInt() {
        int oldPrevious = this.previous;
        int nextValue = this.previous + this.current;
        this.previous = this.current;
        this.current = nextValue;
        return oldPrevious;
    }
};
IntStream.generate(fib).limit(10).forEach(System.out::println);
```

## 5. 流的收集器

流的终端操作`collect`实际上是一个归约操作，将流中的元素累积成一个汇总结果，该归约操作通过Collector接口来参数化。此外Java8还提供了一个名为`Collectors`的工具类，其中有很多静态工厂方法可以方便地创建常见的收集器。

> 注意，这些概念不要跟Java集合体系的根接口`Collection`混淆了。

### Collectors类的静态工厂方法

| 工厂方法          | 返回类型               | 作用                                                         | 示例                                                         |
| ----------------- | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| toList            | List\<T>               | 把流中所有项目收集到一个List                                 | `List<Dish> dishes = menuStream.collect(toList())`           |
| toSet             | Set\<T>                | 把流中所有项目收集到一个Set，删除重复项                      | `Set<Dish> dishes = menuStream.collect(toSet())`             |
| toCollection      | Collection\<T>         | 把流中所有项目收集到给定的供应源创建的集合                   | `Collection<Dish> dishes = menuStream.collect(toCollection(), ArrayList::new)` |
| counting          | Long                   | 计算流中元素的个数                                           | `long howManyDishes = menuStream.collect(counting())`        |
| summingInt        | Integer                | 对流中项目的一个整数属性求和                                 | `int totalCalories = menuStream.collect(summingInt(Dish::getCalories))` |
| averagingInt      | Double                 | 计算流中项目Integer属性的平均值                              | `double avgCalories = menuStream.collect(averagingInt(Dish::getCalories))` |
| summarizingInt    | IntSummaryStatistics   | 惧关于流中项目Integer属性的统计值，如最大、最小、总和、平均值 | `IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories))` |
| joining           | String                 | 连接对流中的每个项目调用toString方法所生成的字符串           | `String shortMenu = menuSream.map(Dish::getName).collect(joining(", "));` |
| maxBy             | Optional\<T>           | 一个包裹了流中按照给定比较器选出的最大元素的Optional，或如果流为空则为Optional.empty() | `Optional<Dish> fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));` |
| minBy             | Optional\<T>           | 与上反                                                       | `Optional<Dish> lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));` |
| reducing          | 归约操作产生的类型     | 从一个作为累加器的初始值开始，利用BinaryOperator与流中的元素逐个结合，从而将流归约为单个值 | `int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));` |
| collectingAndThen | 转换函数返回的类型     | 包裹另一个收集器，对其结构应用转换函数                       | `int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size));` |
| groupingBy        | Map<K, List\<T>>       | 根据项目的一个属性的值对流中的项目作分组，并将属性值作为结果Map的键 | `Map<Dish.Type, List<Dish>> dishesByType = menuStream.collect(groupingBy(Dish::getType))` |
| partitioningBy    | Map<Boolean, List\<T>> | 根据对流中每个项目应用谓词的结果来对项目进行分区             | `Map<Boolean, List<Dish>> vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian))` |

### Collector接口

Collector接口包含了一系列方法，为实例具体的归约操作（即收集器）提供了范本。

> 我们已经看过了Collector接口中实现的许多收集器，例如toList, groupingBy。

你也可以为Collector接口提供自己的实现，从而自由地创建自定义归约操作。Collector接口中声明了5个方法：

> 其中前4个都会返回一个会被collect方法调用的函数，而第5个方法则提供了一系列特征，也就是一个提示列表，告诉collect方法在执行归约操作的时候可以应用哪些优化（比如并行化）。

- supplier方法：建立新的结果容器
- accumulator方法：将元素添加到结果容器
- finisher方法：对结果容器应用最终转换
- combiner方法：合并两个结果容器
- characteristics方法：...

....................暂略..................

## 6. 流的并行化

并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。

对于流，顺序流与并行流之间的转换非常容易：

- 顺序流 -> 并行流：`parallel()`
- 并行流 -> 顺序流：`sequential()`

本节通过示例来说明：

```java
long n = 100000000L;
Long sum;

// 顺序流
sum = Stream.iterate(1L, i -> i + 1)
    .limit(n)
    .reduce(0L, Long::sum);
System.out.println("顺序流：" + sum);

// 并行流
sum = Stream.iterate(1L, i -> i + 1)
    .limit(n)
    .parallel() // 将流转化为并行流，使得归约过程（求和）并行运行
    .reduce(0L, Long::sum);
System.out.println("并行流：" + sum);
```

对于上面的并行流，Stream在内部分成了几块，因而可以对不同的块独立并行进行归纳操作，最后进行汇总，如下图：

![image-20210905164900105](https://chua-n.gitee.io/blog-images/notebooks/Java/57.png)

值得一提的是，在现实中，对顺序流调用`parallel`方法并不意味着流本身有任何实际的变化，它 在内部其实只是设了一个boolean标志，表示你想让调用parallel之后进行的所有操作都并行执行。类似地，你只需要对并行流调用`sequential`方法就可以把它变成顺序流。

需要注意的是，你可能以为能够把`parallel`和`sequential`两个方法结合起来，从而更细化地控制在遍历流时哪些操作要并行执行，哪些要顺序执行，但这样是不行的，因为这两个方法的最后一次调用会影响整个流水线。也就是行，下面的流水线其实是并行执行的：

```java
// 这段代码相当于只有出现在最后的那个parallel()生效
stream.parallel()
    .filter(...)
    .sequential()
    .map(...)
    .parallel()
    .reduce();
```

...................还有不少东西，以后再说吧...................

## 另：Optional类

`Optional<T>`类（java.util.Optional）是一个容器类，代表一个值存在或不存在。

| 方法                          | 作用                                            |
| ----------------------------- | ----------------------------------------------- |
| isPresent()                   | Optional包含值的时候返回true，否则为false       |
| ifPresent(Consumer\<T> block) | 在Optional包含值的时候执行给定代码块            |
| T get()                       | 在值存大时返回值，否则抛出一个NoSuchElement异常 |
| T orElese(T other)            | 在值存在时返回值，否则返回一个默认值            |

