装饰器模式，即将某个类重新装扮一下，使得它比原来更“漂亮”，或者在功能上更强大，这就是装饰器模式所要达到的目的，而作为原来的这个类的使用者不应该感受到装饰前与装饰后有什么不同，即不应破坏原有类的结构，这意味着装饰器模式要做到对被装饰类的使用者透明。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/62.png" style="zoom:67%;" />

- Component——抽象组件角色，定义一组抽象的接口，规定这个被装饰组件都有哪些功能
- ConcreteComponent——实现这个抽象组件的所有功能
- Decorator——装饰器角色，它持有一个Component对象实例的引用，定义一个与抽象组件一致的接口
- ConcreteDecorator——具体的装饰器实现者，负责实现装饰器角色定义的功能

Java I/O中的装饰器模式：

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/63.png" style="zoom:67%;" />

- 抽象组件：`InputStream`
- 具体组件：`FileInputStream`
- 装饰角色：`FilterInputStream`
- 具体的装饰器实现者：`BufferedInputStream`

装饰器与适配器模式都有一个别名就是包装模式（Wrapper），它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一样。

- 适配器模式的意义是要将一个接口转变成另外一个接口，它的目的是通过改变接口来达到重复使用的目的；
- 而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方法而提升性能。

