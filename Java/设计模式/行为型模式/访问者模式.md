访问者模式一般有抽象访问者、具体访问者、抽象节点元素、具体节点元素、结构对象和客户端几种角色，其具体作用为：

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/64.png" style="zoom:67%;" />

- 抽象访问者（Visitor）——声明所有访问者需要的接口
- 具体访问者（ConcreteVisitor）——实现抽象访问者声明的接口
- 抽象节点元素（Element）——提供一个接口，能够接受访问者作为参数传递给节点元素
- 具体节点元素（ConcreteElement）——实现抽象节点元素声明的接口
- 结构对象（ObjectStructure）——提供一个接口，能够访问到所有的节点元素，一般作为一个集合特有节点元素的引用
- 客户端（Client）——分别创建访问者和节点元素的对象，调用访问者访问变量节点元素

访问者模式可以将数据结构和对数据结构的操作解耦，使得增加对数据结构的操作不需要去修改数据结构，也不必去修改原有的操作，再执行时再定义新的Visitor实现者就行了。

Javac中的访问者模式——在Javac中，不同的编译阶段都定义了不同的访问者模式实现：

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/65.png" style="zoom:67%;" />

Vistor无疑是作为抽象访问者角色的，而TreeScanner, Enter, Attr, Gen, Flow等都是作为具体访问者角色的，每个访问者角色都定义了自己的访问规则。而Tree接口就是抽象节点元素，JCIf, JCTry, JCBreak, JCReturn等都是作为具体节点元素的，它们作为一个稳定的数据结构存在。其中的JCCompilationUnit作为结构对象持有整个语法树，而JavaCompiler就是Client了。它同时持有ObjectStructure和ConcreteElement对象，即可以使访问者访问节点元素。

下面再看看访问者是如何访问节点元素的，为什么不同的访问者可以访问同一套数据结构，而访问者的行为却可以各自不同，下图是访问者变量语法树的时序图：

![](https://chua-n.gitee.io/blog-images/notebooks/Java/66.png)

Enter作为一个访问者，实现了抽象访问者Visitor中的所有接口，但是Enter这个访问者具体要实现什么功能由Enter自己定义。遍历这棵树使用统一接口accept，每个节点元素都实现这具accept接口，但是不同节点元素的accept的实现是不同的，以区分不同的节点元素对应不同的功能。