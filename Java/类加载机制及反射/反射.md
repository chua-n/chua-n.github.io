## 1. 查看类信息

程序需要在运行时发现对象和类的真实信息时，可以有两种做法：

1. 若在编译时和运行时都完全知道类型的具体信息，此时可以先使用 instanceof 运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可；
2. 当编译时根本无法预知该对象和类可能属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息时，必须使用反射。

### 1.1 获得 Class 对象

在 Java 程序中获得 Class 对象通常有三种方式：

1. 使用 Class 类的 forName(String className)静态方法；
2. 调用某个类的 class 属性来获取该类对应的 Class 对象；
3. 调用某个对象的 getClass()方法。

```java
package com.chuan;

public class Test {
    public static void main(String[] args) throws ClassNotFoundException {
        System.out.println(Test.class);
        System.out.println(new Test().getClass());
        System.out.println(Class.forName("com.chuan.Test"));
        
        /*
         输出：
         class com.chuan.Test
         class com.chuan.Test
         class com.chuan.Test
         */
    }
}
```

### 1.2 Executable 抽象基类

java.lang.reflect 包下有一个**Executable 抽象基类**，该对象代表可执行的类成员，该类派生了 Constructor, Method 两个子类。

| Executable 基类的方法         |                                         |
| ----------------------------- | --------------------------------------- |
| `isVarArgs()`                 | 判断该方法/构造器是否包含数量可变的形参 |
| `getModifiers()`              | 获取该方法/构造器的修饰符               |
| `int getParameterCount()`     | 获取该构造器/方法的形参个数             |
| `Parameter[] getParameters()` | 获取该构造器/方法的所有形参             |

### 1.3 Parameter 类

Parameter 类：每个 Parameter 对象代表方法/构造器的一个参数，其方法有：

| 方法                          | 作用                                              |
| ----------------------------- | ------------------------------------------------- |
| `getModifiers()`              | 获取修饰该形参的修饰符                            |
| `String getName()`            | 获取形参名                                        |
| `Type getParameterizedType()` | 获取带泛型的形参类型                              |
| `Class<?> getType()`          | 获取形参类型                                      |
| `boolean isNamePresent()`     | 返回该类的 Class 文件中是否包含了方法的形参名信息 |
| `boolean isVarArgs()`         | 判断该参数是否为个数可变的形参                    |

需要指出的是，使用 javac 命令编译 Java 源文件时，默认生成的 class 文件并不包含方法的形参名信息，因此调用 `isNamePresent()`方法将返回 false，调用 `getName()`方法也不能得到该参数的形参名。若希望 javac 命令编译 Java 源文件时可以保留形参信息，需要为该命令指定-parameters 选项。

## 2. 生成并操作对象

通过反射创建对象时性能要稍低一些，实际上，只有当程序需要动态创建某个类的对象时才会考虑反射，通常在开发通用性比较广的框架、基础平台时可能会大量使用反射。

### Constructor

通过反射来生成对象需要先使用 Class 对象获取对应的 Constructor 对象，再调用Constructor 对象的`newInstance()`方法来创建该 Class 对象对应类的实例。

### Method

每个 Method 对象对应一个方法，获得 Method 对象后，程序就可通过该 Method 来调用它对应的方法。

-   在 Method 里包含一个`invoke()`方法，其方法的签名如下：

    ```java
    // 其中obj是执行该方法的主调，后面的args是执行该方法时传入该方法的实参
    Object invoke(Object obj, Object… args)
    ```

-   当通过 Method 的 invoke()方法调用对应的方法时，Java 要求程序必须有调用该方法的权限。若程序确实需要调用某个对象的 private 方法，可以利用 Method 父类 `AccessibleObject` 类提供的 `setAccessible()`方法（Method, Constructor, Field 均是 AccessibleObject 的子类，因而其实均可以调用此方法）：

    ```java
    // 将Method对象的accessible设置为指定的布尔值，指示该Method在使用时是否取消Java语言的访问权限检查。
    setAccessible(boolean flag)
    ```

### Field

Field 提供了如下两组方法来读取或设置成员变量值：

| 方法                          | 作用                                 |
| ----------------------------- | ------------------------------------ |
| `getXxx(Object obj)`          | 获取 obj 对象的该成员变量的值        |
| `setXxx(Object obj, Xxx val)` | 将 obj 对象的该成员变量设置成 val 值 |

### Array

java.lang.reflect 包下的 Array 类可以代表所有的数组，程序可通过使用 Array 来动态地创建数组、操作数组元素等。Array 提供的方法有：

| 方法                                                         | 作用                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| `static Object newInstance(Class<?> componentType, int… length)` | 创建一个具有指定元素类型、指定维度的新数组 |
| `static xxx getXxx(Object array, int index)`                 |                                            |
| `static void setXxx(Object array, int index, xxx val)`       |                                            |

## 3. 生成 JDK 动态代理

> 关于动态代理见博客 [代理模式 | 这里是川！ (chua-n.com)](https://www.chua-n.com/2021/02/07/代理模式/)

java.lang.reflect 包下提供了一个**Proxy 类**和一个**InvocationHandler 接口**，用它们可以生成 JDK 动态代理或动态代理对象。

> 注意 JDK 动态代理只能为接口创建动态代理。

Proxy 提供了用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类。如果在程序中为一个或多个接口动态地生成实现类，就可以使用 Proxy 来创建动态代理类；如果需要为一个或多个接口动态地创建实例，也可以使用 Proxy 来创建动态代理实例。

---

Proxy 提供了两个方法来创建动态代理类和动态代理实例：

-   `static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces)`：创建一个动态代理类所对应的 Class 对象，该代理类将实现 interfaces 所指定的多个接口。

    -   此时生成动态代理类之后，如果程序需要通过该代理类来创建对象，依然需要传入一个 InvocationHandler 对象。

-   `static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`：直接创建一个动态代理对象，该代理对象的实现类实现了 interfaces 指定的系列接口，执行代理对象的每个方法时都会被替换执行 InvocationHandler 对象的 invoke 方法。

> 综上，系统生成的每个代理对象都有一个与之关联的 InvocationHandler 对象。

---

定义 InvocationHandler 接口的实现类时需要重写`invoke()`方法——调用代理对象的所有方法时都会被替换成调用该 invoke()方法，该 invoke()方法中的三个参数解释如下：

| 参数   | 作用                         |
| ------ | ---------------------------- |
| proxy  | 代表动态代理对象             |
| method | 代表正在执行的方法           |
| args   | 代表调用目标方法时传入的实参 |

---

这种动态代理在 AOP 中被称为 AOP 代理，AOP 代理可代替目标对象，AOP 代理包含了目标对象的全部方法。但 AOP 代理中的方法与目标对象的方法存在差异：AOP 代理里的方法可以在执行目标方法之前、之后插入一些通用处理。

## 4. 反射和泛型

Java 允许使用泛型来限制`Class`类，例如`String.class`的类型实际上是`Class<String>`。如果对 Class 对应的类暂时未知，则使用`Class<?>`。

通过在反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。

还有一些内容，使用反射来获取泛型信息等，以后再说吧……
