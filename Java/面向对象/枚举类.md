## 1. 概念引入

有时候，一个类的对象是有限且固定的，比如季节类只有 4 个对象，行星类只有 8 个对象，这种实例有限且固定的类，在 Java 里被称为**枚举类**。

同样地，一个 Java 源文件最多只能定义一个 public 访问权限的枚举类，且该 Java 源文件也必须和该枚举类的类名相同。

Java 5 新增了**enum\*\***关键字\*\*用来定义枚举类，enum 关键字与 class, interface 的地位相同，枚举类属于一种特殊的类。不过它与普通类有如下简单区别：

-   枚举类可以实现一个或多个接口，使用 enum 定义的枚举类默认继承了 java.lang.Enum 类，而非 Object 类，因而枚举类不能显式继承其他父类；
-   java.lang.Enum 类实现了 java.io.Serializable 和 java.lang.Comparable 两个接口；
-   使用 enum 定义、非抽象的枚举类默认会使用 final 修饰，所以枚举类不能派生子类；
-   枚举类的构造器为 private 权限，如程序员省略也会被系统默认添加上去；
-   枚举类的所有实例（即枚举值）必须在枚举类的第一行显式列出，否则这个枚举类永远不能产生实例，且这些实例被 public static final 修饰，程序员无须显式添加；
-   枚举类默认提供了一个 values()方法，可以方便地遍历所有的枚举值。

枚举类举例：

```java
enum SeasonEnum {
    // 在第一行列出4个枚举实例
    SPRING, SUMMER, FALL, WINTER;
}

class EnumTest {
    public void judge(SeasonEnum s) {
        switch (s) {
                // switch的控制表达式使用枚举类型时
                // case表达式中的值可以直接使用枚举值的名字，无须添加枚举类名作为限定
            case SPRING:
                System.out.println("春暖花开，正好踏青");
                break;
            case SUMMER:
                System.out.println("夏日炎炎，适合游泳");
                break;
            case FALL:
                System.out.println("秋高气爽，进补及时");
                break;
            case WINTER:
                System.out.println("冬日雪飘，围炉赏雪");
                break;
        }
    }

    public static void main(String[] args) {
        for (SeasonEnum s : SeasonEnum.values())
            System.out.println(s);
        new EnumTest().judge(SeasonEnum.SPRING);
    }
}
```

以下另一个枚举类的应用，用来说明枚举类与普通类并没有太大的区别，差别只是产生枚举对象的方式不同，枚举类的实例只能是枚举值，而不是随意地通过new来创建枚举类对象。

1. 不过下面这个代码本身并不够好，通常应该把枚举类设计成不可变类，即它的成员变量值不应该允许改变，建议将枚举类的成员变量都使用private final修饰；

2. 如果对所有的成员变量都使用了final修饰，则将导致必须在构造器里为这些成员变量指定初始值（或者在定义成员变量时指定默认值，或者在初始化块里指定初始值，这两种方式不常见），因此应该为枚举类显式定义带参数的构造器。

    ```java
    enum Gender {
        MALE, FEMALE;
        private String name;
        
        public void setName(String name) {
            switch (this) {
                case MALE:
                    if (name.equals("男"))
                        this.name = name;
                    else {
                        System.out.println("参数错误");
                        return;
                    }
                    break;
                case FEMALE:
                    if (name.equals("女"))
                        this.name = name;
                    else {
                        System.out.println("参数错误");
                        return;
                    }
                    break;
            }
        }
        
        public String getName() {
            return this.name;
        }
    }
    
    class GenderTest {
        public static void main(String[] args) {
            Gender g = Gender.valueOf("FEMALE");
            g.setName("女");
            System.out.println(g + "代表:" + g.getName());
            // 此时设置name值时将会提示参数错误
            g.setName("男");
            System.out.println(g + "代表:" + g.getName());
        }
    }
    ```

## 2. Enum 类的方法

java.lang.Enum 类中提供了如下几个方法，所有枚举类都可以直接使用：

| 方法                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `int compareTo(E o)`                                         | 与相同枚举类型的枚举对象比较顺序。若该枚举对象位于指定枚举对象之后返回正整数，若该枚举对象位于指定枚举对象之前返回负整数，否则返回零。 |
| `String name()`                                              | 返回此枚举实例的名称。不过大多数程序员应该优先考虑使用 toString()方法，因为 toString()方法返回更加用户友好的名称。 |
| `int ordinal()`                                              | 返回枚举值在枚举类中的索引值，即枚举值在枚举声明中的位置     |
| `String toString()`                                          | 返回枚举常量的名称，与 name()相似，但 toString()方法更常用   |
| `public static<T extends Enum<T>> T valueOf(Class<T> enumType, String name)` | 一个静态方法，用于返回指定枚举类中指定名称的枚举值           |

## 3. 带参数的枚举类构造器

带参数的枚举类构造器，列出枚举值时必须对应地传入参数：

```java
enum Gender {
    // 此处的枚举值必须调用对应的构造器来创建
    // 以下第一行相当于:
    // public static final Gender MALE = new Gender("男");
    // public static final Gender FEMALE = new Gender("女");
    MALE("男"), FEMALE("女");
    private final String name;
    
    // 枚举类的构造器只能使用private修饰
    private Gender(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
}
```

## 4. 实现接口的枚举类

如果由枚举类来实现接口里的方法，则每个枚举值在调用该方法时都有相同的行为方式（因为方法体一样）；而如果需要每个枚举值在调用方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方式，从而让不同的枚举值调用该方法时具有不同的行为方式。

```java
interface GenderDesc {
    void info();
}

enum Gender implements GenderDesc {
    // 此处的枚举值必须调用对应的构造器来创建
    // 花括号部分实际上是一个类体部分
    MALE("男") {
        public void info() {
            System.out.println("这个枚举值代表男性");
        }
    },
    FEMALE("女") {
        public void info() {
            System.out.println("这个枚举值代表女性");
        }
    };
    private final String name;
    private Gender(String name) {
        this.name = name;
    }
    public String getName() {
        return this.name;
    }
}
```

## 5. 包含抽象方法的枚举类

枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（因为系统会自动添加），但因为枚举类需要显式创建枚举值，而不是作为父类，所以定义每个枚举值时必须为抽象方法提供实现，否则将出现编译错误。
