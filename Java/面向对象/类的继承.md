## 1. 语法

Java的继承只允许**单继承**，每个子类只有一个直接父类。继承通过关键字extends来实现。

```java
[修饰符] class SubClass extends SuperClass {
    // 类定义部分
}
```

## 2. 继承的含义

继承意味着子类扩展了父类，将可以获得父类的**全部**成员变量和方法，只有一个除外：Java的子类不能获得父类的构造器。

父类和子类的关系，是一种一般到特殊的关系，子类是一种特殊的父类，因此父类包含的范围总比子类包含的范围要大，可认为父类是大类，而子类是小类。

> “继承后子类获得了父类的全部成员变量和方法”意味着，父类中定义的**所有**实体在子类中其实依旧是占据内存的，所谓各种修饰符的限定，只是表明了子类对父类的**访问权限**，而非“是否继承”的权限。

![29](https://chua-n.gitee.io/blog-images/notebooks/Java/29.png)

![30](https://chua-n.gitee.io/blog-images/notebooks/Java/30.png)

> 总结：在Java中，当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。

## 3. Object基类

若定义一个Java类时并未显式指定这个类的直接父类，则这个类默认扩展java.lang.Object类。因此，java.lang.Object类是所有类的父亲，要么是其直接父类，要么是其间接父类，所有的Java对象都可以调用java.lang.Object类所定义的实例方法。

## 4. 重写/覆盖

当子类覆盖了父类的方法后，子类的对象将无法访问父类中被覆盖的方法，但在子类方法中依然可以借助super关键字/父类类名调用父类中被覆盖的实例/类方法。

但要注意的是，如果父类方法是private的，该方法对其子类是隐藏的，子类对其根本无法访问，故而根本不存在子类覆盖该方法一说。

## 5. super关键字

**super关键字**用于限定该对象调用它从父类继承得到的可被访问的**实例变量/实例方法**，这通常用于父类的变量/方法被覆盖时的情况。

1. 那也就是说，如果父类中的某个成员限定的访问权限都不允许被子类访问，即使super也不能调用该成员；

2. 正如this不能出现在static修饰的方法中一样，super也不能出现在static修饰的方法中。

3. 如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。

## 6. 子类变量的回溯顺序

如果在某个方法中访问名为a的成员变量，但没有显式地指定调用者，则系统查找a的顺序为：

1. 查找该方法中是否有名为a的局部变量；

2. 查找当前类中是否包含名为a的成员变量；

3. 查找a的直接父类中是否包含名为a的成员变量；

4. 依次上溯a的所有间接父类，直到java.lang.Ojbect类；

5. 若最终都不能找到名为a的成员变量，则编译错误。

## 7. 继承中的构造方法

子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码，类似于“在一个类内一个构造器调用另一个重载的构造器”这种情形，只是关键字换成了super。

```java
class Base {
    public double size;
    public String name;
    public Base(double size, String name) {
        this.size = size;
        this.name = name;
    }
}
public class Sub extends Base {
    public String color;
    public Sub(double size, String name, String color) {
        // 通过super 调用来调用父类构造器的初始化过程
        super(size, name);
        this.color = color;
    }
    public static void main(String[] args) {
        Sub s = new Sub(5.6, "测试对象", " 红色");
        // 输出Sub 对象的三个实例变量
        System.out.println(s.size + "--" + s.name + "--" + s.color);
    }
}
```

使用super调用父类构造器也必须出现在子类构造器执行体的第一行，所以this调用和super调用不会同时出现；

事实上，无论是否在构造器中使用super，当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行，依次上溯的话，这意味着创建任意Java对象总是最先执行java.lang.Object类的构造器。

概述而言，子类构造器总会如下调用父类构造器：

- 若子类构造器执行体的第一行使用了super显式调用父类构造器，系统将根据super调用里传入的实参列表调用父类中相应的构造器；
- 若子类构造器执行体的第一行使用了this显式调用本类中重载的构造器，系统将先调用this匹配的另一个构造器，而在执行另一个构造器时即会调用父类构造器；
- 若子类构造器执行体中既无super又无this，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。

### 8. 注意事项

设计父类时，尽量不要在父类构造器中调用将要被子类重写的方法。

```java
class Base {
    public Base() {
        test();
    }
    public void test() {
        System.out.println("将要被子类重写的方法");
    }
}
public class Sub extends Base {
    private String name;
    public void test() {
        System.out.println("子类重写父类的方法，" + "其name字符串长度" + name.length());
    }
    public static void main(String[] args) {
        // 下面代码会引发空指针异常
        Sub s = new Sub();
        
    /* 
    控制台输出：
    Exception in thread "main" java.lang.NullPointerException
        at com.chuan.Sub.test(Sub.java:17)
        at com.chuan.Base.<init>(Sub.java:5)
        at com.chuan.Sub.<init>(Sub.java:13)
        at com.chuan.Sub.main(Sub.java:22)
     */
    }
}
```

> 当系统试图创建Sub对象时，同样会先执行其父类构造器，而此时父类构造器调用了被其子类重写的方法，就导致父类调用的是被子类重写后的方法。由于此时子类的name实例变量是null，因此将引发空指针异常。

## 9. final修饰符

如果要把某些类设置成最终类，即不能被当成父类，可以使用final修饰这个类。

> `java.lang.String`类和`java.lang.System`类就是两个final类。

除了final，还可用一种技巧禁止子类调用父类的构造器，从而导致无法继承该类：**使用private修饰这个类的所有构造器**。此时对于父类而言，可另外提供一个静态方法用于创建该类的实例。

