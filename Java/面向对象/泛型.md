## 1. 定义泛型

所谓**泛型**，就是允许在定义类、接口、方法时使用**类型形参**，这个类型形参将在<u>声明变量、创建对象、调用方法</u>时动态地指定（即传入实际的类型参数，也可称为**类型实参**）。

泛型的程序设计与面向对象的程序设计是两个角度的设计，两者并不矛盾反而相辅相成。

可以为任何类、接口增加泛型声明，当创建带泛型声明的自定义类并为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。如定义 Apple 类时使用了泛型声明：

```java
class Apple<T> {
    private T info;

    public Apple() {
    }

    public Apple(T info) {
        this.info = info;
    }

    public void setInfo(T info) {
        this.info = info;
    }

    public T getInfo() {
        return this.info;
    }

    public static void main(String[] args) {
        Apple<String> a1 = new Apple<>("apple");
        System.out.println(a1.getInfo());
        Apple<Double> a2 = new Apple<>(3.14);
        System.out.println(a2.getInfo());
    }
}
```

> 以上代码定义了一个带泛型声明的`Apple<T>`类，使用`Apple<T>`时就可为T形参传入实际类型， 这样就可以生成如`Apple<String>`、`Apple<Double>`等形式的多个逻辑子类（物理上并不存在）。

## 2. 向上转型

在Java标准库中的`ArrayList<T>`实现了`List<T>`接口，它可以向上转型为`List<T>`：

```java
public class ArrayList<T> implements List<T> {
    ...
}

// 向上转型成功
List<String> list = new ArrayList<String>();
```

即类型`ArrayList<T>`可以向上转型为`List<T>`。

然而，要特别注意的是：不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`或`List<Number>`，这是为什么呢？

假设`ArrayList<Integer>`可以向上转型为`ArrayList<Number>`，那么观察以下代码：

```java
// 创建ArrayList<Integer>类型：
ArrayList<Integer> integerList = new ArrayList<Integer>();
// 添加一个Integer：
integerList.add(new Integer(123));

// “向上转型”为ArrayList<Number>：
ArrayList<Number> numberList = integerList;

// 添加一个Float，因为Float也是Number：
numberList.add(new Float(12.34));

// 从ArrayList<Integer>获取索引为1的元素（即添加的Float）：
Integer n = integerList.get(1); // ClassCastException!
```

我们把一个`ArrayList<Integer>`转型为`ArrayList<Number>`类型后，这个`ArrayList<Number>`就可以接受`Float`类型，因为`Float`是`Number`的子类。但是，`ArrayList<Number>`实际上和`ArrayList<Integer>`是同一个对象，也就是`ArrayList<Integer>`类型，它不可能接受`Float`类型， 所以在获取`Integer`的时候将产生`ClassCastException`。

实际上，编译器为了避免这种错误，根本就不允许把`ArrayList<Integer>`转型为`ArrayList<Number>`。

> 也即`ArrayList<Integer>`和`ArrayList<Number>`两者完全没有继承关系。

小结：

- 泛型就是编写模板代码来适应任意类型；
- 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；
- 注意泛型的继承关系：可以把`ArrayList<Integer>`向上转型为`List<Integer>`（`T`不能变！），但不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`（`T`不能变成父类）。

## 3. 泛型的实现原理

> 来自廖雪峰 [擦拭法 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1265104600263968) 。

泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java语言的泛型实现方式是擦除法（Type Erasure）。

所谓擦除法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。例如，我们编写了一个泛型类`Pair<T>`，这是编译器看到的代码：

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```

而虚拟机根本不知道泛型。这是虚拟机执行的代码：

```java
public class Pair {
    private Object first;
    private Object last;
    public Pair(Object first, Object last) {
        this.first = first;
        this.last = last;
    }
    public Object getFirst() {
        return first;
    }
    public Object getLast() {
        return last;
    }
}
```

因此，Java使用擦除法实现泛型，导致了：

- 编译器把类型`<T>`视为`Object`；
- 编译器根据`<T>`实现安全的强制转型。

使用泛型的时候，我们编写的代码也是编译器看到的代码：

```java
Pair<String> p = new Pair<>("Hello", "world");
String first = p.getFirst();
String last = p.getLast();
```

而虚拟机执行的代码并没有泛型：

```java
Pair p = new Pair("Hello", "world");
String first = (String) p.getFirst();
String last = (String) p.getLast();
```

所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型`T`视为`Object`处理，但是，在需要转型的时候，编译器会根据`T`的类型自动为我们实行安全地强制转型。

> 擦除也意味着泛型类的所有实例在运行时具有相同的运行时类(class)，而不管他们的实际类型参数，因而，<font color="red">并不存在所谓的“泛型类”</font>。

## 4. Java泛型的局限

了解了Java泛型的实现方式——擦除法，我们就知道了Java泛型的局限。

### 4.1 局限一

`<T>`不能是基本类型，例如`int`，因为实际类型是`Object`，`Object`类型无法持有基本类型：

```java
Pair<int> p = new Pair<>(1, 2); // compile error!
```

### 4.2 局限二

不存在带泛型的`Class`。观察以下代码：

```java
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}

public class Main {
    public static void main(String[] args) {
        Pair<String> p1 = new Pair<>("Hello", "world");
        Pair<Integer> p2 = new Pair<>(123, 456);
        Class c1 = p1.getClass();
        Class c2 = p2.getClass();
        System.out.println(c1==c2); // true
        System.out.println(c1==Pair.class); // true
    }
}
```

因为`T`是`Object`，我们对`Pair<String>`和`Pair<Integer>`类型获取`Class`时，获取到的是同一个`Class`，也就是`Pair`类的`Class`。

换句话说，所有泛型实例，无论`T`的类型是什么，`getClass()`返回同一个`Class`实例，因为编译后它们全部都是`Pair<Object>`。

### 4.3 局限三

无法判断带泛型的类型：

```java
Pair<Integer> p = new Pair<>(123, 456);
// Compile error:
if (p instanceof Pair<String>) {
}
```

原因和前面一样，并不存在`Pair<String>.class`，而是只有唯一的`Pair.class`，也因此`instanceof`无法用于“泛型类”。

### 4.4 局限四

不能实例化`T`类型：

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair() {
        // Compile error:
        first = new T();
        last = new T();
    }
}
```

上述代码无法通过编译，因为构造方法的两行语句：

```java
first = new T();
last = new T();
```

擦拭后实际上变成了：

```java
first = new Object();
last = new Object();
```

这样一来，创建`new Pair<String>()`和创建`new Pair<Integer>()`就全部成了`Object`，显然编译器要阻止这种类型不对的代码。

要实例化`T`类型，我们必须借助额外的`Class<T>`参数：

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(Class<T> clazz) {
        first = clazz.newInstance();
        last = clazz.newInstance();
    }
}
```

上述代码借助`Class<T>`参数并通过反射来实例化`T`类型，使用的时候，也必须传入`Class<T>`。例如：

```java
Pair<String> pair = new Pair<>(String.class);
```

因为传入了`Class<String>`的实例，所以我们借助`String.class`就可以实例化`String`类型。

### 4.5 附：注意以下易错场景

#### 4.5.1 不恰当的覆盖方法

有些时候，一个看似正确定义的方法会无法通过编译。例如：

```java
public class Pair<T> {
    public boolean equals(T t) {
        return this == t;
    }
}
```

这是因为，定义的`equals(T t)`方法实际上会被擦拭成`equals(Object t)`，而这个方法是继承自`Object`的，编译器会阻止一个实际上会变成覆写的泛型方法定义。

换个方法名，避开与`Object.equals(Object)`的冲突就可以成功编译：

```java
public class Pair<T> {
    public boolean same(T t) {
        return this == t;
    }
}
```

#### 4.5.2 泛型继承

一个类可以继承自一个泛型类。例如：父类的类型是`Pair<Integer>`，子类的类型是`IntPair`，可以这么继承：

```java
public class IntPair extends Pair<Integer> {
}
```

使用的时候，因为子类`IntPair`并没有泛型类型，所以，正常使用即可：

```java
IntPair ip = new IntPair(1, 2);
```

前面讲了，我们无法获取`Pair<T>`的`T`类型，即给定一个变量`Pair<Integer> p`，无法从`p`中获取到`Integer`类型。

但是，在父类是泛型类型的情况下，编译器就必须把类型`T`（对`IntPair`来说，也就是`Integer`类型）保存到子类的class文件中，不然编译器就不知道`IntPair`只能存取`Integer`这种类型。

在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：`IntPair`可以获取到父类的泛型类型`Integer`。获取父类的泛型类型代码比较复杂：

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class Main {
    public static void main(String[] args) {
        Class<IntPair> clazz = IntPair.class;
        Type t = clazz.getGenericSuperclass();
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型
            Type firstType = types[0]; // 取第一个泛型类型
            Class<?> typeClass = (Class<?>) firstType;
            System.out.println(typeClass); // Integer
        }
    }
}

class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}

class IntPair extends Pair<Integer> {
    public IntPair(Integer first, Integer last) {
        super(first, last);
    }
}
```

因为Java引入了泛型，所以，只用`Class`来标识类型已经不够了。实际上，Java的类型系统结构如下：

```ascii
                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
```

#### 4.5.3 方法重载

由于擦除的存在，定义重载方法时要小心出现以下的错误：

```java
import java.util.List;

public class Apple {
    // 如下的方法重载是非法的，因为方法形参在擦除后是完全相同的
    public String genericsOver(List<String> list) {
        return "";
    }

    public int genericsOver(List<Integer> list) {
        return 0;
    }
    
    /*
    Java基础知识回顾：JAVA里面方法重载是不能通过返回值类型来区分的，比如代码一中一个类中定义两个如下的方法是不容许的：
    
    public String basicOver(int i) {
        return "";
    }

    public int basicOver(int i) {
        return 0;
    }
     */
}
```

#### 4.5.4 泛型与static

由上所述，并不存在所谓的“泛型类”，因而不管为泛型形参传入哪一种类型，对于Java来说，该泛型依然被当成同一个类处理，在内存中也只占用一块内存空间，泛型形参只是在运行时绑定于具体的实例，因此，在静态方法、静态初始化块、静态变量的声明和初始化中不允许使用类型形参（否则，静态XX将不再是统一不变的）。

类成员是所有实例共享的，但是类型参数是属于具体实例的。所以，

```java
public class Apple<T> {
    T age;
    static T info; // 错误
    public void foo(T msg) {}
    public static void bar(T msg) {} // 错误
}
```

## 5. 泛型派生

当实现/继承带泛型声明的接口/父类时，相应的接口/父类不能再包含**泛型形参**。

```java
// 错误做法：定义类A继承Apple类，Apple类不能跟泛型形参
class A extends Apple<T> {}

// 正确做法1：使用Apple类时为T形参传入实参类型，如String
class A extends Apple<String> {}

// 正确做法2：使用Apple类时直接省略T形参，称之为使用原始类型
// 使用原始类型时，编译器会发出泛型检查的警告
class A extends Apple {}
```

## 6. 类型通配符

使用泛型的类型通配符，其中 ? 表示元素类型未知：

| 代码                                     | 解释                  |
| ---------------------------------------- | --------------------- |
| `Foo<?> fo = new Foo<>()`                | 通配符的上限为 Object |
| `Foo<? extends Number> fn = new Foo<>()` | 通配符的上限为 Number |
| `Foo<? super Bar> fb = new Foo<>()`      | 通配符的下限为 Bar    |

```java
// 以下表示泛型参数T必须继承自Number或是Number本身
class Apple<T extends Number> {
    T col;
    public static void main(String[] args) {
        Apple<Integer> ai = new Apple<>();
        Apple<Double> ad = new Apple<>();
        // 下面一行将引起编译错误
        Apple<String> as = new Apple<>();
    }
}
```

带通配符的泛型List仅能表示它是各种相应泛型List的父类，并不能把元素加入到其中，如以下代码将发生编译错误：

```java
List<?> c = new ArrayList<String>();
// null是所有引用类型的实例，故可添加
c.add(null); 
// 编译错误，程序无法确定集合c的元素类型
c.add(new Object()); 

List<? extends Shape> shapes;
// 编译错误，无法确定通配符的具体类型
shapes.add(0, new Rectangle()); 
```

还可以为泛型形参设定多个上限：

- 但至多有一个父类上限；
- 可以有多个接口上限；
- 如果需要为泛型形参指定类上限，类上限必须位于第一位。

```java
// 表明该泛型形参T必须是其父类的子类，并且实现多个上限接口
class Apple<T extends Number & java.io.Serializable> {}
```

### 协变与逆变？？？

> 一定要看廖雪峰关于extends和super的讲解 [extends通配符 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1265105899616928) 。

对于逆变的泛型集合来说，编译器只知道集合元素是下限的父类型，但具体是哪种父类型则不确定。因此，这种逆变的泛型集合能向其中添加元素（因为实际赋值的集合元素总是逆变声明的父类），从集合中取元素时只能被当成Object类型处理（编译器无法确定取出的到底是哪个父类的对象）。

- 如果你想从一个数据类型里获取数据，使用`? extends`通配符
- 如果你想把对象写入一个数据结构里，使用`? super`通配符
- 如果你既想存，又想取，那就别用通配符

> 协变只读不取；
>
> 逆变只取不读。

## 7. 泛型方法

所谓**泛型方法**，就是在声明方法时定义一个或多个泛型形参，语法如下：

```java
修饰符 <T, S> 返回值类型 方法名(形参列表)
{
    // 方法体……
}
```

> - 泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号包括起来，多个类型形参之间以逗号（,）隔开。
> - 所有的类型形参声明在方法修饰符和方法返回值类型之间。

```java
package generics;

import java.util.ArrayList;
import java.util.Collection;

public class ArrayToList {

    //适用于各种类型的数组到集合的copy
    public static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
        for (T t : a)
            c.add(t);
    }

    public static void testInteger() {
        Collection<Integer> c = new ArrayList<>();
        Integer[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        fromArrayToCollection(a, c);
        System.out.println(c);
    }

    public static void testString() {
        Collection<String> c = new ArrayList<>();
        String[] a = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
        fromArrayToCollection(a, c);
        System.out.println(c);
    }

    public static void main(String[] args) {
        testInteger();
        testString();
        
        // 输出：
        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
		// [1, 2, 3, 4, 5, 6, 7, 8, 9]
    }
}
```

与接口、类声明中定义的泛型不同的是：

1. 方法声明中定义的泛型只能在该方法里使用，而接口、类声明中定义的泛型则可以在整个接口、类中使用；

2. 方法中的泛型参数无须显式传入实际类型参数，因为编译器根据实参推断出泛型所代表的类型，它常推断出最直接的类型。

    > 为了让编译器能准确地推断出泛型方法中泛型的类型，不要制造迷惑！
    >
    > ```java
    > class WrongTest {
    >     static <T> void test(Collection<T> from, Collection<T> to) {
    >         for (T ele : from)
    >             to.add(ele);
    >     }
    >     
    >     public static void main(String[] args) {
    >         List<Object> ao = new ArrayList<>();
    >         List<String> as = new ArrayList<>();
    >         // 编译错误，无法准确推断类型
    >         test(as, ao);
    >     }
    > }
    > 
    > class RightTest {
    >     // 改进
    >     static <T> void test(Collection<? extends T> from, Collection<T> to) {
    >         for (T ele : from)
    >             to.add(ele);
    >     }
    >     
    >     public static void main(String[] args) {
    >         List<Object> ao = new ArrayList<>();
    >         List<String> as = new ArrayList<>();
    >         // 下面代码完全正常
    >         test(as, ao);
    >     }
    > }
    > ```

泛型方法和类型通配符的区别：

1. 大多数时候都可以使用泛型方法来代替类型通配符；

2. 泛型方法允许泛型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系，因此通常在这些条件下才使用泛型方法；

3. 如果有需要，也可以同时使用泛型方法和通配符，如Java的`Collections.copy()`方法。

## 8. 泛型构造器

正如泛型方法允许在方法签名中声明泛型形参一样，Java也允许在构造器签名中声明泛型形参，这样就产生了所谓的**泛型构造器**。

一旦定义了泛型构造器，接下来在调用构造器时，就

- 不仅可以让Java根据实际参数的类型来“推断”泛型形参的类型
- 也可以显式地为构造器中的泛型形参指定实际的类型

```java
class Foo {
    public <T> Foo(T t) {
        System.out.println(t);
    }
}

class GenericConstructor {
    public static void main(String[] args) {
        // 由程序推断泛型形参的类型
        new Foo("Crazy Java.");
        new Foo(200);
        
        // 显示指定泛型构造器中的T类型
        new <String>Foo("Crazy Java.");
        new <String>Foo(12.3); // 代码出错
    }
}
```

Java7新增的“菱形”语法允许在调用构造器时在构造器后使用一对尖括号来代表泛型信息，但如果程序显式指定了泛型构造器中声明的泛型形参的实际类型，则不可以使用“菱形”语法。

```java
class MyClass<E> {
    public <T> MyClass(T t) {
        System.out.println(t);
    }
}
class GenericDiamondTest {
    public static void main(String[] args) {
        // MyClass类声明中的E形参是String类型
        // 泛型构造器中声明的T形参是Integer类型
        MyClass<String> mc1 = new MyClass<>(5);
        
        // 显式指定泛型构造器中声明的T形参是Integer类型
        MyClass<String> mc2 = new <Integer>MyClass<String>(5);
        
        // 在显式指定了泛型构造器中声明的T形参是Integer类型之后，不能使用菱形语法
        // 以下代码错误
        MyClass<String> mc3 = new <Integer>MyClass<>(5);
    }
}
```

## 9. 擦除和转换

为了与老的Java代码保持一致，在使用带泛型声明的类时，如果没有为这个泛型类指定实际的类型，此时默认匹配的是声明该泛型形参时指定的第一个上限类型，称这种情况下的类型为 **原始类型(raw type)** 。

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉，这种现象被称为**擦除**。比如一个`List<String>`类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（对List而言即Object）。

```java
class Apple<T extends Number> {
    T size;
    public Apple() {
    }
    public Apple(T size) {
        this.size = size;
    }
    public void setSize(T size) {
        this.size = size;
    }
    public T getSize() {
        return this.size;
    }
}

class ErasureTest {
    public static void main(String[] args) {
        Apple<Integer> a = new Apple<>(6);
        Integer as = a.getSize();
        // 把a对象赋给Apple变量，丢失尖括号里的类型信息
        Apple b = a;
        // b只知道size的类型是Number
        Number size1 = b.getSize();
        // 编译错误
        Integer size2 = b.getSize();
    }
}

class ErasureTest2 {
    public static void main(String[] args) {
        List<Integer> li = new ArrayList<>();
        li.add(6);
        li.add(9);
        // 擦除
        List list = li;
        // 引起“未经检查的转换”警告，编译、运行时完全正常
        List<String> ls = list;
        // 但只要访问ls里的元素，如下即将引起运行时异常
        System.out.println(ls.get(0));
    }
}
```

## 10. 泛型与数组

Java泛型有一个很重要的设计原则——如果一段代码在编译时没有提出“[unchecked] 未经检查的转换”警告，则程序在运行时不会引发ClassCastException异常。

故而，数组元素的类型不能包含泛型变量或泛型形参，除非是无上限的类型通配符，但可以声明元素类型包含泛型变量或泛型形参的数组。即，只能声明`List<String>[]`形式的数组，但不能创建`ArrayList<String>[10]`这样的数组对象。

```java
class ErasureTest {
    public static void main(String[] args) {
        // 编译错误，不被允许
        List<String>[] lsa = new ArrayList<String>[10];
        // 假设已将以上错误修正
        // 将lsa向上转型为Object[]类型的变量
        Object[] oa = lsa;
        List<Integer> li = new ArrayList<>();
        li.add(3);
        // 下面一行没有警告
        oa[1] = li;
        // 下面一行也没有警告，但将引发ClassCastException异常
        String s = lsa[1].get(0);
    }
}
```

