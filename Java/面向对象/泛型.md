## 1. 定义泛型

所谓**泛型**，就是允许在定义类、接口、方法时使用**类型形参**，这个类型形参将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为**类型实参**）。

泛型的程序设计与面向对象的程序设计是两个角度的设计，两者并不矛盾反而相辅相成。

可以为任何类、接口增加泛型声明，当创建带泛型声明的自定义类并为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。如定义 Apple 类时使用了泛型声明：

```java
class Apple<T> {
    private T info;

    public Apple() {
    }

    public Apple(T info) {
        this.info = info;
    }

    public void setInfo(T info) {
        this.info = info;
    }

    public T getInfo() {
        return this.info;
    }

    public static void main(String[] args) {
        Apple<String> a1 = new Apple<>("apple");
        System.out.println(a1.getInfo());
        Apple<Double> a2 = new Apple<>(3.14);
        System.out.println(a2.getInfo());
    }
}
```

## 2. 泛型的类型

对于一个泛型，不管其实际类型参数是什么，它们在运行时总有同样的类，在内存中也只占用一块内存空间，因此在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用泛型形参。

```java
List<String> l1 = new ArrayList<>();
List<Integer> l2 = new ArrayList<>();
System.out.println(l1.getClass()); // class java.util.ArrayList
System.out.println(l2.getClass()); // class java.util.ArrayList
System.out.println(l1.getClass() == l2.getClass()); // true
```

```java
public class R<T> {
    T age;
    static T info; // 错误
    public void foo(T msg) {}
    public static void bar(T msg) {} // 错误
}
```

由上，如果 Foo 是 Bar 的一个子类型（子类/子接口），对于一个具有泛型声明的类或接口 G，G\<Foo\>并不是 G\<Bar\>的子类型，这点要注意。

## 3. 泛型派生

当实现/继承带泛型声明的接口/父类时，相应的接口/父类不能再包含**泛型形参**。

```java
// 错误做法：定义类A继承Apple类，Apple类不能跟泛型形参
class A extends Apple<T> {}

// 正确做法1：使用Apple类时为T形参传入实参类型，如String
class A extends Apple<String> {}

// 正确做法2：使用Apple类时直接省略T形参，称之为使用原始类型
// 使用原始类型时，编译器会发出泛型检查的警告
class A extends Apple {}
```

## 4. 类型通配符

使用泛型的类型通配符，其中 ? 表示元素类型未知：

| 代码                                     | 解释                  |
| ---------------------------------------- | --------------------- |
| `Foo<?> fo = new Foo<>()`                | 通配符的上限为 Object |
| `Foo<? extends Number> fn = new Foo<>()` | 通配符的上限为 Number |
| `Foo<? super Bar> fb = new Foo<>()`      | 通配符的下限为 Bar    |

```java
// 以下表示泛型参数T必须继承自Number或是Number本身
class Apple<T extends Number> {
    T col;
    public static void main(String[] args) {
        Apple<Integer> ai = new Apple<>();
        Apple<Double> ad = new Apple<>();
        // 下面一行将引起编译错误
        Apple<String> as = new Apple<>();
    }
}
```

带通配符的泛型List仅能表示它是各种相应泛型List的父类，并不能把元素加入到其中，如以下代码将发生编译错误：

```java
List<?> c = new ArrayList<String>();
// null是所有引用类型的实例，故可添加
c.add(null); 
// 编译错误，程序无法确定集合c的元素类型
c.add(new Object()); 

List<? extends Shape> shapes;
// 编译错误，无法确定通配符的具体类型
shapes.add(0, new Rectangle()); 
```

还可以为泛型形参设定多个上限：

- 但至多有一个父类上限；
- 可以有多个接口上限；
- 如果需要为泛型形参指定类上限，类上限必须位于第一位。

```java
// 表明该泛型形参T必须是其父类的子类，并且实现多个上限接口
class Apple<T extends Number & java.io.Serializable> {}
```

### 协变与逆变？？？

对于逆变的泛型集合来说，编译器只知道集合元素是下限的父类型，但具体是哪种父类型则不确定。因此，这种逆变的泛型集合能向其中添加元素（因为实际赋值的集合元素总是逆变声明的父类），从集合中取元素时只能被当成Object类型处理（编译器无法确定取出的到底是哪个父类的对象）。

## 5. 泛型方法

所谓**泛型方法**，就是在声明方法时定义一个或多个泛型形参，语法如下：

```java
修饰符 <T, S> 返回值类型 方法名(形参列表)
{
    // 方法体……
}
```

与接口、类声明中定义的泛型不同的是：

1. 方法声明中定义的泛型只能在该方法里使用，而接口、类声明中定义的泛型则可以在整个接口、类中使用；

2. 方法中的泛型参数无须显式传入实际类型参数，因为编译器根据实参推断出泛型所代表的类型，它常推断出最直接的类型。

    > 为了让编译器能准确地推断出泛型方法中泛型的类型，不要制造迷惑！
    >
    > ```java
    > class WrongTest {
    >     static <T> void test(Collection<T> from, Collection<T> to) {
    >         for (T ele : from)
    >             to.add(ele);
    >     }
    >     
    >     public static void main(String[] args) {
    >         List<Object> ao = new ArrayList<>();
    >         List<String> as = new ArrayList<>();
    >         // 编译错误，无法准确推断类型
    >         test(as, ao);
    >     }
    > }
    > 
    > class RightTest {
    >     // 改进
    >     static <T> void test(Collection<? extends T> from, Collection<T> to) {
    >         for (T ele : from)
    >             to.add(ele);
    >     }
    >     
    >     public static void main(String[] args) {
    >         List<Object> ao = new ArrayList<>();
    >         List<String> as = new ArrayList<>();
    >         // 下面代码完全正常
    >         test(as, ao);
    >     }
    > }
    > ```

泛型方法和类型通配符的区别：

1. 大多数时候都可以使用泛型方法来代替类型通配符；

2. 泛型方法允许泛型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系，因此通常在这些条件下才使用泛型方法；

3. 如果有需要，也可以同时使用泛型方法和通配符，如Java的`Collections.copy()`方法。

## 6. 泛型构造器

正如泛型方法允许在方法签名中声明泛型形参一样，Java也允许在构造器签名中声明泛型形参，这样就产生了所谓的**泛型构造器**。

一旦定义了泛型构造器，接下来在调用构造器时，就

- 不仅可以让Java根据实际参数的类型来“推断”泛型形参的类型
- 也可以显式地为构造器中的泛型形参指定实际的类型

```java
class Foo {
    public <T> Foo(T t) {
        System.out.println(t);
    }
}

class GenericConstructor {
    public static void main(String[] args) {
        // 由程序推断泛型形参的类型
        new Foo("Crazy Java.");
        new Foo(200);
        
        // 显示指定泛型构造器中的T类型
        new <String>Foo("Crazy Java.");
        new <String>Foo(12.3); // 代码出错
    }
}
```

Java7新增的“菱形”语法允许在调用构造器时在构造器后使用一对尖括号来代表泛型信息，但如果程序显式指定了泛型构造器中声明的泛型形参的实际类型，则不可以使用“菱形”语法。

```java
class MyClass<E> {
    public <T> MyClass(T t) {
        System.out.println(t);
    }
}
class GenericDiamondTest {
    public static void main(String[] args) {
        // MyClass类声明中的E形参是String类型
        // 泛型构造器中声明的T形参是Integer类型
        MyClass<String> mc1 = new MyClass<>(5);
        
        // 显式指定泛型构造器中声明的T形参是Integer类型
        MyClass<String> mc2 = new <Integer>MyClass<String>(5);
        
        // 在显式指定了泛型构造器中声明的T形参是Integer类型之后，不能使用菱形语法
        // 以下代码错误
        MyClass<String> mc3 = new <Integer>MyClass<>(5);
    }
}
```

## 7. 擦除和转换

为了与老的Java代码保持一致，在使用带泛型声明的类时，如果没有为这个泛型类指定实际的类型，此时默认匹配的是声明该泛型形参时指定的第一个上限类型，称这种情况下的类型为 **原始类型(raw type)** 。

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉，这种现象被称为**擦除**。比如一个`List<String>`类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（对List而言即Object）。

```java
class Apple<T extends Number> {
    T size;
    public Apple() {
    }
    public Apple(T size) {
        this.size = size;
    }
    public void setSize(T size) {
        this.size = size;
    }
    public T getSize() {
        return this.size;
    }
}

class ErasureTest {
    public static void main(String[] args) {
        Apple<Integer> a = new Apple<>(6);
        Integer as = a.getSize();
        // 把a对象赋给Apple变量，丢失尖括号里的类型信息
        Apple b = a;
        // b只知道size的类型是Number
        Number size1 = b.getSize();
        // 编译错误
        Integer size2 = b.getSize();
    }
}

class ErasureTest2 {
    public static void main(String[] args) {
        List<Integer> li = new ArrayList<>();
        li.add(6);
        li.add(9);
        // 擦除
        List list = li;
        // 引起“未经检查的转换”警告，编译、运行时完全正常
        List<String> ls = list;
        // 但只要访问ls里的元素，如下即将引起运行时异常
        System.out.println(ls.get(0));
    }
}
```

## 8. 泛型与数组

Java泛型有一个很重要的设计原则——如果一段代码在编译时没有提出“[unchecked] 未经检查的转换”警告，则程序在运行时不会引发ClassCastException异常。

故而，数组元素的类型不能包含泛型变量或泛型形参，除非是无上限的类型通配符，但可以声明元素类型包含泛型变量或泛型形参的数组。即，只能声明`List<String>[]`形式的数组，但不能创建`ArrayList<String>[10]`这样的数组对象。

```java
class ErasureTest {
    public static void main(String[] args) {
        // 编译错误，不被允许
        List<String>[] lsa = new ArrayList<String>[10];
        // 假设已将以上错误修正
        // 将lsa向上转型为Object[]类型的变量
        Object[] oa = lsa;
        List<Integer> li = new ArrayList<>();
        li.add(3);
        // 下面一行没有警告
        oa[1] = li;
        // 下面一行也没有警告，但将引发ClassCastException异常
        String s = lsa[1].get(0);
    }
}
```

