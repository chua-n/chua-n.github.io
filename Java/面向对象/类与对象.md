## 1. 类的构成

用类来定义的变量称为**引用变量**，也就是说，所有类都是**引用类型**。

类(class)和对象(object，也被称为实例，instance).

### 1.1 类的定义语法

Java定义类的简单语法如下：

```java
[修饰符] class 类名 {
    // 0~N个构造器定义...
    // 0~N个成员变量...
    // 0~N个方法...
}
```

> - 类的修饰符可以是public,final,abstract,或者省略这三个修饰符。
> - 类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用，但static修饰的成员不能访问没有static修饰的成员。
> - 构造器用于构造该类的实例，Java通过new关键字来调用构造器，从而返回该类的实例；成员变量用于定义该类或该类的实例所包含的状态数据；方法则用于定义该类或该类的实例的行为特征或者功能实现。
> - 如果程序员没有为一个类编写构造器，系统会为该类提供一个默认的构造器；而如果程序员为一个类提供了一个构造器，系统将不再为该类提供构造器。

### 1.2 定义成员变量

语法格式：`[修饰符] 类型 成员变量名 [= 默认值];`

> 修饰符：
>
> - 可以省略，也可以是`public`,`protected`,`private`,`static`,`final`
> - 其中`public`,`protected`,`private`三个最多只能选其一，可以与`static`,`final`组合起来修饰成员变量。

建议成员变量名使用英文名词命名。

### 1.3 定义方法

语法格式：

```java
[修饰符] 方法返回值类型 方法名(形参列表){
    // 由零条到多条可执行性语句组成的方法体
}
```

> 修饰符：
>
> - 可省略，也可以是`public`,`protected`,`private`,`static`,`abstract`
> - 其中`public`,`protected`,`private`三个最多只能选其一；
> - `final`和`abstract`最多只能选其一，但它们可以与`static`组合起来修饰方法。

建议方法名使用英文动词开头。

### 1.4 产生对象

语法：

```java
// 定义一个Person类型的变量
Person p;
// 通过new调用Person类的构造方法，返回一个Person实例，并将其赋值给p变量
p = new Person();
```

当一个对象被创建成功后，这个对象将被保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象，这跟数组类似。

> 当Java创建一个对象时，系统先为该对象的所有实例变量分配内存（前提是该类已经被加载过了），然后程序开始对这些实例变量执行初始化。其初始化顺序是：
>
> 1. 顺序执行初始化块或声明实例变量时指定的初始值
> 2. 执行构造器里指定的初始值。

## 2. static关键字

**static**是一个特殊的关键字，它可用于修饰方法、成员变量等成员。

static的真正作用就是用于区分成员变量、方法、内部类、初始化块这四种成员到底属于类本身还是实于实例。

### 2.1 类变量与类方法

static修饰的成员表明它属于这个类本身，而不属于该类的单个实例，因此通常把static修饰的成员变量、方法也称为**类变量、类方法**；

### 2.2 实例变量与实例方法

不使用static修饰的普通方法、成员变量则属于该类的单个实例，而不属于该类，因此也相应称之为**实例变量、实例方法**。

### 2.3 静态与非静态

由于static的英文直译是静态的意思，也常常把static修饰的成员变量和方法称为**静态变量**和**静态方法**，把不使用static修饰的成员变量和方法称为**非静态变量**和**非静态方法**。

### 2.4 设计本质

静态成员不能直接访问非静态成员。

没有使用static修饰的普通方法和成员变量，只可通过实例来调用；但static修饰的方法和成员变量，虽然理论上它只属于类而不属于实例，但它既可通过类来调用，也可通过实例来调用。

> 《疯狂Java讲义》认为这是Java的一个设计bug，并建议不要在Java代码中使用对象去调用static修饰的成员变量和方法。

## 3. 对象的this引用

this关键字最大的作用就是让类中一个方法，该问该类里的另一个方法或实例变量；

this可以代表任何对象，当其出现在某个方法中时，它所代表的对象是不确定的，但它的类型是确定的：

- this代表当前类的实例；
- 只有当这个方法被调用时，this所代表的对象才被确定下来；
- 谁在调用这个方法，this就代表谁。

this使用示例：

- 你最初想象的写法

    ```java
    public class Dog {
        public void jump(){
            System.out.println("正在执行jump方法");
        }
        public void run(){
            Dog d = new Dog();
            d.jump();
            System.out.println("正在执行run方法");
        }
    }
    ```

- 有了this以后的写法，这样更节省开销

    ```java
    public class Dog {
        public void jump(){
            System.out.println("正在执行jump方法");
        }
        public void run(){
            this.jump();
            System.out.println("正在执行run方法");
        }
    }
    ```

- 由于this的需求普遍性，Java允许对象的一个成员定义中直接调用另一个成员，即省略this前缀，但需清楚这只是一种简便的写法，真正的原理上还是在调用着this

    ```java
    public class Dog {
        public void jump(){
            System.out.println("正在执行jump方法");
        }
        public void run(){
            jump();
            System.out.println("正在执行run方法");
        }
    }
    ```

static修饰的方法中无法使用this关键字，因为static方法不属于对象，this指针无法拥有有效的指向，故而，static方法不能直接调用非static的成员和方法（如果确实需要在静态方法中调用另一个普通方法，那么只能采用上表中的第一种形式了）。

当方法内部的某个局部变量和成员变量同名，局部变量会覆盖掉该成员变量，为了避免歧义，此时应该显式地使用this前缀。

程序可以像访问普通引用变量一样来访问this引用，甚至可以把this当成普通方法的返回值：

```java
public class ReturnThis {
    public int age;
    public ReturnThis grow() {
        age++;
        // return this 返回调用该方法的对象
        return this;
    }
    public static void main(String[] args) {
        ReturnThis rt = new ReturnThis();
        // 可以连续调用同一个方法
        rt.grow().grow().grow();
        System.out.println("rt的age成员变量值是：" + rt.age);
    }
}
```

## 3. 类中的方法

方法在逻辑上要么属于类，要么属于对象。

Java里方法的参数传递方式只有一种：**值传递**。即将实际参数值的副本传入方法内，而参数本身不会受到任何影响。

实际上，由于Java引用类型的定义方式，Java虽然只能值传递，但其实际表现类似于C++的引用传递（你应该已经理解自己说的这句话了，chuan）。

### 3.1 形参个数可变的方法

定义语法：在方法最后一个形参的类型后增加三点(…)，则表明该形参可以接受多个参数值，多个参数值被当成数组传入。

个数可变的形参只能处于形参列表的最后，也就是说，一个方法中最多只能有一个个数可变的形参。

```java
// 以可变个数形参来定义方法
public static void test(int a, String... books){};
// 调用上述方法
test(5, "疯狂Java讲义"，"轻量级Java EE企业应用实战");

// 对比：采用数组形参来定义方法
public static void test(int a, String[] books){};
// 调用上述方法
test(5, new String[]{"疯狂Java讲义"，"轻量级Java EE企业应用实战"});
```

> 显然调用可变个数形参的方式更简洁。

调用形参个数可变的方法时，也可为个数可变的形参传入一个数组（实际上，形参个数可变的参数本质就是一个数组参数）。

当同一个类中定义了`test(String… books)`方法以及一个重载的`test(String book)`方法时，`test(String… books)`方法的books不可能通过直接传入一个字符串参数来调用，因为这会被`test(String book)`“截胡”。此时若非要传入一个字符串参数的同时调用`test(String… books)`，可采用传入字符串数组的形式，即`obj.test(new String[]{"aa"});`

### 3.2 方法重载

**方法重载(overload)**：同一个类中方法名相同，而参数列表不同。至于方法的其他部分不作要求。

### 3.3 方法重写/方法覆盖

**方法重写(override)**：也叫方法覆盖，子类和父类的方法名相同，且参数列表<font color="red">（和返回类型）相同</font>。且要么都是类方法，要么都是实例方法。

### 3.4 Java不支持设置形参默认值

值得一提的是，Java中不支持对方法的形参设置默认值，想达到这样的效果通常得由方法重载来实现。

## 4. 构造方法

构造方法/构造器是一个特殊的方法，其定义语法不需要返回类型：

语法格式：

```java
[修饰符] 构造器名(形参列表){
    // 由零条到多条可执行性语句组成的构造器执行体
}
```

| 组成部分 | 说明                                             |
| -------- | ------------------------------------------------ |
| 修饰符   | 可省略，也可以是public,protected,private其中之一 |
| 构造器名 | 必须和类名相同                                   |
| 形参列表 | 和定义方法形参列表的格式完全相同                 |

值得注意的是：

- 构造器不能定义返回值类型，且不能使用void。

    > 如果为构造器定义了返回值类型或使用了void，编译时不会出错，但其实Java已经认定它不是一个构造器了，而是一个跟类名同名的普通方法。

- 不要在构造器里显式使用return来返回当前类的对象，因为构造器的返回值是隐式的

- 由上，static关键字不能修饰构造器，这也符合static的含义

因为构造器主要用于被其他类调用，用以返回该类的实例，因而通常把构造器设置成public访问权限。

### 构造器的执行过程

当程序调用构造器时，系统会先为对象分配内存空间，并为这个对象执行默认构造化，此时这个对象在构造器执行前就已经产生了，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用（猜测这又是因为对象分配在堆上的原因？）。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会被赋给另一个引用类型的变量。

### this调用构造器

如果系统中包含了多个构造器，其中一个构造器B的执行体里完全包含另一个构造器A的执行体，则可在方法B中调用方法A，尽管有时这可以通过使用new关键字建立一个新对象甚至通过直接在源文件中复制A构造器的执行代码来实现，但这显然不够优雅，为了不重建一个Java对象的同时而引用A的初始化代码，Java中可以this关键字来调用相应的构造器。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/24.png" alt="24" style="zoom:80%;" />

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/25.png" alt="25" style="zoom:60%;" />

使用this调用构造器只能在构造器中使用，而且必须作为构造器执行体的第一条语句，前半部分意味着this调用构造器的必要条件是有重载的构造器。

### 对象创建过程

当Java创建一个对象时，系统先为该对象的所有实例变量分配内存（前提是该类已经被加载过了），然后程序开始对这些实例变量执行初始化。其初始化顺序是：

1. 顺序执行初始化块或声明实例变量时指定的初始值

2. 执行构造器里指定的初始值。

## 5. 类的成员变量（及局部变量）

在Java中，变量根据定义位置不同可分为两大类：**成员变量**、**局部变量**。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/26.png" alt="26" style="zoom:67%;" />

### 5.1 类的成员变量

**类变量**从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存区域相同；而**实例变量**则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。也因如此，把类变量和实例变量统称为**成员变量**。

同一个类的所有实例访问类变量时，实际上访问的是该类本身的同一个变量，也即访问了同一片内存区。

**成员变量无法显式地初始化**，只要为一个类定义了类变量/实例变量，系统就会在这个类的准备阶段/创建该类的实例时进行默认初始化（可能是因为成员变量是存储在堆上？？？），其规则与数组动态初始化时的数组元素的赋值规则完全相同。

在同一个类里，成员变量的作用范围是整个类内有效，一个类里不能定义两个同名的成员变量，即使一个是类变量一个是实例变量也不行。

### 5.2 局部变量

局部变量分为形参、方法局部变量、代码块局部变量，直接理解即可。

除形参外，**局部变量都必须显式初始化**（可能是因为成员变量是存储在栈上？？？），也就是说，必须先给局部变量和代码块局部变量指定初始值，否则不可以访问它们。

若方法局部变量与成员变量同名，局部变量会覆盖成员变量（若仍需引用相应成员变量可使用this）。

如果先定义代码块局部变量，后定义方法局部变量，前面定义的代码块局部变量与后面定义的方法局部变量可以同名（因为代码块局部变量在脱离该代码块时就被销毁了）。

### 5.3 成员变量与局部变量的存储位置

### 局部变量

由于局部变量不属于任何类或实例，因此它总是保存在其所在方法的栈内存中（这种因果关系似乎要搞清楚一些）。

- 若该局部变量是基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中；
- 若该局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对象或数组。

## 成员变量

定义一个成员变量时，成员变量将被内置到堆内存中，成员变量的作用域将扩大到类/对象存在的范围，这种范围的扩大有两个害处：

1. 增大了变量的生存时间，导致更大的内存开销
2. 扩大了变量的作用域，不利于提高程序的内聚性

因为局部变量只保存基本类型的值或者对象的引用，因此局部变量所占的内存区通常比较小。

## 6. 访问权限控制——封装和隐藏

> 为了方便，我们暂且把“类的成员”这个名词当作类的成员变量、方法、构造器等的统称。

## 6.1 类成员访问权限

Java为类成员提供了3个**访问控制符**：private,protected,public，分别代表了3个访问控制级别，加上一个默认的不加任何访问控制符的级别，共有4个访问控制级别（要注意，事实上没有default这个关键字）：

![27](https://chua-n.gitee.io/blog-images/notebooks/Java/27.png)

- private：“私有权限”，该成员只能在当前类的内部被访问
- default：“包访问权限”（默认情况），该成员可以被相同包下的其他类访问
- protected：“子类访问权限”，该成员在上述权限基础上，还可以被其子类访问。
    - 通常情况下，若使用protected修饰一个方法，其用意是希望其子类来重写这个方法。
- public：“公共访问权限”，public的成员可以被所有类访问
    - public不在乎它们是否处于同一个包中或是否具有继承关系

|            | private | [default] | protected | public  |
| :--------: | :-----: | :-------: | :-------: | :-----: |
| 同一个类中 | &radic; |  &radic;  |  &radic;  | &radic; |
| 同一个包中 |         |  &radic;  |  &radic;  | &radic; |
|   子类中   |         |           |  &radic;  | &radic; |
| 全局范围内 |         |           |           | &radic; |

## 6.2 类访问权限

> 类访问权限针对的是外部类，因为内部类属于类的成员了，其访问权限控制参见上节。

对于一个外部类而言，其只有两种访问控制级别，public和default（默认），上述大多数情况是在描述类成员的访问控制级别情况。

- public级别的外部类可以被所有类使用。
- default级别的外部类只能被同一个包中的其他类使用，如在其他类中声明该外部类的变量、创建其实例。

### 6.3 访问权限控制的基本原则

关于访问控制符的使用，可参考如下几条基本原则：

1. 类里的绝大部分成员变量都应该使用private修饰，只有一些static修饰的、类似全局变量的成员变量，才应考虑使用public修饰；

2. 有些方法只用于辅助实现该类的其他方法，通常称之为**工具方法**，它们应该使用private修饰；

3. 若希望某个类主要用做其他类的父类，该类里包含的大部分方法可能仅希望被其子类重写，而不想被外界直接调用，应该使用protected修饰；

4. 希望暴露出来给其他类自由调用的方法应该使用public修饰（因此，类的构造器应该使用public修饰）；

5. 外部类通常都希望被其他类自由使用，所以大部分外部类应使用public修饰（?）。

