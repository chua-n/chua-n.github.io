## 1. 定义

某些情况下，会把一个类放在另一个类的内部定义，这个定义在其他类内部的类称为**内部类**，包含内部类的类也被称为**外部类**。

1. 内部类提供了更好的封装；
2. 内部类成员可以直接访问外部类的私有数据，因为内部类被当成相应外部类的成员；
3. 外部类不能访问内部类的实现细节，例如内部类的成员变量；
4. **匿名内部类**适合用于创建那些仅需要一次使用的类。

---

内部类的定义与外部类的定义语法大致相同，但存在如下两点区别：

1. 内部类定义在一个外部类的内部
2. 内部类比外部类可以多使用三个修饰符：private,      protected, static
3. 非静态内部类不能拥有静态成员

---

外部类的上级程序单员是包，所以它有2个作用域：同一个包内和任何位置，故而只需要包访问权限和public访问权限；而内部类的上一级程序单元是外部类，所有有4个作用域：同一个类、同一个包、父子类、任何位置，故而其使用4种访问控制权限：private级，protected级，default级，public级。

---

通常而言，内部类都被作为成员内部类定义，而非作为局部内部类。

成员内部类的class文件总是这种形式：`OuterClass$InnerClass.class`。

## 2. 非静态内部类

Java不允许在非静态内部类里定义静态成员；

非静态内部类里可以直接访问外部类的private成员，这是因为在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用：

<img src="https://chua-n.gitee.io/figure-bed/notebook/Java/33.png" alt="33" style="zoom:67%;" />

如果外部类成员、内部类成员、内部类中方法的局部变量同名，可通过使用`OuterClassName.this`、`this`作为限定来区分：

```java
public class DiscernVariable{
    private String prop = "外部类的实例变量";
    private class InClass{
        private String prop = "内部类的实例变量";
        public void info() {
            String prop = "局部变量";
            // 通过`外部类类名.this.varName`访问外部类实例变量
            System.out.println("外部类的实例变量值：" + DiscernVariable.this.prop);
            // 通过`this.varName`访问内部类实例的变量
            System.out.println("内部类的实例变量值：" + this.prop);
            // 直接访问局部变量
            System.out.println("局部变量的值：" + prop);
        }
    }
    
    public void test() {
        InClass in = new InClass();
        in.info();
    }
    
    public static void main(String[] args) {
        new DiscernVariable().test();
    }
}
```

根据静态成员不能访问非静态成员的规则，外部类的静态成员中不能直接使用非静态内部类。

## 3. 静态内部类

使用static修饰一个内部类，表明这个内部类属于外部类本身，而不属于外部类的某个对象；

静态内部类可以包含静态成员，也可以包含非静态成员；

当然，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员；

静态内部类是外部类的一个静态成员，因此外部类的所有方法、初始化块中可以使用静态内部类来定义变量、创建对象等；

## 4. 接口里的内部类/内部接口

Java还允许在接口里定义内部类，接口里定义的内部类默认使用public static修饰，即接口内部类只能是静态内部类；此外，接口内部类的访问控制符只能为public，不管是否由程序员显式指定。

其实，接口里还能定义内部接口。

## 5. 在外部定义内部类

在外部类以外的地方定义内部类变量的语法格式为：`OuterClass.InnerClass varName;`

- 当然，如果外部类有包名还应增加包前缀
- 静态和非静态都是如此

虽然内部类是外部类的成员，但不可以在外部类的子类中再定义一个内部类来重写其父类中的内部类成员。因为内部类的类名不再是简单地由内部类的类名组成，它实际上还把外部类的类名作为一个命名空间，作为内部类类名的限制。因此子类中的内部类和父类中的内部类不可能完全同名，也就不可能重写。

## 6. 在外部类以外使用内部类

### 6.1 在外部类以外使用非静态内部类

由于非静态内部类的对象必须寄生在外部类的对象里，创建非静态内部类对象之前必须先创建其外部类对象：

```java
// 语法：OuterInstance.new InnerConstructor();
class Out {
    // 定义一个内部类，不使用访问控制符
    class In {
        public In(String msg) {
            System.out.println(msg);
        }
    }
}

public class CreateInnerInstance {
    public static void main(String[] args) {
        Out.In in = new Out().new In("测试信息");
        /*
         * 上面代码可以改成如下三行代码： 
         * Out.In in; 
         * Out out = new Out(); 
         * in = out.new In("测试信息");
         */
}
```

如果需要在外部类以外的地方创建非静态内部类的子类，则尤其要注意上面的规则：非静态内部类的构造器必须通过其外部类对象来调用。故而，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类的构造器时，必须存在一个外部类对象：

```java
public class SubClass extends Out.In {
    // 显式定义SubClass的构造器
    public SubClass(Out out) {
        // ͨ通过传入的Out对象显式调用In的构造器
        out.super("hello");
    }
}
```

非静态内部类的子类不一定是内部类，但非静态内部类的子类实例一样需要保留一个引用，该引用指向其所在外部类的对象。也就是说，如果有一个内部类子类的对象存在，则一定存在与之对应的外部类对象。

### 6.2 在外部类以外使用静态内部类

创建静态内部类对象时无须创建外部类对象，语法：`New OuterClass.InnerConstructor()`

创建静态内部类的子类也比较简单，如下为静态内部类StaticIn类定义了一个空子类：

```java
public class StaticSubClass extends StaticOut.StaticIn {
    
}
```

使用静态内部类相对简单许多，只要把外部类当成静态内部类的包空间即可。

### 6.3 局部内部类

局部内部类的class文件总是以如下命名：

- `OuterClass$NInnerClass.class`
- 多了一个数字N，是因为同一个类里不可能有两个同名的成员内部类，但可能有两个以上处于不同方法中的同名局部内部类

局部内部类是一个非常“鸡肋”的语法。

## 7. 匿名内部类

匿名内部类的语法有点奇怪，创建匿名内部类时会立即创建一个该类的实例，同时这个类定义立即消失，匿名内部类不能重复使用。

```java
new 实现接口() | 父类构造器(实参列表)
{
	// 匿名内部类的类体部分
}
```

> 由定义语法可知，匿名内部类必须继承一个父类或实现一个接口，但最多只能继承一个父类或实现一个接口。

匿名内部类不能是抽象类，因为匿名内部类在创建时会立即创建类的对象。

> 由于匿名内部类不能是抽象类，所以匿名内部类必须实现它的抽象父类或者接口里包含的所有抽象方法；

匿名内部类不能定义构造器，因为其没有类名。但其可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。

1. 故而当通过接口来创建匿名内部类时，匿名内部类只有一个隐式的无参数构造器，所以new接口名后的括号里不能传入参数值；

2. 如果通过继承父类来创建匿名内部类，匿名内部类将拥有和父类相似的构造器（此处的相似指提拥有相同的形参列表）

如果局部变量被匿名内部类访问，该局部变量相当于自动使用了final修饰（事实上，在Java 8之前，Java要求被局部内部类、匿名内部类访问的局部变量必须显式使用final修饰，而Java8将这个操作隐式化了，并称之为"effectively final"，意思是对于被匿名内部类访问的局部变量，可以用final修饰也可以不用，但必须按照有final修饰的方式来用）。

```java
interface A {
    void test();
}

class ATest {
    public static void main(String[] args) {
        int age = 8;
        // age = 1; // 若存在这条语句会发生编译错误
        A a = new A() {
            public void test() {
                System.out.println(age);
            }
        };
        a.test();
    }
}
```

