## 1. 概念引入

抽象类是从多个类中抽象出来的模板，如果将这种抽象更进一步，则可以提炼出一种更加特殊的“抽象类”——**接口(interface)**。

接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这也意味着接口里通常是定义一组公用方法。

接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这个原则，很多软件架构设计理论都倡导“面向接口编程”，而不是面向实现类编程。面向接口编程的常用场景可参照“简单工厂模式”和“命令模式”。

## 2. 语法

定义接口不再是使用class关键字，而是使用interface关键字。

```java
[public] interface 接口名 [extends 父接口1 父接口2 …]
{
	0~N个常量定义…
	0~N个抽象方法定义…
	0~N个私有方法、默认方法或类方法定义…
	0~N个内部类、接口、枚举定义…
}
```

- 修饰符可以是public或省略，若省略，则默认采用包权限访问控制符(default级别)；
- 接口名的命名像类名那样命名即可，不过接口名通常也使用形容词；
- 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。

## 3. 接口的特性

### 3.1 综述

由于接口定义的是一种**公共的行为规范**，这种设计哲学意味着：

- 接口里不能包含构造器和初始化块；

- 接口里的成员变量、方法、内部类/枚举等，全部是public权限；

- 接口里的成员变量只能是静态常量，即接口里的成员变量都是public     static final修饰的；

- 接口中的方法也是隐式抽象的，即它们是public abstract的，不能有方法体；

- 接口中的定义的内部类、内部接口、内部枚举都是public static的；

- 特殊地，为了更好地服务接口的内涵，接口中的方法还可以定义为类方法（static）、默认方法（default）、私有方法（private），这些方法必须有方法体，故而它们不会隐式地被abstract修饰。

    - **类方法**：必须使用static修饰，毫无疑问，加上隐式的public，它的修饰符是public static的。

    - **默认方法**：必须使用default修饰，default方法不能使用static修饰，综合而言是public default的

        > - 由于默认方法没有static修饰符，不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法；
        > - 接口的默认方法其实就是实例方法，只间由于早期Java的设计是“接口中的实例方法不能有方法体”，Java8也不能直接推倒以前的规则，故而只好重新定义了一个所谓的“默认方法”，说白了，默认方法就是有方法体的实例方法。

    - **私有方法**：必须使用private修饰，作用是为接口中的默认方法或类方法提供支持，其不能使用default修饰，但可以用static修饰，即私有方法既可以是类方法又可以是实例方法。

### 3.2 一个接口示例

```java
package lee;

public interface Output {
    // 接口里的成员变量只能是常量
    int MAX_CACHE_LINE = 50;
    
    // 接口里的普通方法只能是public的抽象方法
    void out();
    void getData(String msg);
    
    // 在接口中定义默认方法，需要使用default修饰
    default void print(String... msgs) {
        for (String msg : msgs) {
            System.out.println(msg);
        }
    }
    
    // 在接口中定义默认方法，需要使用default修饰
    default void test() {
        System.out.println("默认的test()方法");
    }
    
    // 在接口中定义类方法，需要使用static修饰
    static String staticTest() {
        return "接口里的类方法";
    }
    
    // 定义私有方法
    private void foo() {
        System.out.println("foo私有方法");
    }
    
    // 定义私有静态方法
    private static void bar() {
        System.out.println("bar私有静态方法");
    }
}
```

### 3.3 接口的继承

接口的继承和类不一样，接口完全支持多继承。和类继承相似，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。

```java
interface InterfaceA {
    int PROP_A = 5;
    void testA();
}

interface InterfaceB {
    int PROP_B = 6;
    void testB();
}

interface InterfaceC extends InterfaceA, InterfaceB {
    int PROP_C = 7;
    void testC();
}

public class InterfaceExtendsTest {
    public static void main(String[] args) {
        System.out.println(InterfaceC.PROP_A);
        System.out.println(InterfaceC.PROP_B);
        System.out.println(InterfaceC.PROP_C);
    }
}
```

### 3.4 使用接口

接口不能用于创建实例，但接口可以用于声明引用类型变量，此时这个引用类型变量必须引用到其实现类的对象；除此之外，接口的主要用途就是被实现类实现。

一个类可以实现一个或多个接口，其中继承使用extends关键字，实现使用implements关键字，这也是Java为单继承灵活性不足所做的补充：

```java
[修饰符] class 类名 extends 父类 implements 接口1, 接口2…
{
    // 类体部分
}
```

一个类实现了一个或多个接口后，这个类必须完全实现这些接口里所定义的全部抽象方法；否则，这个类将保留从父接口那里继承到的抽象方法，导致该类也必须定义成抽象类。

实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（实现类）重写父类方法时访问权限只能更大或者相等，所以实现类实现接口里的方法时只能使用public访问权限。

接口不能显式继承任何类，但所有接口类型的引用变量都可以直接赋给Object类型的引用变量。

## 4. 接口和抽象类的比较

接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承；

接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法；

接口和抽象类的差别主要体现在二者的设计目的上：接口体现的是一种规范，抽象类体现的是一种模板式设计。

以及一些用法上的差别……

