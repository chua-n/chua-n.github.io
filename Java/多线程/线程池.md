## 1. 线程池概念

**线程池**在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个对象的run()或call()方法。

使用线程池可以有效地控制系统中并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至JVM崩溃，而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/49.png" alt="49" style="zoom:50%;" />

## 2. Executors工厂类

### 2.1 Executors的静态方法

Java提供了一个**Executors工厂类**来产生线程池，其包含如下几个静态方法来创建线程池：

| Executors的静态方法                                          | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ExecutorService  newCachedThreadPool()                       | 创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中 |
| ExecutorService  newFixedThreadPool(int nThreads)            | 创建一个可重用的、具有固定线程数的线程池                     |
| ExecutorService  newSingleThreadExecutor()                   | 创建一个只有单线程的线程池，相当于调用newFixedThreadPool(1)  |
| ScheduledExecutorService  newScheduledThreadPool(int corePoolSize) | 创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内 |
| ScheduledExecutorService  newSingleThreadScheduledExecutor() | 创建只有一个线程的线程池，它可以在指定延迟后执行线程任务     |
| ExecutorService  newWorkStealingPool(int parallelism)        | 创建持有足够的线程的线程池来支持给定的并行级别，本方法还会使用多个队列来减少竞争 |
| ExecutorService  newWorkStealingPool()                       | 上一个方法的简化版。若当前机器有4个CPU，则目标并行级别被设置为4，相当于上一个方法传入4为参数 |

- `ExecutorService`接口代表一个线程池，它可以执行Runnable/Callable对象所代表的线程，ExecutorServic同时代表尽快执行线程的线程池，只要线程池中有空闲线程，就立即执行线程任务；
- `ScheduledExecutorService`是`ExecutorService`的子接口，它代表可在指定延迟后或周期性地执行线程任务的线程池。
- 上述7种方法中最后2种是Java8新增的，其可充分利用多CPU并行的能力。这两个方法生成的work stealing池，都相当于后台线程池，如果所有的前台线程都死亡了，work stealing池中的线程会自动死亡。

### 2.2 ExecutorServic

ExecutorServic里提供了3个方法：

- `Future<?> submit(Runnable task)`
- `<T> Future<T> submit(Runnable task, T result)`
- `<T> Future<T> submit(Callable<T> task)`

### 2.3 ScheduledExecutorService

ScheduledExecutorService提供了4个方法：

- `ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)`
- `ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)`
- `ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay long period, TimeUnit unit)`
- `ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)`

## 3. 线程池的shutdown()方法与shutdownNow()方法

用完一个线程池后，应该调用线程池的`shutdown()`方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接收新任务，但会将以前所有已提交的任务执行完成。当线程池中所有任务执行完成后，池中的所有线程都会死亡。

也可以调用线程池的`shutdownNow()`方法关闭线程池，该方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。

## 4. 线程池的使用步骤

使用线程池来执行线程任务的步骤如下：

1. 调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池；

2. 创建Runnable/Callable实现类的实例，作为线程执行任务；

3. 调用ExecutorService对象的submit()方法来提交Runnable/Callable实例；

4. 当不想提交任何任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class ThreadPoolTest {
    public static void main(String[] args) throws Exception {
        // 创建一个具有固定线程数（6）的线程池
        ExecutorService pool = Executors.newFixedThreadPool(6);
        Runnable target = () -> {
            for (int i = 0; i < 100; ++i) {
                System.out.println(Thread.currentThread().getName() + "的不值为：" + i);
            }
        };
        pool.submit(target);
        pool.submit(target);
        pool.shutdown();
    }
}
```

## 5. ForkJoinPool类

Java还提供了`ForkJoinPool`类来支持将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。

### 5.1 构造器

| 方法                           | 作用                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| ForkJoinPool(int  parallelism) | 创建一个包含parallelism个并行线程的ForkJoinPool              |
| ForkJoinPool()                 | 以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool |

### 5.2 方法

ForkJoinPool通过2个静态方法提供通用池功能：

| 方法                            |                                                              |
| ------------------------------- | ------------------------------------------------------------ |
| ForkJoinPool  commonPool()      | 返回一个通用池，通用池的运行状态不会受shutdown()/shutdownNow()方法的影响 |
| int  getCommonPoolParallelism() | 返回通用池的并行级别                                         |

ForkJoinPool提供的执行任务的方法：

| 方法                       |      |
| -------------------------- | ---- |
| submit(ForkJoinTask  task) |      |
| invoke(ForkJoinTask  task) |      |

> - ForkJoinTask代表一个可以并行、合并的任务，其是一个抽象类；
> - ForkJoinTask还有两个抽象子类：RecursiveAction,     RecursiveTask，前者代表有返回值的任务，后者代表没有返回值的任务。

### 5.3 示例

```java
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;
import java.util.concurrent.TimeUnit;
// “大任务”：简单地打印0~300的数值
class PrintTask extends RecursiveAction {
    // 每个“小任务”最多只打印50个数
    private static final int THRESHOLD = 50;
    private int start;
    private int end;
    // 打印从start到end的任务
    public PrintTask(int start, int end) {
        this.start = start;
        this.end = end;
    }
    @Override
    protected void compute() {
        // 当end与start之间的差小于THRESHOLD时，开始打印
        if (end - start < THRESHOLD) {
            for (int i = start; i < end; ++i)
                System.out.println(Thread.currentThread().getName() + "的i值为：" + i);
        } else {
            // 当end与start之间的差大于THRESHOLD时
            // 将大任务分解成两个小任务
            int middle = (start + end) / 2;
            PrintTask left = new PrintTask(start, middle);
            PrintTask right = new PrintTask(middle, end);
            // 并行执行两个“小任务”
            left.fork();
            right.fork();
        }
    }
}
class ForkJoinPoolTest {
    public static void main(String[] args) throws Exception {
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(new PrintTask(0, 300));
        pool.awaitTermination(2, TimeUnit.SECONDS);
        pool.shutdown();
    }
}
```

