## 1. 线程同步的典型问题

线程同步的典型问题即是“生产者-消费者”问题：

- 假设有一个线程负责往数据区写数据，另一个线程从同一数据区中取数据，两个线程可以并行执行。
- 如果数据区已满，生产者要等消费者取走一些数据后才能再写。
- 如果数据区已空，消费者要等生产者写入一些数据后才能再取。

具体而言，比如经典的银行取钱问题：

```java
// 定义一个账户类
class Account {
    private String accountNo;
    private double balance;  // balance：余额
    
    public Account() {
    }
    
    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }
    
    // accountNo的setter与getter方法
    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
    public String getAccountNo() {
        return this.accountNo;
    }
    
    // balance的setter与getter方法
    public void setBalance(double balance) {
        this.balance = balance;
    }
    public double getBalance() {
        return this.balance;
    }
    
    // 下面根据accountNo来重写hashCode()和equals()方法
    public int hashCode() {
        return accountNo.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj != null && obj.getClass() == Account.class) {
            Account target = (Account) obj;
            return target.getAccountNo().equals(accountNo);
        }
        return false;
    }
}

// 定义一个取钱的线程类
class DrawThread extends Thread {
    private Account account;
    private double drawAmount;
    
    public DrawThread(String name, Account account, double drawAmount) {
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }
    
    // 当多个线程修改同一个共享数据时，将涉及数据安全问题
    public void run() {
        // 账户余额大于取钱数目
        if (account.getBalance() >= drawAmount) {
            // 吐出钞票
            System.out.println(getName() + "取钱成功！吐出钞票：" + drawAmount);
            
            /*
	         * // 取消掉这里的注释代码也依然是错误的程序
	         * try { Thread.sleep(1); } catch (InterruptedException ex) {
	         * ex.printStackTrace(); }
	         */
            
            // 修改余额
            account.setBalance(account.getBalance() - drawAmount);
            System.out.println("\t余额为：" + account.getBalance());
        } else {
            System.out.println(getName() + "取钱失败！余额不足！");
        }
    }
}

// 模拟取钱过程
class DrawTest {
    public static void main(String[] args) {
        Account acct = new Account("1234567", 1000);
        // 模拟两个线程对同一个账户取钱
        new DrawThread("甲", acct, 800).start();
        new DrawThread("乙", acct, 800).start();
        // -----------结果如下，总是出错-----------：
        // 乙取钱成功！吐出钞票：800.0
        // 甲取钱成功！吐出钞票：800.0
        //         余额为：200.0
        //         余额为：-600.0
    }
}
```

## 2. synchronized

### 2.1 介绍

synchronized——线程同步关键字，实现互斥。

1. 用于指定需要同步的代码段或方法，也就是<font size=5>**监视区**</font>。
2. 可实现与一个锁旗标的交互，例如： `synchronized(obj) {代码段}` 
3. synchronized的功能是：首先判断对象的锁旗标是否存在，如果在就获得锁旗标，然后就可以执行紧随其后的代码段；如果对象的锁旗标不在（已被其他线程拿走），就进入等待状态，直到获得锁旗标。
4. 当被synchronized限定的代码段执行完，就释放锁旗标。

**synchronized**后的代码段可以是方法、代码块，但不能修饰构造器、成员变量等。

### 2.2 同步监视器及同步代码块

当有两个进程并发修改同一个文件时就有可能造成异常。为了解决同步问题，Java的多线程引入了<font size=5>**同步监视器**</font>，而使用同步监视器的通用方法就是<font size=5>**同步代码块**</font>。同步代码块的语法为：

```java
synchronized(obj)
{
	// ……
	// 此处的代码就是同步代码块
}
```

> - 上边的obj就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定；
> - 任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。       

虽然Java程序允许使用任何对象作为同步监视器，但通常还是应该使用可能被并发访问的共享资源充当同步监视器。

```java
class DrawThread extends Thread {
    
    private Account account;
    private double drawAmount;
    
    public DrawThread(String name, Account account, double drawAmount) {
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }
    
    // 当多个线程修改同一个共享数据时，将涉及数据安全问题
    public void run() {
        // 使用account作为同步监视器，任何线程进入下面同步代码块之前
        // 必须先获得对account账户的锁定
        // 这种做法符合：“加锁——修改——释放锁”的逻辑
        synchronized (account) {
            // 账户余额大于取钱数目
            if (account.getBalance() >= drawAmount) {
                // 吐出钞票
                System.out.println(getName() + "取钱成功！吐出钞票：" + drawAmount);
                // try {
                //     Thread.sleep(1);
                // } catch (InterruptedException ex) {
                //     ex.printStackTrace();
                // }
                // 修改余额
                account.setBalance(account.getBalance() - drawAmount);
                System.out.println("\t余额为：" + account.getBalance());
            } else {
                System.out.println(getName() + "取钱失败！余额不足！");
            }
        }
        // 同步代码块结束，该线程释放同步锁
    }
}
```

### 2.3 同步方法

与同步代码块对应，Java的多线程安全支持还提供了同步方法，<font size=5>**同步方法**</font>就是用synchronized关键字来修饰的方法。对于synchronized修饰的实例方法，无须显式指定同步监视器，**同步方法的同步监视器就是this**，即调用该方法的对象。

下面把Account类对balance的访问设置成线程安全的，只要把修改balance的方法变成同步方法即可：

```java
class Account {
    private String accountNo;
    private double balance;
    
    public Account() {
    }
    
    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }
    
    // accountNo的setter与getter方法
    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
    
    public String getAccountNo() {
        return this.accountNo;
    }
    
    // balance的getter方法
    public double getBalance() {
        return this.balance;
    }
    
    // 提供一个线程安全的draw()方法来完成取钱操作
    public synchronized void draw(double drawAmount) {
        // 账户余额大于取钱数目
        if (balance >= drawAmount) {
            // 吐出钞票
            System.out.println(Thread.currentThread().getName() + "取钱成功！吐出钞票：" + drawAmount);
            try {
                Thread.sleep(1);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            // 修改余额
            balance -= drawAmount;
            System.out.println("\t余额为：" + balance);
        } else {
            System.out.println(Thread.currentThread().getName() + "取钱失败！余额不足！");
        }
    }
    
    // 下面根据accountNo来重写hashCode()和equals()方法
    public int hashCode() {
        return accountNo.hashCode();
    }
    
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj != null && obj.getClass() == Account.class) {
            Account target = (Account) obj;
            return target.getAccountNo().equals(accountNo);
        }
        return false;
    }
}
```

### 2.4 同步监视器的释放

任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？实际上，程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下进行释放：

1. 当前线程的同步代码块、同步方法执行结束：

    - 正常结束；

    - 遇到break、return等结束；

    - 抛出异常。

2. 当前线程执行同步代码块/同步方法时，程序执行了**同步监视器对象的`wait()`方法**，则当前线程暂停，并释放同步监视器。

值得注意的是，以下情况线程不会释放同步监视器：

1. 线程执行同步代码块/同步方法时，程序调用Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器；

2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。

### 2.5 效率

可变类的线程安全是以降低程序的运行效率为代价的，为了减少线程安全带来的负面影响，程序可以采用如下策略：

1. 不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源（竞争资源也就是共享资源）的方法进行同步；

2. 如果可变类有两种运行环境：单线程环境和多线程环境，则应该为该可变类提供两种版本，即线程不安全版本和线程安全版本，在单线程环境中使用线程不安全版本以保证性能，在多线程环境中使用线程安全版本。

## 3. 同步锁

Java可以通过显式定义<font size=5>**同步锁**</font>对象来实现同步，在这种机制下，同步锁由`Lock`对象充当。

1. Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，其允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。
2. Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。
3. Lock的一些方法：
    - `tryLock()`
    - `tryLock(long TimeUnit)`
    - `lockInterruptibly()`

某些锁可能允许对共享资源进行并发访问，如`ReadWriteLock`（读写锁）。

`Lock`、`ReadWriteLock`是两个根接口，Java为`Lock`提供了`ReentrantLock`（可重入锁）实现类，为`ReadWriteLock`提供了`ReentrantReadWriteLock`实现类。

1. ReentrantLock锁具有**可重入性**，即一个线程可以对已被加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套调用，线程在每次调用lock()加锁后，必须显式调用unlock()释放锁。<font color="red">因此，一段被加锁保护的代码可以调用另一个被相同锁保护的方法（？？？）。</font>

2. ReentrantReadWriteLock为读写操作提供了三种锁模式：**Writing**, **ReadingOptimistic**, **Reading**。

Java8新增了`StampedLock`类，在大多数场景中它可以替代传统的ReentrantReadWriteLock。

在实现线程安全的控制中，比较常用的是ReentrantLock，该Lock对象可以显式地加锁、释放锁，其一般的代码格式为：

```java
class X {
    // 定义锁对象
    private final ReentrantLock lock = new ReentrantLock();
    // ...
    // 定义需要保证线程安全的方法
    public void method() {
        lock.lock(); // 加锁
        try {
            // 需要保证线程安全的代码
        } finally {
            // 使用finally块来保证释放锁
            lock.unlock();
        }
    }
}
```

显然可使用同步锁的方式改写之前Account类的同步方法draw()。

## 4. 死锁

线程在运行过程中，其中某个步骤往往需要满足一些条件才能继续进行下去，如果这个条件不能满足，线程将在这个步骤上出现阻塞。例如，线程A可能会陷于对线程B的等待，而线程B同样陷于对线程C的等待，依次类推，整个等待链最后又可能回到线程A，如此一来便陷入一个彼此等待的轮回中，任何线程都动弹不得，此即所谓<font size=5>**死锁**</font>（deadlock）。

对于死锁问题，关键不在于出现问题后调试，而在于**预防**！

当两个线程相互等待对方释放同步监视器时就会发生死锁，一旦出现死锁，程序不会发生任何异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。

```java
class A {
    public synchronized void foo(B b) {
        System.out.println("当前线程名：" + Thread.currentThread().getName() + " 进入了A实例的foo()方法");
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        System.out.println("当前线程名：" + Thread.currentThread().getName() + " 企图调用B实例的last()方法");
        b.last();
    }
    public synchronized void last() {
        System.out.println("进入了A类的last()方法内部");
    }
}

class B {
    public synchronized void bar(A a) {
        System.out.println("当前线程名：" + Thread.currentThread().getName() + " 进入了B实例的bar()方法");
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        System.out.println("当前线程名：" + Thread.currentThread().getName() + " 企图调用A实例的last()方法");
        a.last();
    }
    public synchronized void last() {
        System.out.println("进入了B类的last()方法内部");
    }
}

class DeadLock implements Runnable {
    A a = new A();
    B b = new B();
    public void init() {
        Thread.currentThread().setName("主线程");
        a.foo(b);
        System.out.println("进入了主线程之后");
    }
    public void run() {
        Thread.currentThread().setName("副线程");
        b.bar(a);
        System.out.println("进入了副线程之后");
    }
    public static void main(String[] args) {
        DeadLock dl = new DeadLock();
        new Thread(dl).start();
        dl.init();
    }
}
```

