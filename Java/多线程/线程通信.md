## 1. 传统方法

Object类提供了wait(),     notify(), notifyAll()三个方法，这三个方法必须由同步监视器对象来调用，这分成两种情况：

1. 对于使用synchronized修饰的同步方法，由于该类的默认实例(this)就是同步监视器，所以可以在同步方法中直接调用这三个方法。

2. 对于使用synchronized修饰的同步代码块，同步监视器是synchronized括号里的对象，所以必须使用该对象调用这三个方法。

Account类的改写：

```java
class Account {
    private String accountNo;
    private double balance;
    private boolean flag = false; // 标识账户中是否已有存款的旗标
    public Account() {
    }
    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }
    // accountNo的setter与getter方法
    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
    public String getAccountNo() {
        return this.accountNo;
    }
    // 因为账户余额不允许随便修改，所以只为balance提供getter方法
    public double getBalance() {
        return this.balance;
    }
    public synchronized void draw(double drawAmount) {
        try {
            if (flag == false) {
                wait();
            } else {
                System.out.println(Thread.currentThread().getName() + " 取钱：" + drawAmount);
                balance -= drawAmount;
                System.out.println("账户余额为：" + balance);
                flag = false;
                notifyAll(); // 唤醒其他线程
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }
    public synchronized void deposit(double depositAmount) {
        try {
            if (flag == true) {
                wait();
            } else {
                System.out.println(Thread.currentThread().getName() + " 存款：" + depositAmount);
                balance += depositAmount;
                System.out.println("账户余额为：" + balance);
                flag = true;
                notifyAll(); // 唤醒其他线程
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }
    // 省略hashCode()和equals()方法
}
```

## 2. Condition

如果程序不使用synchronized关键字来保证同步，而是直接使用lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait(),     notify(), notifyAll()方法进行线程通信了。

Java提供了**Condition类**，Condition将同步监视器方法（wait(), notify(),     notifyAll()）分解成截然不同的对象，以便通过将这些对象与Lock对象组合使用，为每个对象提供多个等待集，在这种情况下，Lock替代了同步方法或同步代码块，Condition替代了同步监视器的功能。

Condition实例被绑定在一个Lock对象上。要获得特定Lock实例的Condition实例，调用**Lock对象的newCondition()方法**即可。Condition类提供了如下三个方法：

| Condition类的方法 | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| await()           | 导致当前线程等待，直到其他线程调用该Condition的signal()或signalAll()方法来唤醒该线程。await()方法有更多变体，可以完成更丰富的等待操作。 |
| signal()          | 唤醒在此Lock对象上等待的单个线程。若有多个线程都在该Lock对象上等待，随机唤醒其中一个。只有当前线程放弃对该Lock对象的锁定后（使用await()方法），才可以执行被唤醒的线程。 |
| signalAll()       | 唤醒在此Lock对象上等待的所有线程。只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。 |

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Account {
    private final Lock lock = new ReentrantLock();
    private final Condition cond = lock.newCondition();
    private String accountNo;
    private double balance;
    private boolean flag = false; // 标识账户中是否已有存款的旗标
    public Account() {
    }
    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }
    // accountNo的setter与getter方法
    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
    public String getAccountNo() {
        return this.accountNo;
    }
    // 因为账户余额不允许随便修改，所以只为balance提供getter方法
    public double getBalance() {
        return this.balance;
    }
    public void draw(double drawAmount) {
        lock.lock(); // 加锁
        try {
            if (flag == false) {
                cond.await();
            } else {
                System.out.println(Thread.currentThread().getName() + " 取钱：" + drawAmount);
                balance -= drawAmount;
                System.out.println("账户余额为：" + balance);
                flag = false;
                cond.signalAll(); // 唤醒其他线程
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void deposit(double depositAmount) {
        lock.lock();
        try {
            if (flag == true) {
                cond.await();
            } else {
                System.out.println(Thread.currentThread().getName() + " 存款：" + depositAmount);
                balance += depositAmount;
                System.out.println("账户余额为：" + balance);
                flag = true;
                cond.signalAll(); // 唤醒其他线程
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    // 省略hashCode()和equals()方法
}
```

## 3. BlockingQueue

Java提供了一个**BlockingQueue接口**，虽然其也是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程同步的工具。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。

BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，若该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，若该队列已空，则该线程被阻塞。

BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法。但在这里值得注意的是BlockingQueue提供的两个支持阻塞的方法：

| 方法     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| put(E e) | 尝试把e元素放入BlockingQueue中，若该队列的元素已满，阻塞该线程 |
| take()   | 尝试从BlockingQueue的头部取出元素，若该队列的元素已空，阻塞该线程 |

BlockingQueue包含如下5个实现类：

| BlockingQueue的实现类 | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| ArrayBlockingQueue    | 基于数组实现的BlockingQueue队列                              |
| LinkedBlockingQueue   | 基于链表实现的BlockingQueue队列                              |
| PriorityBlockingQueue | ……                                                           |
| SynchronousQueue      | 同步队列。对其的存、取操作必须交替进行                       |
| DelayQueue            | 一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，但DelayQueue要求集合元素都实现Delay接口，DelayQueue根据集合元素的getDelay()方法返回值进行排序 |

> BlockingQueue与其实现类之间的类图：
>
> ![48](https://chua-n.gitee.io/blog-images/notebooks/Java/48.png)

代码示例：

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

class Producer extends Thread {
    private BlockingQueue<String> bq;
    public Producer(BlockingQueue<String> bq) {
        this.bq = bq;
    }
    public void run() {
        String[] strArr = new String[] { "Java", "Struts", "Spring" };
        for (int i = 0; i < 999999999; ++i) {
            System.out.println(getName() + "生产者准备生产集合元素！");
            try {
                Thread.sleep(200);
                bq.put(strArr[i % 3]);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            System.out.println(getName() + "生产完成：" + bq);
        }
    }
}

class Consumer extends Thread {
    private BlockingQueue<String> bq;
    public Consumer(BlockingQueue<String> bq) {
        this.bq = bq;
    }
    public void run() {
        while (true) {
            System.out.println(getName() + "消费者准备消费集合元素！");
            try {
                Thread.sleep(200);
                bq.take();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            System.out.println(getName() + "消费完成：" + bq);
        }
    }
}

class BlockingQueueTest {
    public static void main(String[] args) {
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(1);
        // 启动3个生产者线程
        new Producer(bq).start();
        new Producer(bq).start();
        new Producer(bq).start();
        // 启动1个消费者线程
        new Consumer(bq).start();
    }
}
```

