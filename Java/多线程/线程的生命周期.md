线程生命周期的5种状态：新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)、死亡(Dead)。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/47.png" alt="47" style="zoom:67%;" />

## 1. 新建状态

当程序使用new关键字创建了一个线程之后，该线程就处于**新建状态**。此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。

## 2. 就绪状态

当线程对象调用了start()方法之后，该线程处于**就绪状态**，JVM会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了，至于该线程何时开始运行，取决于JVM里线程调度器的调度。

1. 调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理。
2. 但若调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。
3. 直接调用run()方法时，Thread的this.getName()方法返回的是该对象的名字，而不是当前线程的名字。

```java
class InvokeRun extends Thread {
    private int i;
    
    public void run() {
        for (; i < 100; ++i) {
            // 直接调用run()方法时，Thread的this.getName()返回的是该对象的名字，而不是当前线程的名字
            // 使用Thread.currentThread().getName()总是获取当前线程的名字
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 100; ++i) {
            // 调用Thead的currentThread()方法获取当前线程
            System.out.println(Thread.currentThread().getName() + " " + i);
            if (i == 20) {
                // 直接调用线程对象的run()方法
                // 系统会把线程对象当成普通对象，把run()方法当成普通方法
                // 所以下面两行代码并不会启动两个线程，而是依次执行两个run()方法
                new InvokeRun().run();
                new InvokeRun().run();
            }
        }
    }
}
```

## 3. 运行状态

就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定：

- 当处于就绪状态的线程获得处理器资源时，该线程进入**运行状态**；
- 当处于运行状态的线程失去处理器资源，或程序主动调用了yield()方法时，该线程进入就绪状态。

## 4. 阻塞状态

当发生如下情况时，线程将会进入**阻塞状态**：

1. 线程调用sleep()方法主动放弃所占用的处理器资源；

2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；

3. 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；

4. 线程在等待某个通知(notify)；

5. 程序调用了线程的suspend()方法将该线程挂起（suspend()方法很容易导致死锁，应该尽量避免使用该方法）。

线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。

## 5. 死亡状态

线程会以如下三种方式结束，结束后就处于**死亡状态**：

1. run()或call()方法执行完成，线程正常结束；

2. 线程抛出一个未捕获的Exception或Error；

3. 直接调用该线程的stop()方法来结束该线程（不推荐）。

> 使用stop()方法可以结束线程的生命，但如果一个线程正在操作共享数据段，操作过程没有完成就用stop()结束，将会导致数据操作的不完整，因此不提倡使用该方法。通常，可通过控制run()方法中循环条件的方式来结束一个线程。

当主线程结束时，其他线程不受任何影响，并不会随之结束。事实上，一旦子线程启动起来，它就拥有和主线程同样的地位。

不要对处于死亡状态的线程调用start()方法，会引起IllegalThreadStateException异常，程序只能对新建状态的线程调用start()方法。

为了测试某个线程是否已经死亡，可以调用线程对象的**isAlive()方法**，其返回一个boolean值：

| 线程状态       | `isAlive()`返回值 |
| -------------- | ----------------- |
| 就绪/运行/阻塞 | true              |
| 新建/死亡      | false             |


