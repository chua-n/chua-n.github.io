## 1. ThreadLocal类

**ThreadLocal类**，是Thread Local Variable（线程局部变量）的意思，ThreadLocal为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量一样。

ThreadLocal类只提供了如下3个都是public的方法：

| 方法               | 说明                                   |
| ------------------ | -------------------------------------- |
| T  get()           | 返回此线程局部变量中当前线程副本中的值 |
| void  remove()     | 删除此线程局部变量中当前线程的值       |
| void  set(T value) | 设置此线程局部变量中当前线程副本中的值 |

ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象与线程相关的状态使用ThreadLocal保存；

ThreadLocal是为了隔离多个线程的数据共享，从根本上避免多个线程之间对共享资源（变量）的竞争。

```java
class Account {
    private ThreadLocal<String> name = new ThreadLocal<>();
    public Account(String str) {
        this.name.set(str);
        System.out.println("---" + this.name.get());
    }
    // name的setter, getter方法
    public String getName() {
        return name.get();
    }
    public void setName(String str) {
        this.name.set(str);
    }
}

class MyTest extends Thread {
    private Account account;
    public MyTest(Account account, String name) {
        super(name);
        this.account = account;
    }
    public void run() {
        for (int i = 0; i < 10; ++i) {
            if (i == 6)
                account.setName(getName());
            System.out.println(account.getName() + " 账户的i值：" + i);
        }
    }
}

class ThreadLocalTest {
    public static void main(String[] args) {
        /*
	         * 虽然两个线程共享同一个账户，即只有一个账户名
	         * 但由于账户名是ThreadLocal类型的，所以每个线程都完全拥有各自的副本
	         * 故在i == 6之后，将看到两个线程访问同一个账户时出现不同的账户名
	         */
        Account at = new Account("初始名");
        new MyTest(at, "线程甲").start();
        new MyTest(at, "线程已").start();
    }
}
```

## 2. Collections工具类

包装线程不安全的集合——使用**Collections**提供的如下几个静态方法：

- `<T> Collection<T> synchronizedCollection(Collection<T> c)`：返回指定collection对应的线程安全的collection
- `static <T> List<T> synchronizedList(List<T> list)`
- `static <K, V> Map<K, V> synchronizedMap(Map<K, V> m)`
- `static <T> Set<T> synchronizedSet(Set<T> s)`
- `static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> m)`
- `static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)`

## 3. java.util.concurrent包

线程安全的集合类——在**java.util.concurrent包**下提供了大量支持高效并发访问的集合接口和实现类：

![50](https://chua-n.gitee.io/blog-images/notebooks/Java/50.png)

这些线程安全的集合类可以分为如下两类：

1. 以Concurrent开头的集合类：代表支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定，因此在并发写入时具有较好的性能；

2. 以CopyOnWrite开头的集合类。

因为ConcurrentLinkedQueue和ConcurrentHashMap支持多线程并发访问，所以当使用迭代器来遍历集合元素时，该迭代器可能不能反映出创建迭代器之后所做的修改，但程序不会抛出任何异常。

Java8为ConcurrentHashMap新增了30多个新方法，它们可借助于Stream和Lambda表达式执行聚集操作，这些新增方法大致分为如下3类：

1. forEach系列：forEach,      forEachKey, forEachValue, forEachEntry

2. search系列：search,      searchKeys, searchValues, searchEntries

3. reduce系列：reduce,      reduceToDouble, reduceToLong, reduceKeys, reduceValues

当线程对CopyOnWriteArrayList集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞，因而读取操作很快、很安全；当线程对CopyOnWriteArrayList集合执行写入操作时，该集合会在底层复制一份新的数组，接下来对新的数组执行写入操作，故而保证了线程安全，但也因此使得其在写入操作时性能较差。