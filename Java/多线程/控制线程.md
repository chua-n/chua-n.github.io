## 1. join()方法

Thread提供了让一个线程等待另一个线程完成的方法：`join()`方法。当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被调用join()方法的线程执行完为止。

join()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。

join()方法有如下三种重载形式：

| 方法                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| join()                        | 等待被join的线程执行完成；                                   |
| join(long  millis)            | 等待被join的线程的时间最长为millis毫秒，若届时被join的线程还未结束，则不再等待； |
| join(long  millis, int nanos) | 等待被join的线程的时间最长为millis毫秒加nanos毫微秒。        |

> 由于计算机硬件、操作系统本身通常无法精确到毫微秒，因此一般很少使用第三种形式。

示例程序：

```java
class JoinThread extends Thread {
    // 提供一个有参数的构造器，用于设置该线程的名字
    public JoinThread(String name) {
        super(name);
    }
    
    public void run() {
        for (int i = 0; i < 100; ++i) {
            System.out.println(getName() + " " + i);
        }
    }
    
    public static void main(String[] args) throws Exception {
        new JoinThread("新线程").start();
        for (int i = 0; i < 100; ++i) {
            if (i == 20) {
                JoinThread jt = new JoinThread("被Join的线程");
                jt.start();
                // main线程调用了jt线程的join()方法
                // main线程必须等jt执行结束才会向下执行
                jt.join();
            }
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}
```

## 2. 后台线程

有一种线程，它是在后台运行的，其任务是为其他的线程提供服务，这种线程被称为“**后台线程**”，又称为“**守护线程**”。JVM的垃圾回收线程就是典型的后台线程。

后台线程的特点是：如果所有的前台线程都死亡，后台线程会自动死亡。前台线程死亡后，JVM会通知后台线程死亡，但从它接收指令到做出响应，需要一定时间。

调用Thread对象的`setDaemon(true)`方法可将指定线程设置成后台线程。且若要将某个线程设置为后台线程，必须在该线程启动之前设置，即setDaemon(true)必须在start()方法之前调用，否则会引发IllegalThreadStateException异常。

Thread类还有一个`isDaemon()`方法，用于判断指定线程是否为后台线程。

并不是所有的线程默认都是前台线程，有些线程默认就是后台线程：前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。

后台线程示例：

```java
class DaemonThread extends Thread {
    public void run() {
        for (int i = 0; i < 1000; ++i) {
            System.out.println(getName() + " " + i);
        }
    }
    
    public static void main(String[] args) {
        DaemonThread t = new DaemonThread();
        // 将此线程设置为后台线程
        t.setDaemon(true);
        t.start();
        for (int i = 0; i < 10; ++i) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        // -----程序执行到此处，前台线程(main线程)结束
        // 后台线程也应该随之结束
    }
}
```

## 3. 线程睡眠

Thread类的静态`sleep()`方法可以让当前正在执行的前线暂停一段时间，进入阻塞状态。

| 方法签名                                   | 说明                                            |
| ------------------------------------------ | ----------------------------------------------- |
| static  void sleep(long millis)            | 让当前正在执行的线程暂停millis毫秒              |
| static  void sleep(long millis, int nanos) | 让当前正在执行的线程暂停millis毫秒加nanos毫微秒 |

Thread还提供了一个与sleep()方法有点相似的`yield()`**静态方法**，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。

1. yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次。完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。

2. 当某个线程调用了yield()方法暂停之后，只有<font color="red">优先级与当前线程相同或更高、且处于就绪状态的线程才会获得执行的机会</font>。

sleep()方法和yield()方法的区别如下：

1. sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级，但yield()方法只会给优先级相同或更高的线程执行机会；

2. sleep()方法会将线程转入阻塞状态，直到经过阻塞状态才会转入就绪状态，而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态，故而完全有可能某个线程被yield()方法暂停之后，立即再次获得处理器资源被执行；

3. sleep()方法声明抛出了InterruptedException异常，所以调用sleep()方法时要么捕捉该异常，要么显示抛出该异常，而yield()方法则没有声明抛出任何异常；

4. sleep()方法比yield()方法有更好的可移值性，通常不建议使用yield()方法来控制并发线程的执行。

## 4. 改变优先级

每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会。

每个线程默认的优先级都与创建它的父线程的优先级相同。

在默认情况下，main线程具有普通优先级。

Thread类提供了`setPriority(int newPriority)`、`getPriority()`方法来设置和返回指定线程的优先级，其中setPriority()方法的参数可以是一个整数，范围是1~10之间，也可以使用Thread类的如下三个静态常量：

|   静态常量    |   说明   |
| :-----------: | :------: |
| MAX_PRIORITY  | 其值为10 |
| MIN_PRIORITY  | 其值为1  |
| NORM_PRIORITY | 其值为5  |

> 虽然Java提供了10个优先级级别，但这些优先级级别需要操作系统的支持，遗憾的是，不同操作系统上的优先级并不相同，而且也不能很好地和Java的10个优先级对应，如Windows 2000仅提供了7个优先级。因此应该尽量避免直接为线程指定优先级，应该使用MAX_PRIORITY, MIN_PRIORITY, NORM_PRIORITY三个静态常量来设置优先级，这样才可以保证程序具有最好的可移值性。

示例代码：

```java
class PriorityTest extends Thread {
    public PriorityTest(String name) {
        super(name);
    }
    
    public void run() {
        for (int i = 0; i < 50; ++i) {
            System.out.println(getName() + "，其优先级是：" + getPriority() + i);
        }
    }
    
    public static void main(String[] args) {
        // 改变主线程的优先级
        Thread.currentThread().setPriority(6);
        for (int i = 0; i < 30; ++i) {
            if (i == 10) {
                PriorityTest low = new PriorityTest("低级线程");
                low.start();
                System.out.println("创建之初的优先级：" + low.getPriority());
                // 设置该线程为最低优先级
                low.setPriority(Thread.MIN_PRIORITY);
            }
            if (i == 20) {
                PriorityTest high = new PriorityTest("高级线程");
                high.start();
                System.out.println("创建之初的优先级：" + high.getPriority());
                // 设置该线程为最高优先级
                high.setPriority(Thread.MAX_PRIORITY);
            }
        }
    }
}
```

假设某线程正在运行，则只有出现以下情况之一，才会使其暂停运行（清华郑莉）：

1. 一个具有更高优先级的线程变为就绪状态（Ready）；

2. 由于输入/输出（或其他一些原因）、调用sleep()、wait()、yield()方法使其发生阻塞；

3. 对于支持时间分片的系统，时间片的时间期满。

