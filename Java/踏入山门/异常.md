## 1. Java异常概述

### 1.1 Checked异常与Runtime异常

Java将异常分为两种，**Checked异常**和**Runtime异常**：

1. Checked异常：可以在编译阶段被处理的异常，Java强制程序处理所有的Checked异常，这也是Java领域一个备受争论的话题。
2. Runtime异常：所有的RuntimeException类及其子类的实例被称为Runtime异常，其他异常则是Checked异常。

只有Java语言提供了Checked异常，这体现了Java的设计哲学。

对于Checked异常的处理方式有两种：

1. 当前方法明确知道如何处理该异常，程序应该使用try…catch块来捕获该异常，然后在对应的catch块中修复该异常；

2. 当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常。

而Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。

### 1.2 Java异常类体系

Java常见异常类之间的继承关系：

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/40.jpg" alt="40" style="zoom:50%;" />

- Java把所有的非正常情况分成两种：**异常(Exception)** 和 **错误(Error)** ；
- Error错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。
- 所有Throwable的子类在构造器中都可以接收一个**cause对象**作为参数，这个cause就用来表示原始异常，这样可以把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

### 1.3 异常类的方法

所有的异常对象都包含了如下几个常用方法：

| 方法                            | 作用                                   |
| ------------------------------- | -------------------------------------- |
| getMessage()                    | 返回该异常的详细描述字符串             |
| printStackTrace()               | 将该异常的跟踪栈信息输出到标准错误输出 |
| printStackTrace(PrintStream  s) | 将该异常的跟踪栈信息输出到指定输出流   |
| getStackTrace()                 | 返回该异常的跟踪栈信息                 |

### 1.4 自定义异常类

用户自定义异常类都应该继承Exception基类，若希望自定义Runtime异常，则应该继承RuntimeException基类；

定义异常类时通常需要提供两个构造器：

1. 一个无参数的构造器；

2. 一个带一个字符串参数的构造器，这个字符串将作为该异常对象的描述信息（也就是异常对象的getMessage()方法的返回值）。

    ```java
    class AuctionException extends Exception {
        public AuctionException() {
        }
        
        public AuctionException(String msg) {
            super(msg);
        }
    }
    ```

## 2. try语句块

Java异常处理机制的语法结构：

```java
try {
    // ...
} catch (SubException1 e) {
    // ...
} catch (SubException2 e){
    // ...
}
// ...
finally{
    // ...
}
```

- try块与if/switch语句不一样，try块与catch块后的花括号{}永远不可省略；

- try块里声明的变量属于代码块局部变量，只在try块内有效，在catch块中也不能访问该变量；

- 对于finally块，不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return 语句，finally块也总会被执行；
    - 不过，如果在finally块执行前使用System.exit(1)退出了虚拟机，则finally块将失去执行的机会；
    - 通常情况下，不要在finally块中使用如return或throw等导致方法终止的语句，这将会导致try块、catch块中的return、throw语句失效。

- 一个catch块还可以捕获多种类型的异常，此时：

    - 多种异常类型之间用竖线（|）隔开；
    - 异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值。

    ```java
    class MultiExceptionTest {
        public static void main(String[] args) {
            try {
                int a = Integer.parseInt(args[0]);
                int b = Integer.parseInt(args[1]);
                int c = a / b;
            } catch (IndexOutOfBoundsException | NumberFormatException | ArithmeticException ie) {
                System.out.println("程序发生了数组越界、数字格式异常、算法异常之一");
                // 捕获多异常时，异常变量默认有final修饰，故下行错误
                ie = new ArithmeticException("test");
            } catch (Exception e) {
                System.out.println("未知异常");
                // 捕获一种类型的异常时，异常变量没有final修饰，故下行正确
                e = new RuntimeException("test");
            }
        }
    }
    ```

---

当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含了finally块。

1. 如果没有finally块，程序立即执行return或throw语句，方法终止；

2. 如果有finally块，系统立即开始执行finally块，当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，此时如果finally块本身也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会再跳回去执行try、catch块里的任何代码。

---

进行异常捕获时，应遵循这样的规则：把Exception类对应的catch块放在最后，而且所有父类异常的catch块都应该排在子类异常catch块的后面，否则将出现编译错误。

## 3. 关闭物理资源

有时程序在try块里打开了一些物理资源，如数据库连接、网络连接、磁盘文件等，这些物理资源都必须显式回收，通常在finally块中进行回收。

try关键字后可紧一对**圆括号**，圆括号可以声明、初始化一个或多个物理资源，try语句在该语句结束时自动关闭这些资源。此时要求这些资源实现类必须实现AutoCloseable或Closeable接口，实现这两个接口就必须实现close()方法。

```java
class AutoCloseTest {
    public static void main(String[] args) throws IOException {
        try (
            // 声明、初始化两个可关闭的资源
            // try语句会自动关闭这两个资源
            BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
            PrintStream ps = new PrintStream(new FileOutputStream("a.txt"))) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println("庄生晓梦迷蝴蝶");
        }
    }
}
```

Java9再次增强了这种try语句，Java9不要求在try后的圆括号内声明并创建资源，只需要自动关闭的资源有final修饰或者是effectively final，Java9允许将资源变量放在try后的圆括号内。

```java
class AutoCloseTest2 {
    public static void main(String[] args) throws IOException {
        // 有final修饰的资源
        final BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
        // 没有显式使用final修饰，但只要不对该变量重新赋值，该变量就是effectively final的
        PrintStream ps = new PrintStream(new FileOutputStream("a.txt"));
        // 只要将两个资源放在try后的圆括号内即可
        try (br; ps) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println("庄生晓梦迷蝴蝶");
        }
    }
}
```

## 4. throws/throw

thorws关键字在方法签名中使用，用于声明该方法可能抛出的异常；throw关键字用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。

### 4.1 使用throws抛出异常

```java
throws ExceptionClass1, ExceptionClass2…
```

throws意味着当前方法不知道如何处理这种类型的异常，将该异常交由上一级调用者处理；

当main方法使用了throws声明抛出异常时，该异常将交由JVM处理。JVM对异常的处理方法是：打印异常的跟踪栈信息，并中止程序运行。

```java
class ThrowsTest {
    // main方法声明不处理IOException异常，将该异常交由JVM处理
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("a.txt");
    }
}
```

但是，如果某段代码中调用了一个带throws声明的方法，该方法声明抛出了Checked异常，则表明该方法希望它的调用者来处理该异常。即，调用该方法时要么放在try块中显式捕获该异常，要么放在另一个带throws声明抛出的方法中。

```java
class ThrowsTest {
    public static void main(String[] args) throws Exception {
        // 因为test()方法声明抛出IOException异常
        // 所以调用test()方法的代码要么处于try...catch块中，
        // 要么处于另一个带throws声明抛出的方法中
        test();
    }
    public static void test() throws IOException {
        // 因为FileInputStream的构造器声明抛出IOException异常
        // 所以调用FileInputStream的代码要么处于try...catch块中，
        // 要么处于另一个带throws声明抛出的代码中
        FileInputStream fis = new FileInputStream("a.txt");
    }
}
```

**方法重写时使用throws声明抛出异常有一个限制**：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。

```java
class OverrideThrows {
    public void test() throws IOException {
        FileInputStream fis = new FileInputStream("a.txt");
    }
}
class Sub extends OverrideThrows {
    // 下面方法出错
    public void test() throws Exception {
    }
}
```

### 4.2 使用throw抛出异常

```java
throw exceptionInstance;
```

throw语句可在程序中主动抛出异常，throw语句抛出的不是异常类，而是一个异常实例，且每次只能抛出一个异常实例；

catch和throw结合使用的情况在大型企业级应用中非常常用，企业级应用对异常的处理通常分成两个部分：①应用后台需要通过日志来记录异常发生的详细情况；②应用还需要根据异常向应用使用者传达某种提示。故而，所有异常都需要这两个方法共同完成。

## 5. 异常链

真实的企业级应用，常常有严格的分层关系，上层功能的实现严格依赖于下层的API，也不会跨层访问。

<img src="https://chua-n.gitee.io/blog-images/notebooks/Java/41.jpg" alt="41" style="zoom:67%;" />

> 对一个上图所示结构的应用，当业务逻辑层访问持久层出现SQLException异常时，程序不应该把底层的SQLException异常传到用户界面：
>
> 1. 对于正常用户而言，他们不想看到底层SQLException异常，SQLException异常对他们使用该系统没有任何帮助；
> 2. 对于恶意用户而言，将SQLException异常暴露出来不安全。

把底层的原始异常直接传给用户是一种不负责任的表现，通常的做法是：程序先捕获原始异常，然后抛出一个新的业务异常，新的业务异常中包含了对用户的提示信息，这种处理方式被称为**异常转译**。

异常转译可以保证底层异常不会扩散到表现层，避免向上暴露太多的实现细节。这种捕获一个异常然后抛出另一个异常，并把原始异常信息保存下来是一种典型的链式处理（23种设计模式之一：职责链模式），也被称为**异常链**。

所有Throwable的子类在构造器中都可以接收一个cause对象作为参数，这个cause就用来表示原始异常，这样可以把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

## 6. 异常处理规则

不要过度使用异常，过度使用异常主要有两个方面：

1. 把异常和普通错误混淆在一起，不再编写任何错误处理代码，而是以简单地抛出异常来代替所有的错误处理；

2. 使用异常处理来代替流程控制。

异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分享，因此绝不要使用异常处理来代替正常的业务逻辑判断。

不要使用过于庞大的try块。

避免使用CatchAll语句，即不要处理程序发生的所有可能异常：`catch (Throwable t){}`

不要忽略捕获到的异常。

