## 1. 什么是 Linux

Linux 可划分为以下四部分：

![1](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/1.png)

-   Linux 内核
-   GNU 工具
-   图形化桌面环境
-   应用软件

通常来讲，**计算机硬件**是由运算器、控制器、存储器、I/O 设备等共同组成的，而让各种硬件设备各司其职又能协同运行的东西就是**系统内核**。LINUX 系统的内核负责完成对硬件资源的分配、调度等管理任务。

<img src="https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/2.png" style="zoom:67%;" />

**内核**主要负责以下 4 种功能：

-   系统内存管理：内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间(swap space)；

-   软件程序管理：LINUX 操作系统将运行中的程序称为进程；

-   硬件设备管理：

    -   驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据；
    -   LINUX 系统将硬件设备当成特殊的文件，称为设备文件，设备文件有 3 种分类：字符型设备文件、块设备文件、网络设备文件；
    -   LINUX 为系统上的每个设备都创建一种称为节点的特殊文件；

-   文件系统管理：

    -   LINUX 服务器所访问的所有硬盘都必须格式化成表 1-1 所列文件系统类型中的一种；

        ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/3.png)

    -   LINUX 内核采用虚拟文件系统(Virtual File System, VFS)作为和每个文件系统交互的接口，这为 LINUX 内核同任何类型文件系统通信提供了一个标准接口。

**GNU**组织(GNU 是 GNU's Not Unix 的缩写)开发了一套完整的 UNIX 工具，但没有可以运行它们的内核系统，这些工具是在名为开源软件(open source software, OSS)的软件理念下开发的，将 Linus 的 Linux 内核和 GNU 操作系统工具整合起来，就产生了一款完整的、功能丰富的免费操作系统。因为，尽管通常将 LINUX 内核和 GNU 工具的结合体称为 LINUX，但在互联网上也常有一些 LINUX 纯粹主义者将其称为 GNU/Linux 系统，藉此向 GNU 组织所作的贡献致意。

GNU 工具主要由两部分组成：核心 GNU 工具、SHELL

-   核心 GNU 工具(coreutils, core utilities)软件包由三部分组成：
    -   用以处理文件的工具
    -   用以操作文本的工具
    -   用以管理进程的工具
-   SHELL：也称为**终端**或**壳**，其充当的是人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端，它就会调用相应的程序服务去完成某些工作

LINUX**桌面环境**：“完成工具的方式不止一种，Linux 一直以来都以此而闻名。”

1. X Window 系统

2. KDE 桌面

3. GNOME 桌面：GNOME(the GNU Network Object Model Environment, GNU 网络对象模型环境)，现已成为许多 LINUX 发行版默认的桌面环境

    ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/4.png)

4. Unity 桌面：其宗旨是为工作站、平板电脑以及移动设备提供一致的桌面体验，Ubuntu 即为 Unity 桌面

    ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/5.png)

Linux 发行版：我们将完整的 LINUX 系统包称为发行版。不同的 LINUX 发行版通常归为 3 种：

-   核心 LINUX 发行版：提供了一站式的完整 LINUX 安装

    | 版本      | 特点                                                 |
    | --------- | ---------------------------------------------------- |
    | Slackware | 最早的 LINUX 发行版中的一员，在 LINUX 极客中比较流行 |
    | Red Hat   | 主要用于 Internet 服务器的商业发行版                 |
    | Fedora    | 从 Red Hat 分离出的家用发行版                        |
    | Gentoo    | 为高级 linux 用户设计的发行版，仅包含 linux 源代码   |
    | openSUSE  | 用于商用和家用的发行版                               |
    | Debian    | 在 linux 专家和商用 linux 产品中流行的发行版         |

-   特定用途的发行版：通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序

    | 版本        | 特点                                             |
    | ----------- | ------------------------------------------------ |
    | CentOS      | 基于 Red Hat 企业版 linux 源代码构建的免费发行版 |
    | Ubuntu      | 用于学校和家庭的免费发行版                       |
    | PCLinuxOS   | 用于家庭和办公的免费发行版                       |
    | Mint        | 用于家庭娱乐的免费发行版                         |
    | dyne:bolic  | 用于音频和 MIDI 应用的免费发行版                 |
    | Puppy Linux | 用于老旧 PC 的小型免费发行版                     |

-   LiveCD 测试发行版：......

## 2. Linux 存储结构

Linux 将文件存储在单个目录结构中，这个目录被称为**虚拟目录**(virtual directory)，其将安装在计算机上的所有存储设备的文件路径纳入单个目录结构中。

**绝对路径**指从根目录（/）开始写起的文件或目录名称，**相对路径**则指的是相对于当前路径的写法。

Linux 中有两个特殊字符可用于相对路径：

1. 单点符(.)：表示当前目录

2. 双点符(..)：表示当前目录的父目录

LINUX 系统中的一切文件都是从根(/)目录开始的，并按照文件系统层次化标准（FHS）采用**树形结构**来存放文件，并定义了常见目录的用途：

![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/6.png)

本质上，FHS 对于用户来讲只是一种**道德上的约束**，有些用户就是懒得遵守，总会把文件到处乱放，有些甚至从来没有听说过它。所以，大家在日常工作学习中要灵活运用所学的知识，不要只讲死道理。

关于**文件**——

1. LINUX 系统中的文件和目录名称是**严格区分大小写**的，并且文件名称中不得包含斜杠（/）；

2. LINUX 系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件；

3. LINUX 系统中“一切都是文件”，对服务程序进行配置自然也就是编辑程序的配置文件。

LINUX 系统中常见的目录名称及其相应内容：

|  目录名称   |        含义        | 应放置文件的内容                                       |
| :---------: | :----------------: | ------------------------------------------------------ |
|      /      |  虚拟目录的根目录  | 通常不会在这里存储文件                                 |
|    /boot    |      启动目录      | 开机所需文件——内核、开机菜单以及所需配置文件等         |
|    /bin     |     二进制目录     | 存放单用户模式下还可以操作的命令                       |
|    /dev     |      设备目录      | LINUX 在这里创建设备节点，以文件形式存放任何设备与接口 |
|    /etc     |    系统配置目录    | 存放系统配置文件的目录                                 |
|    /home    | 用户家目录/主目录  | linux 在这里创建用户目录                               |
|    /lib     |       库目录       | 存放系统和应用程序的库文件                             |
|   /media    |      媒体目录      | 可移动媒体设备的常用挂载点                             |
|    /mnt     |      挂载目录      | 另一个可移动媒体设备的常用挂载点                       |
|    /opt     |      可选目录      | 常用于存放第三方软件包和数据文件                       |
|    /proc    |      进程目录      | 存放现有硬件及当前进程的相关信息等                     |
|    /root    | 系统管理员的家目录 | 顾名思义                                               |
|    /sbin    |   系统二进制目录   | 存放许多 GNU 管理员级工具，如开机过程中需要的命令      |
|    /run     |      运行目录      | 存放系统动作时的运行时数据                             |
|    /srv     |      服务目录      | 存放一些网络服务的数据文件                             |
|    /sys     |      系统目录      | 存放系统硬件信息的相关文件                             |
|    /tmp     |      临时目录      | 存放任何人均可使用的临时工作文件                       |
|    /usr     |   用户二进制目录   | 存放大量用户级的 GNU 工具和数据文件                    |
|    /var     |      可变目录      | 用以存放经常变化的文件，如日志                         |
| /usr/local  |                    | 用户自行安装的软件                                     |
|  /usr/sbin  |                    | LINUX 系统开机时不会使用到的软件/命令/命令             |
| /usr/share  |                    | 帮助与说明文件，也可放置共享文件                       |
| /lost+found |                    | 当文件系统发生错误时，将一些丢失的文件片段存放在这里   |

## 3. CLI

在图形化桌面出现之前，与 unix 系统进行交互的唯一方式就是借助由 shell 所提供的文本**命令行界面**(command line interface, **CLI**)，CLI 只能接受文本输入，也只能显示出文本和基本的图形输出。

进入 CLI 主要有两种方式：

1. 控制台终端：让 LINUX 系统退出图形化桌面模式，进入文本模式，这样在显示器上就只有一个简单的 shell CLI，跟图形化桌面出现以前一样，这种模式称作 Linux 控制台。在 LINUX 控制台中无法运行任何图形化程序。

    ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/7.png)

2. 图形化终端：LINUX 图形化桌面环境中的终端仿真包，其会在一个桌面图形化窗口中模拟控制台终端的使用，我们平常所指的命令行界面实际上就是这个。

    ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/8.png)

图形化终端的仿真 CLI 有大量可用的仿真器，每个软件包都有各自独特的特性及选项，但主要的有三种：GNOME Terminal, Konsole Terminal, xterm.

GNOME Terminal 是 GNOME 桌面环境的默认终端仿真器中，很多发行版如 RHEL, Fedora 和 CentOS 默认采用的都是 GNOME 桌面环境，但一些其他桌面环境如 Ubuntu Unity，也采用了 GNOME Terminal 作为默认的终端仿真软件包，它使用起来非常简单，是 LINUX 新手的不错选择。

## 4. shell

### 4.1 走进 shell

所有主流 Linux 发行版默认使用的 shell 都是 Bash(Bourne-Again Shell)解释器。

如果不记得 shell 的命令名，可用关键字搜索手册页，语法是 man -k keyword，如，要查找与终端相关的命令，可以输入 man -k terminal.

常见 shell 命令的格式为`命令名称 <命令参数> <命令对象>`：

-   命令对象一般是指要处理的文件、目录、用户等资源；

-   命令参数可以用**长格式**（完整的选项名称），也可以用**短格式**（单个字母的缩写），两者分别用--与-作为前缀。

    ```bash
    # 示例
    man --help # 长格式
    man -h # 短格式
    ```

长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个-即可。另外，ps 命令可允许参数不加减号(-)，因此可直接写成 ps aux 的样子。

shell 不会就相同的功能采用不同大小写的参数，只有极少的例外，如 rm -r dir 与 rm -R dir 功能相同。

shell 命令输出条目的**字段**之间用冒号分隔，如`christine:x:501:501:Christine Bresnahan:/home/christine:/bin/bash`。

SHELL 中的**转义字符**为反斜杠（\）——使反斜杠后面的一个变量变为单纯的字符串。

管道命令符，用来把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入，即将两个或多个命令像管道一样连接起来，省去写很多行的命令的形式。其格式为`命令A|命令B`。

在 shell 中有关文件名的输入时，往往可以使用**模糊的文件名**，这实则是一个文件名过滤器，这种情况输入的名字可能会匹配多个文件/目录。

| 符号  | 含义                    |
| ----- | ----------------------- |
| ?     | 可使用?代表一个字符     |
| \*    | 代表零或多个字符        |
| [ai]  | 代表多选，[ai]即 a 或 i |
| [a-i] | 字母范围 a-i            |
| [!a]  | 不允许有 a              |

### 4.2 理解 shell

shell 的**父子结构**:

1. 在一个 shell 的 CLI 提示符后输入/bin/bash 命令或其他等效的 bash 命令时，会创建一个新的 shell 程序，这个 shell 程序被称为子 shell(child shell)，原来的 shell 则称为父 shell. 可通过 ps -f 命令可查看创建子 shell 前后的进程变化。子 shell 可以嵌套，可以利用 exit 命令一层一层地退出 shell.

2. 在生成子 shell 进程时，只有部分父进程的环境被复制到子 shell 环境中，这会对包括变量在内的一些东西造成影响。

3. 在 shell 脚本中，经常使用子 shell 进行多进程处理，但是采用子 shell 的成本不菲，会明显拖慢处理速度，在交互式的 CLI shell 会话中，子 shell 同样存在问题。这并非真正的多进程处理，因为终端控制着子 shell 的 I/O.

shell 命令可以组成**命令列表**，只需要在命令之间加入分号(;)即可，这些命令会依次执行：

<img src="https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/9.png" style="zoom:67%;" />

将命令列表的形式用圆括号括住，则构成了**进程列表**。进程列表的不同之处在于它会生成一个子 shell 来执行对应的命令：

<img src="https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/10.png" style="zoom:67%;" />

`echo $BASH_SUBSHELL`可返回子 shell 的数量，为 0 意味着没有创建子 shell.

在交互式 shell 中，一个高效的子 shell 用法是使用**后台模式**，在后台模式中可以在处理命令的同时让出 CLI，以供他用，在命令后加上`&`即可让命令切换到后台执行。另外与后台模式相关的经典命令是`sleep`命令。

shell 内建命令与外部命令：

1. **内建命令**是解释器内部的指令，它们已经和 shell 编译成了一体，作为 shell 工具的组成部分存在，不需要借助外部程序文件而被直接执行；内建命令不会创建子进程，因而其执行速度更快。

2. **外部命令**也称为文件系统命令，它们并不是 shell 程序的一部分，外部命令将在 PATH 中寻找其位置然后执行；外部命令执行时，会创建一个子进程，被称为衍生(forking)。

3. cd 和 exit 命令都内建于 bash shell，而 ps 命令是一个外部命令。可以这么理解：有些命令不是 shell 必须的，却在日常中经常使用，故而在 Linux 发行版中配套了相关的外部命令可以直接使用。

4. 注意，有些命令其实有多种实现，如 echo 和 pwd 既有内建命令也有外部命令，要查看命令的不同实现，使用 type 命令的-a 选项。对于有多种实现的命令，若想要使用其外部实现，通过直接指明其对应的文件就可以了，如/bin/pwd.

| shell 命令 | 作用                             | 示例                                                              | 示例说明                                                                                                                                |
| ---------- | -------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| type       | 判断某命令是内建命令还是外部命令 | type command                                                      |                                                                                                                                         |
| which      | 返回命令的目录位置               | which command                                                     |                                                                                                                                         |
| exit       | 退出当前 shell                   | exit                                                              |                                                                                                                                         |
| sleep      | 开启休眠模式                     | sleep second<&>                                                   | 1) 让进程睡眠 second 秒，过后才回到 CLI 提示符；<br />2) 若末尾加上&，则开启了后台模式                                                  |
| history    | 显示历史执行过的命令             | history <-c> 历史命令会被保存到用户家目录中的.bash_history 文件中 | 1) history 命令默认显示当前用户执行过的最近 1000 条命令记录；<br />2) 自定义/etc/profile 文件中的 HISTSIZE 环境变量值可改变记录的条数。 |
| alias      | 给某命令创建一个别名             | alias another_name=command                                        | 1) 可使用 alias -p 查看当前可用的别名；<br />2) 别名仅在它被定义的 shell 进程中有效。                                                   |
| unalias    | 取消一个别名                     | unalias another_name                                              |                                                                                                                                         |

## 5. 环境变量

在 Linux 的 bash shell 中可定义一些**变量**，它们存储着有关 shell 会话和工作环境的信息，因而 Linux 的变量也叫做**环境变量**。

1. 变量由固定的**变量名**与用户/系统设置的**变量值**两部分组成，我们完全可以自行创建变量，来满足工作需求。一个相同的变量会因为用户身份的不同而具有不同的值。

2. Linux 的**系统环境变量**名称一般是**全大写**的，这是一种约定俗成的规范，以区别普通用户的**自定义变量**。

3. Linux 中最重要的 10 个系统环境变量为：

    | 变量名称     | 作用                                   |
    | ------------ | -------------------------------------- |
    | HOME         | 用户的主目录（即家目录）               |
    | SHELL        | 用户在使用的 Shell 解释器名称          |
    | PATH         | shell 查找外部命令路径列表，由冒号分隔 |
    | HISTSIZE     | 输出的历史命令记录条数                 |
    | HISTFILESIZE | 保存的历史命令记录条数                 |
    | MAIL         | 邮件保存路径                           |
    | LANG         | 系统语言、语系名称                     |
    | RANDOM       | 生成一个随机数字                       |
    | PSL          | Bash 解释器的提示符                    |
    | EDITOR       | 用户默认的文本编辑器                   |

在 bash shell 中，环境变量分为两类：

1. **全局变量**：对 shell 会话和所有生成的子 shell 都可见；

2. **局部变量**：只对创建它们的 shell 可见，亦即只能在定义它们的进程中可见。

变量赋值：

1. 给变量赋值的形式是"variable=value"，注意等号两边不能有空格，变量值可能是数值或字符串，若字符串内需要含有空格，则将字符串放入引号之内。

2. 创建全局变量的方法是先创建一个局部变量，则通过 export 将它导出到全局环境中。

3. 修改/删除子 shell 中全局变量并不会影响到父 shell 中该变量的值；子 shell 甚至无法使用 export 命令改变父 shell 中全局变量的值。**（真别扭？？？！！！）**

数组变量：要给某个变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。

1. 对于数组变量，`echo $variable`只能显示其第一个值；要引用其他数组元素，使用`echo ${variable[index]}`，数组变量的索引从 0 开始。

2. 要显示整个数组变量，可使用通配符: `echo ${variable[*]}`.

3. 可使用索引直接改变某个元素的值: `variable[index]=new_value`.

4. 删除某个数组元素时使用 `unset (unset variable[index])`，但其实该索引位置只是置为空了，原来的每个元素的索引是没有变的：

    ```bash
    $ unset mytest[2]
    $
    $ echo ${mytest[*]}
    one two four five
    $ echo ${mytest[2]}
    $ echo ${mytest[3]}
    four
    ```

5. `unset variable`可删除整个数组.

PATH 环境变量：

1. 作为一名态度谨慎、有经验的运维人员，在接手了一台 Linux 系统后一定会在执行命令前先检查 PATH 变量中是否有可疑的目录。

2. 如果命令或程序的位置没有包括在 PATH 变量中，只有使用绝对路径才能在 shell 中调用。

3. 要将某目录添加到现有 PATH 变量中，只需使用 echo 引用原来的 PATH 值，然后添加新目录即可；很多程序员习惯将单点符（即当前目录）添加到 PATH 中；但注意这种修改在退出或重启系统之后会失效。

    ![](https://chua-n.gitee.io/blog-images/notebooks/杂技/Linux/11.png)

4. 永远修改环境变量最好的办法是在/etc/profile.d 目录中创建一个以.sh 结尾的文件，把所有新的或修改过的全局环境变量设置放在这个文件中。

bash 命令：

-   `env`：查看所有全局系统变量。`env`

-   `printenv`：查看所有/某全局系统变量。`printenv <globle_variable>`

-   `echo`

    -   `echo $<variable>`：引用某变量的值；若该变量不存在，则创建一个空值的变量。

    -   `echo str`：引用字符串的值

    -   `echo <command>`：显示命令执行结果

        ```bash
        $ echo `date`
        Thu Jul 24 10:08:46 CST 2014
        ```

-   `set`：显示某进程的所有变量，返回结果按字母顺序排序。`set`

-   `unset`：删除某变量。`unset variable`

-   `export`：将变量提升为全局变量。`export variable`

## 6. 输入输出重定向

**输入重定向**是指把文件导入到命令中，**输出重定向**则是指把原本要输出到屏幕的数据信息写入到指定文件中。输出重定向又分为标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式。

1. 标准输入重定向（STDIN，文件描述符为 0）——默认从键盘输入，也可从其他文件或命令中输入；

2. 标准输出重定向（STDOUT，文件描述符为 1）——默认输出到屏幕；

3. 错误输出重定向（STDERR，文件描述符为 2）——默认输出到屏幕。

输入重定向中用到的符号及其作用：

| 符号                     | 作用                                            |
| ------------------------ | ----------------------------------------------- |
| `命令 < 文件`            | 将文件作为命令的标准输入                        |
| `命令 << 分界符`         | 从标准输入中读入，直到遇见分界符停止            |
| `命令 < 文件 1 > 文件 2` | 将文件 1 作为命令的标准输入并将标准输出到文件 2 |

输出重定向中用到的符号及其作用：

| 符号                                 | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `命令 > 文件`                        | 将标准输出重定向到一个文件中（清空原有文件的数据）           |
| `命令 2> 文件`                       | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
| `命令 >> 文件`                       | 将标准输出重定向到一个文件中（追加到原有内容的后面）         |
| `命令 2 >> 文件`                     | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |
| `命令 >> 文件 2>&1 或 命令 &>> 文件` | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |

## 7. 其他常用命令

-   `man`：查看某命令存储在 Linux 系统上的手册页面

    | 按键      | 用途                             |
    | --------- | -------------------------------- |
    | 空格键    | 向下翻一页                       |
    | 回车键    | 逐行查看                         |
    | Page Down | 向下翻一页                       |
    | Page Up   | 向上翻一页                       |
    | home      | 直接前往首页                     |
    | end       | 直接前往尾页                     |
    | /         | 从上至下搜索某个关键词，如/linux |
    | ?         | 从下至上搜索某个关键词，如?linux |
    | n         | 定位到下一个搜索到的关键词       |
    | N         | 定位到上一个搜索到的关键词       |
    | q         | 退出帮助文档                     |

-   `clear`：清除屏幕里的所有命令

-   `reboot`：重启系统，默认只能使用 root 管理员来重启

-   `poweroff`：关闭系统，默认只有 root 管理员可关闭

-   `date`：显示及设置系统时间/日期，`date <option> <+指定的格式>`

    | 命令                         | 输出                         |
    | ---------------------------- | ---------------------------- |
    | $ date                       | Mon Aug 24 16:11:23 CST 2017 |
    | $ date "+%Y-%m-%d %H:%M:%S"  | 2019-09-12 11:34:27          |
    | $ date -s "20170901 8:30:00" | 将当前系统时间设置为此       |

    | 参数 | 作用           |
    | ---- | -------------- |
    | %t   | 跳格【Tab 键】 |
    | %H   | 小时（00~23）  |
    | %I   | 小时（00~12）  |
    | %M   | 分钟（00~59）  |
    | %S   | 秒（00~59)     |
    | %j   | 今年中的第几天 |

-   `last`：查看系统所有的登录记录，`last <option>`

    > 由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很轻易地对内容进行篡改，千成不要单纯地以该命令的输出信息来判断系统有无被恶意入侵。

-   `who`：查看当前登入主机的用户终端信息，`who <option>`

-   `uname`：查看系统内核与系统版本等信息，`uname <-a>`

-   `ifconfig`：获取网卡配置与网络状态等信息，`ifconfig <网络设备> <option>`

-   `ping`：测试网络的连通性

-   `wget`：下载网络文件，`wget <option> 下载地址`

    | option | function                             |
    | ------ | ------------------------------------ |
    | -b     | 后台下载模式                         |
    | -P     | 下载到指定目录                       |
    | -t     | 最大尝试次数                         |
    | -c     | 断点续传                             |
    | -p     | 下载页面内所有资源，包括图片、视频等 |
    | -r     | 递归下载                             |

-   `sosreport`：收集系统配置及架构信息，并输出诊断文档

