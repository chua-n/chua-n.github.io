## 前言：Annotation or XML？

No matter the choice, annotations or XML, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its [JavaConfig](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) option, Spring lets annotations be used in a non-invasive way, without touching the target components source code.

Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.

Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。

## 常用注解速览

Spring“原始注解”与“新注解”主要是一种逻辑上的区分。

### 原始注解

使用原始注解进行开发时，需要在applicationContext.xml中配置组件扫描，其作用是指定哪个包（及其子包）下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。

```xml
<!--配置组件扫描-->
<context:component-scan base-package="com.itheima"></context:component-scan>
```

| 原始注解         | 解释                                                      |
| ---------------- | --------------------------------------------------------- |
| `@Component`     | 使用在类上，用于实例化Bean                                |
| `@Controller`    | @Component的衍生注解：使用在Web层上，用于实例化Bean       |
| `@Service`       | @Component的衍生注解：使用在service层类上，用于实例化Bean |
| `@Repository`    | @Component的衍生注解：使用在dao层类上，用于实例化Bean     |
| `@Autowired`     | 通常使用在字段上，用于根据Bean的类型进行依赖注入          |
| `@Qualifier`     | 结合@Autowired一起使用用于同时根据类型和名称进行依赖注入  |
| `@Resource`      | 相当于@Autowired+@Qualifier，按照名称进行注入             |
| `@Value`         | 注入普通属性                                              |
| `@Scope`         | 标注Bean的作用范围                                        |
| `@PostConstruct` | 使用在方法上，标注该方法是Bean的初始化方法                |
| `@PreDestroy`    | 使用在方法上，标注该方法是Bean的销毁方法                  |

### 新注解

使用原始注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：

- 非自定义的Bean的配置：`<bean>`
- 加载properties文件的配置：`<context:property-placeholder>`
- 组件扫描的配置：`<context:component-scan>`
- 引入其他文件：`<import>`

| 新注解            | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `@Configuration`  | 用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解 |
| `@ComponentScan`  | 用于指定Spring在初始化容器时要扫描的包，作用和在Spring的xml配置文件中的<context:component-scan  base-package="com.itheima"/>一样 |
| `@Bean`           | 使用在方法上，表示将该方法的返回值存储到Spring容器中，并可赋予指定名称 |
| `@PropertySource` | 用于加载properties文件中的配置                               |
| `@Import`         | 用于导入其他配置类                                           |

## post-processors

As always, you can register the post-processors as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the `context` namespace):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

The `<context:annotation-config/>` element implicitly registers the following post-processors:

- `ConfigurationClassPostProcessor`
- `AutowiredAnnotationBeanPostProcessor`
- `CommonAnnotationBeanPostProcessor`
- `PersistenceAnnotationBeanPostProcessor`
- `EventListenerMethodProcessor`

`<context:annotation-config/>` only looks for annotations on beans in the same application context in which it is defined. 

- This means that, if you put `<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`, it only checks for `@Autowired` beans in your controllers, and not your services. 
- See [The DispatcherServlet](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) for more information.

## @Required

>  The `@Required` annotation and `RequiredAnnotationBeanPostProcessor` are formally deprecated as of Spring Framework 5.1.
>
> ```java
> /** @deprecated */
> @Deprecated
> @Retention(RetentionPolicy.RUNTIME)
> @Target({ElementType.METHOD})
> public @interface Required {
> }
> ```

The `@Required` annotation applies to bean property setter methods, as in the following example:

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

This annotation indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring.

## @Autowired

> 很多情况下，JSR 330提供的`@Inject`注解可以替换`@Autowired`的作用。

`@Autowired`根据类型注入Bean，对应类型的Bean需要是单例的。

```java
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}
```

注意，由`@Autowired`的定义可知，其作用范围为构造器、方法、形参、字段、注解，最常见的字段注入的方式只是其中之一而已。当然了，当用在方法上时，此注解肯定不可能用在静态方法上。

> 当在方法上使用`@Autowired`时，spring会在项目启动的过程中，自动调用一次加了`@Autowired`注解的方法，我们可以在该方法做一些初始化的工作（如此一来，与`@PostConstruct`的区别？）

### 多个Bean类型相同

如果对应的类型有多个，`@Autowired`会失败，此时有三种解决方式：

- 与 `@Qualifier`（合格者、修饰词）结合，在同类型的基础上通过名称再进行取舍；

- 在被注入的Bean上加入优先级，如指定某一个Bean为`@Primary`；

- 另外，实际上可以将注入的字段改为集合类型：

    > 当集合为Map时，其key必须为String类型，含义为Bean的名字；其value为对应的Bean实例。

    ```java
    @Service
    public class UserService {
    
        @Autowired
        private List<IUser> userList;
    
        @Autowired
        private Set<IUser> userSet;
    
        @Autowired
        private Map<String, IUser> userMap;
    
        public void test() {
            // userList:[User1@2513a118, User2@2bfb583b]
            System.out.println("userList:" + userList);
            // userSet:[User1@2513a118, User2@2bfb583b]
            System.out.println("userSet:" + userSet);
            // {user1=User1@2513a118, user2=User2@2bfb583b}
            System.out.println("userMap:" + userMap);
        }
    }
    ```

### 注入Bean集合

`@Autowired`注入的字段为集合类型时：

- 集合不能为空，其中必须至少能注入一个Bean，否则Spring将抛异常。
- 如果想控制集合中Bean出现的顺序，可以令相关的Bean实现`Ordered`接口，或通过`@Order`、`@Priority`注解来定义相对的顺序。
- 如果没有显式的顺序定义，其排列顺序将按照在IoC容器中注册的顺序。

### 关于required

如果`@Autowired`修饰的是方法且`@Autowired(required = false)`，当Spring发现存在某一个要注入的Bean不存在时，会导致该方法完全不会被执行。

Injected constructor and factory method arguments are a special case since the `required` attribute in `@Autowired` has a somewhat different meaning due to Spring’s constructor resolution algorithm that may potentially deal with multiple constructors. 

- Constructor and factory method arguments are effectively required by default but with a few special rules in a single-constructor scenario, such as multi-element injection points (arrays, collections, maps) resolving to empty instances if no matching beans are available. 
- This allows for a common implementation pattern where all dependencies can be declared in a unique multi-argument constructor — for example, declared as a single public constructor without an `@Autowired` annotation.

Only one constructor of any given bean class may declare `@Autowired` with the `required` attribute set to `true`, indicating *the* constructor to autowire when used as a Spring bean.

- If multiple constructors declare the annotation, they will all have to declare `required=false` in order to be considered as candidates for autowiring. 
    - The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen.
    - If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used.
- Similarly, if a class declares multiple constructors but none of them is annotated with `@Autowired`, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. 
- Note that an annotated constructor does not have to be public.

Alternatively, you can express the non-required nature of a particular dependency through Java 8’s `java.util.Optional`, as the following example shows:

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```

As of Spring Framework 5.0, you can also use a `@Nullable` annotation: 

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

### 注入Spring框架相关Bean

You can also use `@Autowired` for interfaces that are well-known resolvable dependencies: 

- `BeanFactory`
- `ApplicationContext`
- `Environment`
- `ResourceLoader`
- `ApplicationEventPublisher`
- `MessageSource`

These interfaces and their extended interfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are automatically resolved, with no special setup necessary.

The `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring `BeanPostProcessor` implementations. This means that you cannot apply these annotations within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any). These types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.

### self injection

> Note that self injection is a fallback.

自Spring 4.3开始，`@Autowired` 也支持了“自注入（self injection）”，即注入自己。

Regular dependencies on other components always have precedence. 

- In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary.
- On the contrary, they always end up as lowest precedence.

实践中，应该将自注入作为一种最后的不得已的手段（for example, for calling other methods on the same instance through the bean’s transactional proxy），通常更建议将需要用到自注入的方法提取到另外一个委托Bean里。

Alternatively, you can use `@Resource`, which may obtain a proxy back to the current bean by its unique name.

通过`@Bean`方法来实现自注入也是一种有效的方法。但是，建议要么在实际需要的地方在方法签名中惰性地解析这些引用（与`@Autowired`正好相反），要么将受影响的`@Bean`方法声明为静态的，从而将它们与母体及其生命周期解耦。否则，此类Bean只会在fallback phase被考虑，而优先考虑其他的符合条件的Bean。

### 隐式的qualfier

除了直接使用 `@Qualifier` 注解来修饰Bean外，Spring也支持借助Java的泛型信息来作为一种隐式的修饰语，从而区别不同的Bean。

例如，假设有如下的配置类：

```java
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}
```

假定上述的Bean都实现了一个泛型接口，即`Store<String>` 和 `Store<Integer>`，那么可以直接使用 `@Autowire` 来注入相应的泛型接口从而注入相应的Bean，即：

```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
```

该原则也适用于`List, Map, array`：

```java
// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
```

### 失效原因排查

对象未被注入的可能原因：

- 使用`@Autowired`的类不在IoC容器中（没有加`@Componet`, `@Controller`之类的注解）
- 包未被spring扫描
- `@Autowired`的`required = false`.
- 在listener和filter里面@Autowired某个bean：由于web应用启动的顺序是：`listener` -> `filter` -> `servlet`，而SpringMVC的启动是在`DisptachServlet`里面做的，执行在对应的bean还没有初始化，无法自动装配。此时可以通过其他途径来实现。
- 循环依赖问题（在单例情况下多数没问题）

## @Qualifier

```java
package org.springframework.beans.factory.annotation;

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Qualifier {
    String value() default "";
}
```

You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument.

In the simplest case, this can be a plain descriptive value, as shown in the following example:

```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}
```

You can also specify the `@Qualifier` annotation on individual constructor arguments or method parameters:

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

> For a fallback match, the bean name is considered a default qualifier value. Thus, you can define the bean with an `id` of `main` instead of the nested qualifier element, leading to the same matching result.
>
> 注意，尽管Bean的id是唯一的，但`@Qualfier`也始终只是在`@Autowired`圈定的范围内进行挑选。
>
> Good qualifier values are `main` or `EMEA` or `persistent`, expressing characteristics of a specific component that are independent from the bean `id`, which may be auto-generated in case of an anonymous bean definition.

`@Qualfier`的值不需要是唯一的，因此也可以据此来注入Bean集合。

当需要根据名称来注入Bean时，`@Qualfier`并不一定是必需的，因为默认情况下，当有多个候选项时（且没有其他限定条件，如优先级），Spring会根据字段或形参的名称来匹配同名的Bean。

另外，如果就是为了根据修饰性的名称来注入Bean，往往更推荐使用 JSR-250 提供的`@Resource` 注解，`@Resource`本意即是根据唯一的限定名称来注入Bean，不考虑Bean的类型。

### 自定义`@Qualifier` 

You can create your own custom qualifier annotations. To do so, define an annotation and provide the `@Qualifier` annotation within your definition, as the following example shows:

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {
    String value();
}
```

Then you can provide the custom qualifier on autowired fields and parameters, as the following example shows:

```java
public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
```

### CustomAutowireConfigurer

[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.3.20/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring’s `@Qualifier` annotation. The following example shows how to use `CustomAutowireConfigurer`:

```xml
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>
```

The `AutowireCandidateResolver` determines autowire candidates by:

- The `autowire-candidate` value of each bean definition
- Any `default-autowire-candidates` patterns available on the `<beans/>` element
- The presence of `@Qualifier` annotations and any custom annotations registered with the `CustomAutowireConfigurer`

When multiple beans qualify as autowire candidates, the determination of a “primary” is as follows: If exactly one bean definition among the candidates has a `primary` attribute set to `true`, it is selected.

## @Resource

> `@Resource` takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics

@Autowired是Spring提供的注解，@Resource是Java（JSR-250）提供的注解。

- @Autowired只包含一个参数：required，表示是否开启自动准入，默认是true；而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。
- @Resource只能用在类、成员变量和方法上。
- @Resource的搜索路径：
    - 未给定任何参数：首先根据名称匹配（即字段名或setter方法名），如果找不到再根据类型匹配
    - 仅指定了name：根据名称装配
    - 仅指定了type：根据类型装配
    - 同时指定了name和type：寻找名称和类型都匹配的Bean进行装配

```java
@Target({TYPE, FIELD, METHOD})
@Retention(RUNTIME)
public @interface Resource {

    String name() default "";

    String lookup() default "";

    Class<?> type() default java.lang.Object.class;

    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;

    boolean shareable() default true;

    String mappedName() default "";

    String description() default "";
    
    enum AuthenticationType {
            CONTAINER,
            APPLICATION
    }
}
```

## @Order, @Priority, @Primary

这三个注解总的来说都是用来做bean的排序。

- `@Order`是Spring提供的注解，里面存储了一个代表顺序的值，默认为`Integer.MAX_VALUE`，值越小优先级越高。

    - `@Order`只控制Bean的注入顺序，不影响单例Bean的启动顺序，后者是由依赖关系和`@DependsOn`声明决定的。
    - `@Order`能控制 List 等有序集合里面存放的Bean的顺序，因为Spring的`DefaultListableBeanFactory`类会在注入时调用`AnnotationAwareOrderComparator.sort(listA)`，该方法根据`@Order`或者`Ordered`接口返回的值排序。

    ```java
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
    @Documented
    public @interface Order {
        int value() default 2147483647;
    }
    ```

- `@Priority`是 JSR 250 标准，与`@Order`类似，同样接收一个表示顺序的值，值越小优先级越高。

    > `@Priority`优先级比`@Order`更高，两者共存时优先加载`@Priority`。

    ```java
    @Target({TYPE,PARAMETER})
    @Retention(RUNTIME)
    @Documented
    public @interface Priority {
        /**
         * The priority value.
         */
        int value();
    }
    ```

    > Note that the standard `@Priority` annotation is not available at the `@Bean` level, since it cannot be declared on methods. Its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean for each type.

- `@Primary`同样是表达顺序的注解，它是Spring提供的注解，其表达的优先级最高的，如果同时有`@Primary`以及其他几个的话，`@Primary`注解的Bean会优先注入。

    ```java
    @Target({ElementType.TYPE, ElementType.METHOD})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    public @interface Primary {
    }
    ```

## @Value

### 释义

`@Value` is typically used to inject externalized properties:

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}
```

With the following configuration:

```java
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }
```

And the following `application.properties` file:

```java
catalog.name=MovieCatalog
```

In that case, the `catalog` parameter and field will be equal to the `MovieCatalog` value.

Spring提供的内置转换器支持自动处理简单的类型转换(例如Integer或int)，同时多个逗号分隔的值可以自动转换为String数组，而无需处理。

### 设置默认值

@Value也可以设置默认值，如下：

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}
```

### 使用SpEL表达式

When `@Value` contains a [`SpEL` expression](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions) the value will be dynamically computed at runtime as the following example shows:

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}
```

### PropertySourcesPlaceholderConfigurer

Spring默认提供了一个规则宽容的属性值解析器，该解析器在解析属性值时，如果找不到对应的值，会将相应的属性名（例如上例的 `${catalog.name}`）作为值注入到对应的属性中。

如果想要对不存在的属性值设置一个更严格的规则，则应该声明一个`PropertySourcesPlaceholderConfigurer` 的Bean，如下：

> 使用`@Bean`方法来声明这个Bean时，必须是static方法。

```java
@Configuration
public class AppConfig {

    @Bean
    public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
        return new PropertySourcesPlaceholderConfigurer();
    }
}
```

上述`PropertySourcesPlaceholderConfigurer`在发现无法解析到属性值时，会直接报错。此外，其也可以使用 `setPlaceholderPrefix`, `setPlaceholderSuffix`, `setValueSeparator` 方法来定制placeholders。

>  Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that will get properties from `application.properties` and `application.yml` files.

### ConversionService

A Spring `BeanPostProcessor` uses a `ConversionService` behind the scenes to handle the process for converting the `String` value in `@Value` to the target type. 

If you want to provide conversion support for your own custom type, you can provide your own `ConversionService` bean instance as the following example shows:

```java
@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
```

## @PostConstruct, @PreDestroy

The `CommonAnnotationBeanPostProcessor` not only recognizes the `@Resource` annotation but also the JSR-250 lifecycle annotations: `javax.annotation.PostConstruct` and `javax.annotation.PreDestroy`.

> The entire `javax.annotation` package got separated from the core Java modules in JDK 9 and eventually removed in JDK 11. 
>
> If needed, the `javax.annotation-api` artifact needs to be obtained via Maven Central now, simply to be added to the application’s classpath like any other library.

```java
package javax.annotation;

@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PostConstruct {
}
```

```java
package javax.annotation;

@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PreDestroy {
}
```

## @DependsOn

此注解可以用来调整 Bean 的初始化顺序。比如如果一个BeanB依赖于BeanA的初始化，那么可以给BeanB加上注解`@DependsOn("beanA")`，让BeanA先于BeanB初始化。

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DependsOn {
    String[] value() default {};
}
```

