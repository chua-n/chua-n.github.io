## 1. 跨域问题

当客户端和服务端分开部署到不同服务器的时候，就会遇到跨域访问的问题，是由浏览器同源策略限制的一类请求场景。

| URL                                                         | 说明                           | 是否允许通信                           |
| ----------------------------------------------------------- | ------------------------------ | -------------------------------------- |
| http://www.a.com/a.js<br />http://www.a.com/b.js            | 同一域名下                     | 允许                                   |
| http://www.a.com/lab/a.js<br />http://www.a.com/script/b.js | 同一域名下不同文件夹           | 允许                                   |
| http://www.a.com:8000/a.js<br />http://www.a.com/b.js       | 同一域名，不同端口             | 不允许                                 |
| http://www.a.com/a.js<br />https://www.a.com/b.js           | 同一域名，不同协议             | 不允许                                 |
| http://www.a.com/a.js<br />http://70.32.92.74/b.js          | 域名和域名对应ip               | 不允许                                 |
| http://www.a.com/a.js<br />http://script.a.com/b.js         | 主域相同，子域不同             | 不允许                                 |
| http://www.a.com/a.js<br />http://a.com/b.js                | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |
| http://www.cnblogs.com/a.js<br />http://www.a.com/b.js      | 不同域名                       | 不允许                                 |

## 2. HTTP反向代理

> 参考[肖国栋的i自留地](https://juejin.cn/post/6958987684383555592)。

要理解什么是 **反向代理(reverse proxy)** ，自然你得先知道什么是 **正向代理(forward proxy)** 。

> 另外需要说的是， 一般提到反向代理， 通常是指 HTTP 反向代理， 但反向代理的范围可以更大， 比如 tcp 反向代理，本文不讨论HTTP反向代理之外的东西。

### 所谓正向代理

正向代理通常直接称为**代理(proxy)** ，无需强调它是正向的，在 HTTP 协议中，代理即指正向代理。

而要谈论什么是正向代理，则需要先讨论"直接访问"的形式，即没有任何代理的模式。事实上， 直接访问对于很多的小网站来说是最常见的方式，直接访问类似于"厂家直销"—— 你直接向生产厂家下单， 没有经过任何的中间商。从系统的角度看， "直接访问"就是浏览器的请求直接到了最终生成网页的服务器， 中间没有经过任何的 HTTP 代理服务器。

对于浏览器的请求处理来说，一个（正向）代理，更确切的说一台代理服务器，其并没有直接响应请求的能力，它不过是把请求转发到最终的网页服务器上，再把后者的响应再转发回请求者，也就是浏览器。 如下图所示:

![forward proxy demo](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/3.png)

但这里还有个问题——浏览器怎么知道代理服务器在哪？最终的服务器浏览器是知道的，比如对于域名 "baidu.com"，通过 DNS 浏览器能查到对应的 ip 地址，但浏览器怎么知道哪里有代理服务器，以及请求是否要经过代理服务器呢？

答案是必须主动告诉浏览器，这个过程通常称为“配置代理服务器”，如在 IE 浏览器上配置代理服务器的操作如下：

<img src="https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/4.png" style="zoom:67%;" />

### 为什么有代理存在?

一是出于安全审计及控制方面的一些考虑。在一些组织内，web 相关的端口如 80 及 443 是被封禁的，在组织内上不了网，如果这时有上网的需求，就只能使用组织指定的内网的代理服务器了。

> 当然了，代理服务器本身则没有被限制，它是可以访问外部的网络的。

如此一来， 你的所有上网请求都要经过代理服务器， 而这个代理是由组织控制的， 就可以对请求进行审计了:

- 比如发现你往外面的一个网站上传组织内部的保密资料， 就出手阻止你;
- 又或发现你访问了一个不安全的网站， 可能会导致你的电脑中毒， 于是出手拦截了;
- 又或者是发现你在访问与工作无关的娱乐网站， 于是就给你阻断了~~。

二是有时出于加速或节省带宽等的考虑，因为有的代理服务器它不仅能转发，还能对网页以及其它一些资源进行缓存。举个例子，假如现在很多同学都要去上 qq.com 的主页，那么第一个同学请求时，代理服务器就可以把主页缓存起来一段时间，碰到后面还要同学想访问这个主页，就无需再去请求了，代理服务器直接返回缓存的请求。

> 自然，缓存也会有一个失效期，不会一直缓存下去，否则内容就得不到更新了。至于多长时间更新缓存，怎么更新等这些就属于具体的缓存策略问题了。

值得一提的是，现在很多网页主页都有个性化推荐，又或者直接就是要登录的，那通常就无法缓存了，所以现在配置代理服务器的行为现在也不那么时兴了，当然一个原因也可能是现在带宽也提高了。不过另一方面，很多静态资源还是可以缓存的，比如图片、js、css 之类的文件，所以用好了代理服务器依然还是可以发挥作用的。

### 反向代理

反向代理与正向代理的一个很大区别就是，它不需要客户端(浏览器)去做什么配置，并没有什么配置代理服务器的操作.

如果说正向代理是**主动配置**，主动走代理，那么反向代理则是**被代理**，从这点上看，反向代理有时又称为透明代理，也即是浏览器都不知道自己被代理了，浏览器以为发给它响应的就是最终的网页服务器，而其实不过是个代理。

类似于:

![direct sale vs reverse proxy](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/5.png)

访问一些网站时，比如 [xiaogd.net](https://link.juejin.cn?target=https%3A%2F%2Fxiaogd.net)，可以发现响应这个访问请求的是一台 Nginx server，如下图所示:

![http response server xiaogd net](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68799e53163f457897cbeee1a6a8bfb3~tplv-k3u1fbpfcp-watermark.awebp)

问题在于 Nginx 并非最终生成这个网页的 server ，如果你了解 Nginx，就会知道它通常只是一个静态资源服务器，而相应的网页是一个动态生成的内容，从Nginx那里取得最终响应的内容，并再次转发给浏览器，整个情形如下:

![nginx reverse proxy demo](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/6.png)

这是内部配置的一个情况:

```yml
location ~ \.php$ {
    root           /ftp/wwwroot;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;
    include        fastcgi_params;
}
```

请求被转发到内部一个在 9000 端口上监听的 php 应用服务器。从外部浏览器的角度看，请求直接发给了 Nginx server，响应也从 Nginx server 里回来了，中间没有任何的(正向)代理。至于说你内部请求又被怎么转发了，显然浏览器既无从知道也不需要知道。

在整个体系里面，Nginx 的角色就是一个反向代理服务器，浏览器被代理了，但它无从知道自己是否被代理了，这一切对它而言是透明的，反正它自己是没有主动走代理的。

值得额外一提的是，通过上述你已经知道了该网站内部的配置，此时如果直接访问 [xiaogd.net:9000](https://link.juejin.cn?target=http%3A%2F%2Fxiaogd.net%3A9000)，那便是真正的“直接访问”了，就绕过了 Nginx。不过嘛，通过而言直接访问是访问不通的，因为 9000 端口并没有对外放开，只是在内部可以访问。

### 为什么要使用反向代理?

一个很直接的原因就是反向代理可以作为内部**负载均衡(load balance)**的手段：

![nginx tomcat load balance](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/7.png)

如果你在云上有好几台主机，甚至还可以将其组成一个内网，然后将 tomcat 部署在不同的主机上。比如有三台主机的话，一台运行 Nginx 监听 80 端口，其余两台运行 tomcat，分别监听 8080 和 8081 端口，同时接受并处理 Nginx 反向代理过来的请求，如下图所示：

![nginx tomcat load balance multi hosts](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/8.png)

如果两台 tomcat 主机的配置不同，比如一台的性能更强劲些，还可以调整负载的比例(即权重，weight)，让性能更强的一台承担更多的请求：

```yaml
http {
    upstream myapp1 {
        server 192.168.0.20:8080 weight=3;
        server 192.168.0.21:8080 weight=2;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}
```

> 如上配置 3:2 的权重比，让其中一台承担 60% 的请求，而另一台性能较差的则承担 40%，也即每 5 个请求，3 个会被转到 ip 为 20 的主机上，2 个会转到 ip 为 21 的主机上。

自然，有人可能会有疑问，所有请求都还是要经过 Nginx，它能处理得过来吗? 答案是可以的，因为它的功能仅仅是转发，这就有点像美团外卖，虽然它每天接受成千上万的人的点餐，但它自己不需要去买菜、洗菜、切菜、炒菜等，它仅仅需要把订单交给饭店餐馆，然后把它们做好的饭菜配送出去，也即那些耗时的做饭过程都交给了饭店餐馆处理。

在这种反向代理的模式中，同样的，生成网页这个重任交到了隐藏在背后的 tomcat，生成一个复杂的动态网页可能需要经过一些复杂的计算，要查询数据库，要拼凑各个页面组件，可能会比较耗时，但这些请求被两个 tomcat 应用并发地处理了，因此响应的速度还是得到了保证，而这些就是反向代理带来的好处。

## 3. 前端路由与后端路由

> 参考[前端南玖 - 博客园 ](https://www.cnblogs.com/songyao666/p/11470030.html)。

### 从后端路由讲起

在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入`www.baidu.com`到你看到网页这个过程中经历了什么」其实讲的也是这个道理。

![img](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/9.jpg)

在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个`404`状态码。

#### 后端路由与服务端渲染

前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。

如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的服务端渲染。

服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。

node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。

不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。

于是，我们开始进入了前端路由的时代。

### 过渡到前端路由

前端路由——顾名思义，页面跳转的URL规则匹配由前端来控制。而前端路由主要是有两种显示方式：

- 带有hash的前端路由，优点是兼容性高。缺点是URL带有`#`号不好看
- 不带hash的前端路由，优点是URL不带`#`号，好看。缺点是既需要浏览器支持也需要后端服务器支持

前端路由应用最广泛的例子就是当今的SPA的web项目。

不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。

#### 前端路由与前端渲染

讲前端路由就不能不说前端渲染。以Vue项目为例，如果你是用官方的`vue-cli`搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有`button`有`form`的样子么？我想不是的。在生产模式下，你看看构建出来的`index.html`长什么样：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vue</title>
</head>
<body>
  <div id="app"></div>
  <script type="text/javascript" src="xxxx.xxx.js"></script>
  <script type="text/javascript" src="yyyy.yyy.js"></script>
  <script type="text/javascript" src="zzzz.zzz.js"></script>
</body>
</html>
```

通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个`<div id="app"></div>`这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。

![img](https://chua-n.gitee.io/figure-bed/notebook/JavaWeb/其他/10.jpg)

前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。

需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。

##### Hash模式

hash模式利用的是浏览器不会对`#`号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：`http://localhost/#/user/1`和`http://localhost/`其实到服务端都是去请求`http://localhost`这个页面的内容。

而前端的router库通过捕捉`#`号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回`http://localhost`对应的html，剩下具体是哪个页面，就由前端路由去判断便可。

##### History模式

不带`#`号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的[history](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)这个api。比如`history.pushState()`可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。

上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是`history.pushState()`这个api，所以跟后端没什么关系。但是一旦你从浏览器地址栏里输入一个地址，比如`http://localhost/user/1`,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。

那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为`vue-cli`在开发模式下帮你启动的那个`express`开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过`vue-cli`都帮你配置好了，所以你就不用手动配置了。

那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的[配置例子](https://router.vuejs.org/zh-cn/essentials/history-mode.html)。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个`index.html`返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了`http://localhost/user/1`这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器`index.html`。

浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。

当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。

#### 前端路由与服务端渲染

虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。

当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。

关于预渲染，可以考虑使用[prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)这个webapck的插件，它的3.x版本开始使用puppeteer来构建html文件了。

### 前后端分离

得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。

前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。撒花~

