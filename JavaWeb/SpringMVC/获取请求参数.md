客户端请求参数的格式是键值对形式：name1=value1&name2=value2…

服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：

- 基本类型参数：令Controller中的业务方法的参数名称与请求参数的name一致，则参数值会被自动映射匹配。

    ```java
    // http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&age=12
    
    @RequestMapping("/quick9")
    @ResponseBody
    public void quickMethod9(String username, int age) throws IOException {
        System.out.println(username);
        System.out.println(age);
    }
    ```

- POJO类型参数：令Controller中的业务方法的POJO参数的属性名与请求参数的name一致，则参数值会自动映射匹配。

    ```java
    // http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&age=12
    
    public class User{
        private String usrname;
        private int age;
        getter/setter...
    }
    
    @RequestMapping("/quick10")
    @ResponseBody
    public void quickMethod10(User user) throws IOException {
        System.out.println(user);
    }
    ```

- 数组类型参数：令Controller中的业务方法数组名称与请求参数的name一致，则参数值会自动映射匹配。

    ```java
    // http://localhost:8080/itheima_springmvc1/quick11?strs=111&strs=222&strs=333
    
    @RequestMapping("/quick11")
    @ResponseBody
    public void quickMethod11(String[] strs) throws IOException {
        System.out.println(Arrays.asList(strs));
    }
    ```

- 集合类型参数：一般地，当获得集合参数时，要将集合参数包装到一个POJO中才可以，通常也将这种对象称为VO(value object, view object)对象（参见[B站视频](https://www.bilibili.com/video/BV1WZ4y1H7du?p=100)）。

    ```java
    // VO.java
    
    package com.itheima.domain;
    
    import java.util.List;
    public class VO {
        private List<User> userList;
        public List<User> getUserList() {
            return userList;
        }
        public void setUserList(List<User> userList) {
            this.userList = userList;
        }
        @Override
        public String toString() {
            return "VO{" +
                    "userList=" + userList +
                    '}';
        }
    }
    ```

    ```java
    // UserController.java
    
    @RequestMapping("/quick9")
    @ResponseBody
    public void save9(VO vo) {
        System.out.println(vo);
    }
    ```

    ```jsp
    <%-- form.jsp --%>
    
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
        <head>
            <title>Title</title>
        </head>
        <body>
            <form action="${pageContext.request.contextPath}/quick9" method="post">
                <%-- 表明第一个User对象的username、age --%>
                <input type="text" name="userList[0].username" /><br />
                <input type="text" name="userList[0].age" /><br />
                <input type="text" name="userList[1].username" /><br />
                <input type="text" name="userList[1].age" /><br />
                <input type="submit" value="提交" />
            </form>
        </body>
    </html>
    ```

    ![30](https://chua-n.gitee.io/blog-images/notebooks/JavaWeb/SpringMVC/30.png)

    ![31](https://chua-n.gitee.io/blog-images/notebooks/JavaWeb/SpringMVC/31.png)

    - 当使用ajax提交时，可以指定contentType为json形式，此时在方法参数位置使用@RequestBody注解可以直接接收集合数据，而无需使用POJO进行包装（参见[B站视频](https://www.bilibili.com/video/BV1WZ4y1H7du?p=101)）。

        ```jsp
        <script>
        // 模拟数据
            var userList = new Array();
            userList.push({username: "zhangsan", age: "20"});
            userList.push({username: "lisi", age: "20"});
            $.ajax({
                type: "POST",
                url: "/itheima_springmvc1/quick13",
                data: JSON.stringify(userList),
                contentType: 'application/json;charset=utf-8'
            });
        </script>
        ```

        ```java
        @RequestMapping(value="/quick15")
        @ResponseBody
        public void save15(@ResponseBody List<User> userList) throws IOException {
            System.out.println(userList);
        }
        ```



