---
title: 磁盘管理
date: 2019-09-13
---

## 1. 文件系统

文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。

Linux 支持数十种的文件系统，而最常见的文件系统为：

1. **Ext3**——一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。不过，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。
2. **Ext4**——Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。且 Ext4 文件系统能够批量分配 block 块，从而极大地提高读写效率。
3. **XFS**——一种高性能的日志文件系统，是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB，几乎能满足所有需求。

在拿到一块新的硬盘存储设备后，需要**先分区**，然后**再格式化**文件系统，最后才能**挂载**并正常使用。

- 硬盘的分区操作取决于你的需求和硬盘大小，也可以选择不进行分区，但必须对硬盘进行格式化处理。
- 如果硬件存储设备没有格式化，则 Linux 系统无法得知怎么在其中写入数据。因此，在对存储设备进行分区后还需进行格式化操作。

为了使用户在读取或写入文件时不用关心底层的硬盘结构，Linux 内核中的软件层为用户程序提供了一个**VFS(Virtual File System，虚拟文件系统)** 接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了：

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/19.png" style="zoom:67%;" />

## 2. 物理设备的命名

在 Linux 系统中一切都是文件，硬件设备也不例外。

系统内核的**udev 设备管理器**会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等，这对于陌生的设备来说特别方便。同时，udev 设备管理器的服务会一直以守护进程的形式运行并侦听内核发生的信号来管理/dev 目录下的设备文件。

Linux 中常见的硬件设备及其文件名称如下。实际上，由于现在的 IDE 设备已经很少见了，所以一般的硬盘设备都会是以/dev/sd 开头的。由于一台主机上可以有多块硬盘，因此采用 a~p 来代表 16 块不同的硬盘（默认从 a 开始分配），而且硬盘的分区编号也很有讲究：

1. 主分区或扩展分区的编号从 1 开始，到 4 结束；

2. 逻辑分区从编号 5 开始。

    |    硬件设备    |      文件名称       |
    | :------------: | :-----------------: |
    |    IDE 设备    |    /dev/hd[a-d]     |
    | SCSI/SATA/U 盘 |    /dev/sd[a-p]     |
    |      软驱      |    /dev/fd[0-1]     |
    |     打印机     |    /dev/lp[0-15]    |
    |      光驱      |     /dev/cdrom      |
    |      鼠标      |     /dev/mouse      |
    |     磁带机     | /dev/st0 或/dev/ht0 |

注意事项

1. /dev 目录中的 sda 设备之所以是 a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。这就是为什么在使用 iSCSI 网络存储设备时，明明主板上第二个插槽是空着的，但系统却能识别到/dev/sdb 这个设备的原因。
2. 另外，sda3 只能表示是编号为 3 的分区，而不能判断 sda 设备上已经存在了 3 个分区。

分析如下/dev/sda5 设备文件名称：

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/20.png" style="zoom:67%;" />

-   /dev/目录中保存硬件设备文件
-   sd 表示是存储设备
-   a 表示系统中同类接口中第一个被识别到的设备
-   5 表示这个设备是一个逻辑分区

## 3. 挂载硬件设备

当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是**挂载**。挂载是在使用硬件设备前执行的最后一步操作。

我们挂载文件系统的目的是为了使用硬件资源，而**卸载**文件系统意味着不再使用硬件的设备资源。相对应地，挂载操作就是把硬件设备与目录进行关联的动作，因此卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要其他参数。

挂载相关命令：

-   `mount`

    -   `mount`：输出已挂载的设备列表

        > 每行输出提供 4 部分信息：
        >
        > 1. 媒介的设备文件名
        > 2. 媒介挂载到虚拟目录的挂载点
        > 3. 文件系统类型
        > 4. 已挂载媒介的访问状态

    -   `mount <option> <type> device dir`：挂载操作

        | option |               function                |
        | :----: | :-----------------------------------: |
        |  `-a`  | 挂载所有在/etc/fstab 中定义的文件系统 |
        |  `-t`  |          指定文件系统的类型           |

        > 要把设备/dev/sdb2 挂载到/backup 目录中，执行如下：
        >
        > ```bash
        > $ mount /dev/sdb2 /backup
        > ```
        >
        > 上述命令执行后就能立即使用文件系统，但在系统重启后挂载就会失效，也就是每次开机后都需要手动挂载一下。

-   `umount`：撤销已经挂载的设备文件，`umount 挂载点/设备文件`

    ```bash
    $ umount /dev/sdb2
    ```

若要让硬件设备和目录永久地进行自动关联，必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”写入到/etc/fstab 文件中：

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/21.png" style="zoom:50%;" />

## 4. 管理磁盘

**SWAP（交换）** 分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。

由于 SWAP 分区是通过硬盘设备读写数据的，速度肯定比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。

在生产环境中，SWAP 分区的大小一般为真实物理内存的 1.5~2 倍。

**磁盘容量配额**——root 管理员使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用，相关 Linux 命令为`quota`命令。

1. **软限制**——当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
2. **硬限制**——当达到硬限制时会提示用户，且强制终止用户的操作。

管理磁盘的 Linux 命令：

-   `fdisk`：管理磁盘的一站式分区服务，`fdisk <option> device`

    | option |        function        |
    | :----: | :--------------------: |
    |  `m`   |   查看全部可用的参数   |
    |  `n`   |      添加新的分区      |
    |  `d`   |      删除某个分区      |
    |  `l`   | 列出所有可用的分区类型 |
    |  `t`   |   改变某个分区的类型   |
    |  `p`   |      查看分区信息      |
    |  `w`   |       保存并退出       |
    |  `q`   |     不保存直接退出     |

    > 分区可以按主分区或扩展分区创建，主分区可以被文件系统直接格式化，而扩展分区则只能容纳逻辑分区（参见硬盘 MBR 分区）。

-   `mkfs`：格式化操作，`mkfs.type device`

    |  mkfs.type   |        function         |
    | :----------: | :---------------------: |
    | `mkfs.ext3`  | 创建一个 ext3 文件系统  |
    | `mkfs.ext4`  | 创建一个 ext4 文件系统  |
    |  `mkfs.xfs`  |  创建一个 XFS 文件系统  |
    |  `mkfs.zfz`  |  创建一个 ZFS 文件系统  |
    | `mkfs.btrfs` | 创建一个 Btrfs 文件系统 |

    <img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/22.png" style="zoom:67%;" />

-   `df`：查看所有已挂载磁盘的使用情况，`df <option> `

    | 参数 |                             作用                             |
    | :--: | :----------------------------------------------------------: |
    | `-h` | 将输出中的磁盘空间按照用户易读的形式显示，通常用 M 来替代兆字节，用 G 来替代吉字节 |

-   `du`：查看文件/目录占用的磁盘空间，`du <option> <file>`

    |    option     |          function          |
    | :-----------: | :------------------------: |
    | `--max-depth` |    展示的最大子目录深度    |
    |     `-c`      | 显示所有已列出文件总的大小 |
    |     `-h`      |   按用户易读格式输出大小   |
    |     `-s`      |   显示每个输出参数的总计   |

    ```bash
    $ du --max-depth 1 -h
    284K    ./C++
    828K    ./fc_stw
    1.1G    ./GAN
    6.0M    ./LCD
    8.6M    ./LeetCode
    16K     ./linux
    4.0K    ./markdown
    4.0K    ./pore
    128K    ./pytorch
    848K    ./sklearn_demo
    8.5G    ./VAE
    9.5G    .
    ```

-   `mkswap`：SWAP 分区专用的格式化命令

-   `swapon`：把准备好的 SWAP 分区设备正式挂载到系统中

-   `xfs_quota`：专门针对 XFS 文件系统来管理 quota 磁盘容量配额服务的命令，`xfs_quota <option> 配额 文件系统`

    -   -c 参数用于以参数的形式设置要执行的命令
    -   -x 参数是专家模式，让运维人员能够对 quota 服务进行更多复杂的配置

-   `edquota`：编辑用户的 quota 配额限制，`edquota <option> <user>`

    -   -u 参数表示要针对哪个用户进行设置
    -   -g 参数表示要针对哪个用户组进行设置

## 5. 硬盘的 MBR 分区

硬盘是由大量的**扇区**组成的，每个扇区的容量为 512 字节。其中，**第一个扇区**最重要，它里面保存着**主引导记录**与**分区表信息**。

就第一个扇区来讲，主引导记录需要占用 446 字节，分区表需要 64 字节，结束符占用 2 字节。其中分区表中每记录一个分区信息就需要 16 字节，这样一来最多只有 4 个分区信息可以写到第一个扇区中，这 4 个分区就是 4 个**主分区**。

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/23.png" style="zoom:67%;" />

难道说第一个扇区最多只能创建出 4 个分区？为了解决分区个数不够的问题，可以将第一个扇区的分区表中 16 字节（原本要写入主分区信息）的空间拿出来指向另外一个分区，这部分空间称之为**扩展分区**。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用 16 字节分区表空间的指针。这样一来，用户一般会选择使用 3 个主分区加 1 个扩展分区的方法，然后在扩展分区中创建出数个**逻辑分区**，从而来满足多区分（大于 4 个）的需求。

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/24.png" style="zoom:50%;" />

## 6. RAID

**RAID**，**独立冗余磁盘阵列**，其通过把多个设备组合成一个容量更大、安全性更好的**磁盘阵列**，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的**数据冗余备份**效果。

RAID 技术的设计初衷是减少因为采购硬盘设备带来的费用支出，但是与数据本身的价值相比较，现代企业更看重的则是 RAID 技术所具有的冗余备份机制以及带来的硬盘吞吐量的提升。也就是说，RAID 不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得以广泛部署和应用。

出于成本和技术方面的考虑，需要针对不同的需求在数据可靠性及读写性能上作出权衡，制定出满足各自需求的不同方案。常见的方案有**RAID 0**, **RAID 1**, **RAID 5**, **RAID 10**四种：

-   RAID 0——RAID 0 技术把多块物理硬盘设备通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次定稿到各个物理硬盘中。能够有效地提升硬盘数据的吞叶速度，但是不具备数据备份和错误修复能力。

    ![](https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/25.png)

-   RAID 1——把两块以上的硬盘进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。此方案硬盘的利用率下降，从理论上来说下图所示硬盘空间的真实可用率只有 50%，由三块硬盘设备组成的 RAID 1 磁盘阵列利用率只有 33%，以此类推。

    ![](https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/26.png)

-   RAID 5——把硬盘设备的数据奇偶检验信息保存到其他硬盘设备中。RAID 5 技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶检验信息来尝试重建损坏的数据。这种方案妥协地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。

    ![27](https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/27.png)

-   RAID 10——RAID 1 与 RAID 0 技术的一个组合体，RAID 10 技术需要至少 4 块硬盘来组建，其中先分别两两制作成 RAID 1 磁盘阵列，以保证数据的安全性；然后再对两个 RAID 1 磁盘阵列实施 RAID 0 技术，进一步提高硬盘设备的读写速度。生产环境中主要使用的是 RAID 10 技术。

    ![](https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/28.png)

Linux 中管理软件 RAID 硬盘阵列的命令为`mdadm`：`mdadm <模式> < RAID设备名称> <选项> <成员设备名称>`

| 参数 |         作用         |             备注             |
| :--: | :------------------: | :--------------------------: |
| `-a` |     检测设备名称     | -a yes 代表自动创建设备文件  |
| `-n` |     指定设备数量     | -n 4 代表使用 4 块硬盘来部署 |
| `-l` |    指定 RAID 级别    |   -l 10 代表 RAID 10 方案    |
| `-C` | 创建一个 RAID 阵列卡 |                              |
| `-v` |     显示创建过程     |                              |
| `-f` |     模拟设备损坏     |                              |
| `-r` |       移除设备       |                              |
| `-Q` |     查看摘要信息     |                              |
| `-D` |     查看详细信息     |                              |
| `-S` |  停止 RAID 磁盘阵列  |                              |

在确认有一块物理硬盘设备出现损坏而不能继续正常使用后，应该使用`mdadm`命令将其移除，然后查看 RAID 磁盘阵列的状态，可以发现状态已经改变。

**RAID 备份盘技术**的核心理念是准备一块足够大的硬盘，这块硬盘平时处于闲置状态，一旦 RAID 磁盘阵列中有硬盘出现故障后就会马上自动顶替上去。

## 7. LVM

前面学习的硬盘设备管理技术虽然能够有效地提高硬盘设备的读写速度以及数据的安全性，但是在硬盘分好区或者部署为 RAID 磁盘阵列之后，再想修改硬盘分区大小就不容易了，因而有了**LVM 技术(logical volume manager, 逻辑卷管理器)**.

**LVM**可以将另外一个硬盘上的分区加和已有文件系统，动态地添加存储空间，让你无需重建整个文件系统。

<img src="https://chua-n.gitee.io/figure-bed/notebook/杂技/Linux/29.png" style="zoom:67%;" />

-   **物理卷**——在 LVM 中，硬盘称为物理卷(physical volume, PV)，每个物理卷都会映射到硬盘上特定的物理分区。
-   **卷组**——多个物理卷集中在一起可以形成一个卷组(volume group, VG)。LVM 将卷组视为一个物理硬盘，尽管事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的。卷组提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统。
-   **逻辑卷**——逻辑卷(logical volume, LV)为 Linux 提供了创建文件系统的分区环境，Linux 将每个逻辑卷视为一个物理分区。可以使用任意一种标准 Linux 文件系统来格式化逻辑卷，然后再将它加入 Linux 虚拟目录中的某个挂载点。
-   优点——通过 LVM，你可以在日后将某硬盘未使用的分区分配到已有卷组，或者将一块新插入电脑的硬盘添加到已有卷组：可创建一个新的逻辑卷，或在需要更多空间时用它来扩展已有的逻辑卷。

LVM 技术的相关 Linux 操作

1. 常用的 LVM 部署命令

    | 功能 | 物理卷管理(pv) | 卷组管理(vg) | 逻辑卷管理(lv) |
    | :--: | :------------: | :----------: | :------------: |
    | 扫描 |     pvscan     |    vgscan    |     lvscan     |
    | 建立 |    pvcreate    |   vgcreate   |    lvcreate    |
    | 显示 |   pvdisplay    |  vgdisplay   |   lvdisplay    |
    | 删除 |    pvremove    |   vgremove   |    lvremove    |
    | 扩展 |                |   vgextend   |    lvextend    |
    | 缩小 |                |   vgreduce   |    lvreduce    |

2. 扩容逻辑卷——扩展前一定要卸载设备和挂载点的关联

3. 缩小逻辑卷——Linux 规定，在对 LVM 逻辑卷进行缩容操作之前，要先检查文件系统的完整性（当然这也是为了保证我们的数据安全）。在执行缩容操作前先要先把文件系统卸载掉。

4. 逻辑卷快照——LVM 的**快照**功能有三个特点：

    1. 在备份由于高可靠性需求而无法锁定的重要数据时，快照功能非常给力。传统的备份方法在将文件复制到备份媒介上时通常要将文件锁定，而快照允许你在复制的同时，保证运行关键任务的 Web 服务器或数据库服务器继续工作；
    2. 快照卷的容量必须等于逻辑卷的容量；
    3. 快照卷仅一次有效，一旦执行还原操作后会被立即自动删除；

5. 删除逻辑卷——删除前记得提前备份好重要的数据信息，然后依次删除逻辑卷、卷组、物理卷设备，这个顺序不可颠倒。

## 8. 更改 swap 分区大小

|                         命令                         |                             作用                             |
| :--------------------------------------------------: | :----------------------------------------------------------: |
|                  `$ sudo swapon -s`                  | 查看是否已经存在 swapfile，即 swap 分区(一般情况下都是存在的，且文件为/swapfile) |
|              `$ sudo swapoff /swapfile`              | 将上一步查到的 swap 分区文件停用掉（不然会占用资源而无法修改） |
| `$ sudo dd if=/dev/zero of=/swapfile bs=1G count=16` | 创建一个新的 swapfile，名字与上面查到的相同以便覆盖，你想创建的 swap 分区的大小应该为$bs \times count$ |
|              `$ sudo mkswap /swapfile`               |              设置上面创建的文件为 swap 文件类型              |
|              `$ sudo swapon /swapfile`               | 启用刚刚创建的 swap 分区（因为上述操作是覆盖了原来的/swapfile，所以无需修改/etc/fstab 配置文件即可永久生效） |
