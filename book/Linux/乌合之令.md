---
title: 乌合之令
---

## 短小之令

- `clear`：清除屏幕里的所有命令

- `reboot`：重启系统，默认只能使用 root 管理员来重启

- `poweroff`：关闭系统，默认只有 root 管理员可关闭

- `last`：查看系统所有的登录记录，`last <option>`

  > 由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很轻易地对内容进行篡改，千成不要单纯地以该命令的输出信息来判断系统有无被恶意入侵。

- `who`：查看当前登入主机的用户终端信息，`who <option>`

- `uname`：查看系统内核与系统版本等信息，`uname <-a>`

- `sosreport`：收集系统配置及架构信息，并输出诊断文档

- `type`：判断某命令是内建命令还是外部命令，`type command`

- `which`：在`PATH`变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果，使用语法为`which command`

- `whereis`：用于程序名的搜索，而且只搜索二进制文件(参数-b)、man说明文件(参数-m)和源代码文件(参数-s)。如果省略参数，则返回所有信息。

  > 和`find`相比，`whereis`查找的速度非常快，这是因为 Linux 系统会将系统内的所有文件都记录在一个数据库文件中，当使用`whereis`和下面即将介绍的`locate`时，会从数据库中查找数据，而不是像`find`命令那样，通过遍历硬盘来查找，效率自然会很高。

- `locate`：此命令可以在搜寻数据库时快速找到档案，数据库由`updatedb`程序来更新，`updatedb` 是由`cron daemon`周期性建立的，`locate`命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是`locate`所找到的档案若是最近才建立或刚更名的，可能会找不到，默认情况下，`updatedb`每天会跑一次，可以由修改`crontab`来更新设定值。

- `exit`：退出当前 shell

- `sleep`：开启休眠模式

## man/info

`man`：查看某命令存储在 Linux 系统上的手册页面。

如果不记得 shell 的命令名，可用关键字搜索手册页，语法是 `man -k keyword`，如，要查找与终端相关的命令，可以输入 `man -k terminal`.

|   按键    |               用途               |
| :-------: | :------------------------------: |
|  空格键   |            向下翻一页            |
|  回车键   |             逐行查看             |
| Page Down |            向下翻一页            |
|  Page Up  |            向上翻一页            |
|   home    |           直接前往首页           |
|    end    |           直接前往尾页           |
|     /     | 从上至下搜索某个关键词，如/linux |
|     ?     | 从下至上搜索某个关键词，如?linux |
|     n     |    定位到下一个搜索到的关键词    |
|     N     |    定位到上一个搜索到的关键词    |
|     q     |           退出帮助文档           |

man 手册页不是唯一的参考资料，还有另一种叫作 info 页面的信息。可以输入`info info`来了解 info 页面的相关内容。

## history

`history <-c>` 是显示历史执行过的命令，其默认记录当前用户执行过的最近 1000 条命令记录，通过自定义 `/etc/profile` 文件中的 `HISTSIZE` 环境变量值可改变记录的条数。

历史命令会被保存到用户家目录中的 `.bash_history` 文件中，当不会实时写入该文件，可以在退出 shell 会话之前强制将命令历史记录写入`.bash_history`文件，使用`-a`选项即可。

如果你打开了多个终端会话， 仍然可以使用 `history -a` 命令在打开的会话中向`.bash_history`文件中添加记录。但是对于其他打开的终端会话，历史记录并不会自动更新。这是因为`.bash_history`文件只有在打开首个终端会话时才会被读取。要想强制重新读取`.bash_history`文件，更新终端会话的历史记录，可以使用`history -n`命令。

对于命令历史，你可以唤回历史列表中任意一条命令，只需输入惊叹号和命令在历史列表中的编号即可，如：

```bash
$ history
[...]
13 pwd
14 ls
15 cd
16 type pwd
17 which pwd
18 type echo
19 which echo
20 type -a pwd
21 type -a echo
[...]
32 history -a
33 history
34 cat .bash_history
35 history
$
$ !20
type -a pwd
pwd is a shell builtin
pwd
```

## alias/unalias

|   命令    | 作用                 |             示例             | 示例说明                                                     |
| :-------: | :------------------- | :--------------------------: | ------------------------------------------------------------ |
|  `alias`  | 给某命令创建一个别名 | `alias another_name=command` | <ul><li>可使用 `alias -p` 查看当前可用的别名；</li><li>别名仅在它被定义的 shell 进程中有效。</li></ul> |
| `unalias` | 取消一个别名         |    `unalias another_name`    |                                                              |

## date

`date`：显示及设置系统时间/日期，`date <option> <+指定的格式>`

|              命令              |             输出             |
| :----------------------------: | :--------------------------: |
|            `$ date`            | Mon Aug 24 16:11:23 CST 2017 |
| `$ date "+%Y-%m-%d %H:%M:%S"`  |     2019-09-12 11:34:27      |
| `$ date -s "20170901 8:30:00"` |    将当前系统时间设置为此    |

| 参数 |      作用      |
| :--: | :------------: |
| `%t` | 跳格【Tab 键】 |
| `%H` | 小时（00~23）  |
| `%I` | 小时（00~12）  |
| `%M` | 分钟（00~59）  |
| `%S` |   秒（00~59)   |
| `%j` | 今年中的第几天 |

使用示例：

```bash
$ date
Tue Dec 13 16:58:39 CST 2022
```

## cal

`cal` 命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。

使用示例（实际显示时，13号那里有底色标记）：

```bash
$ cal
   December 2022
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
```

## sort

处理大量数据时的一个常用命令是`sort`命令。顾名思义，`sort`命令是对数据进行排序的。

## lsof

> 在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。

`lsof`(list open files)是一个列出当前系统打开文件的工具。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过`lsof`工具能够查看这个列表对系统监测以及排错将是很有帮助的。

| 参数              | 作用                       |
| ----------------- | -------------------------- |
| `-h`              | 显示帮助信息               |
| `-p PID`          | 列出指定进程号所打开的文件 |
| `-c process_name` | 列出指定进程所打开的文件   |
| `-a`              | 列出打开文件存在的进程     |
| `-g`              | 列出 GID 号进程详情        |
| `-d 文件号`       | 列出占用该文件号的进程     |
| `+d 目录`         | 列出目录下被打开的文件     |
| `+D 目录`         | 递归列出目录下被打开的文件 |
| `-n 目录`         | 列出使用NFS的文件          |
| `-i 条件`         | 列出符合条件的进程         |
| `-u UID`          | 列出UID号进程详情          |

## ulimit

`ulimit` 为shell内建指令，可用来控制shell执行程序的资源。

|        参数         |                     作用                     |
| :-----------------: | :------------------------------------------: |
|        `-a`         |            显示目前资源限制的设定            |
| `-c <core文件上限>` |       设定core文件的最大值，单位为区块       |
| `-d <数据节区大小>` |        程序数据节区的最大值，单位为KB        |
|   `-f <文件大小>`   |     shell所能建立的最大文件，单位为区块      |
|        `-H`         | 设定资源的硬性限制，也就是管理员所设下的限制 |
|   `-m <内存大小>`   |        指定可使用内存的上限，单位为KB        |
|   `-n <文件数目>`   |        指定同一时间最多可开启的文件数        |
|  `-p <缓冲区大小>`  |      指定管道缓冲区的大小，单位512字节       |
|   `-s <堆叠大小>`   |           指定堆叠的上限，单位为KB           |
|        `-S`         |              设定资源的弹性限制              |
|   `-t <CPU时间>`    |       指定CPU使用时间的上限，单位为秒        |
|   `-u <程序数目>`   |           用户最多可开启的程序数目           |
| `-v <虚拟内存大小>` |      指定可使用的虚拟内存上限，单位为KB      |

## sed, awk

TODO

## 正则表达式

使用正则表达式最大的问题在于有不止一种类型的正则表达式，不同的应用程序可能会用不同类型的正则表达式，比如编程语言（Java、Perl和Python）、Linux实用工具（比如sed编辑器、gawk程序和grep工具）以及主流应用（比如MySQL和PostgreSQL数据库服务器）。正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。

在Linux中，有两种流行的正则表达式引擎：

- POSIX基础正则表达式（basic regular expression，BRE）引擎
- POSIX扩展正则表达式（extended regular expression，ERE）引擎

大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。遗憾的是，有些工具（比如sed编辑器）只符合了BRE引擎规范的子集，这是出于速度方面的考虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本。

## tmux

当在本地的命令行中使用 SSH 连接到远程服务器进行工作时，如果 SSH 连接突然停止，会导致远程服务器中运行的相关命令停止执行（因为 SSH 创建的进程被关闭），这意味着如果你正在服务器中进行一个长时间执行的操作，比方说训练一个神经网络，当网络意外中断、或你关闭了本地的命令行窗口，将导致该操作的运行终止，而不是继续在服务器中执行。那么如何让“连接中断时，正在执行的指令仍旧保持运行”呢，这就可以用到 tmux 命令了。

### tmux 简介

tmux(terminal multiplexer) 是一个终端复用器，它可以在一个窗口屏幕上创建、访问、控制多个终端。

-   tmux 使得“终端会话”可以从屏幕上分离出来，继续在后台运行，待后续重新连接；
-   tmux 还允许每个会话有多个连接窗口，因此可以多个用户实时共享会话。

### session、window、pane:

tmux 中有三个重要的概念需要辨析：session、window、pane，其手册中如是说：

> A session is a single collection of pseudo terminals under the management of tmux. Each session has one or more windows linked to it. A window occupies the entire screen and may be split into rectangular panes, each of which is a separate pseudo terminal (the pty(4) manual page documents the technical details of pseudo terminals). Any number of tmux instances may connect to the same session, and any number of windows may be present in the same session. Once all sessions are killed, tmux exits.
>
> Each session is persistent and will survive accidental disconnection (such as ssh(1) connection timeout) or intentional detaching (with the ‘C-b d’ key strokes).

即，一个会话(session)是一系列伪终端的集合，一个会话可以有多个窗口(window)，所谓的窗口就是日常所说的占据一块屏幕区域的窗口，每一个窗口又可以进行“分屏”，切割为若干窗格(pane)，或称之为子屏幕，对于每一个子屏幕，它也是一个独立的伪终端。

### tmux 命令

|                          命令                          |                             作用                             |
| :----------------------------------------------------: | :----------------------------------------------------------: |
|                          tmux                          |             开启一个 tmux 会话（以数字编号为名）             |
|            tmux new -s &lt;session-name&gt;            |               开启一个名为 session-name 的会话               |
|                        tmux ls                         |                   查看所有存在的 tmux 会话                   |
|                      tmux detach                       |                      脱离当前 tmux 会话                      |
|          tmux attach -t &lt;session-name&gt;           | 连接名为 session-name 的会话，这里的 session-name 当然也可以为数字编号形式的名字 |
|          tmux switch -t &lt;session-name&gt;           |                           切换会话                           |
| tmux rename-session -t &lt;oldname&gt; &lt;newname&gt; |                          重命名会话                          |
|       tmux kill-session -t &lt;session-name&gt;        |                           销毁会话                           |

### tmux 快捷键

在 tmux 会话内，可使用一些快捷键替代 tmux 命令，不过要想使用快捷键，必须每次先按下前缀键`Ctrl + b`唤醒快捷键功能。

> 注意：若想脱离而不销毁会话，一定要按`Ctrl + b + d`，别按成了`Ctrl + d`，这个属于 linux 终端的快捷键，会直接退出并销毁会话。

-   系统操作：

|  快捷键  |                           功能                           |
| :------: | :------------------------------------------------------: |
|    ?     |                      列出所有快捷键                      |
|    :     |                      进入命令行模式                      |
|    [     |           进入复制模式，此时的操作与 vim 相同            |
|    d     |                       脱离当前会话                       |
|    D     |                     选择要脱离的会话                     |
|    r     |                   强制重绘未脱离的会话                   |
|    ~     | 列出提示信息缓存，其中包含了之前 tmux 返回的各种提示信息 |
| `Ctrl+z` |                       挂起当前会话                       |

-   窗口操作

| 快捷键 |                 功能                 |
| :----: | :----------------------------------: |
|   c    |              创建新窗口              |
|   &    |             关闭当前窗口             |
| 数字键 |            切换至指定窗口            |
|   p    |            切换至上一窗口            |
|   n    |            切换至下一窗口            |
|   l    |       在前后两个窗口间互相切换       |
|   w    |         通过窗口列表切换窗口         |
|   ,    |            重命名当前窗口            |
|   .    | 修改当前窗口编号，相当于窗口重新排序 |
|   f    |       在所有窗口中查找指定文本       |

-   窗格操作

|    快捷键     |               功能                |
| :-----------: | :-------------------------------: |
|       "       |     当当前窗格上下平分为两块      |
|       %       |     将当前窗格左右平分为两块      |
|       x       |           关闭当前窗格            |
|       !       |       将当前面板置于新窗口        |
| `Ctrl+方向键` | 以 1 个单元格为单位，移动窗格边缘 |
| `Alt+方向键`  | 以 5 个单元格为单位，移动窗格边缘 |
|       q       |           显示窗格编号            |
|       o       |     在当前窗格中选择下一窗格      |
|    方向键     |        移动光标以选择面板         |
|       {       |         向前置换当前面板          |
|       }       |         向后置换当前面板          |
|   `Ctrl+o`    |     顺时针旋转当前窗口的面板      |
|    `Alt+o`    |     逆时针旋转当前窗口的面板      |

## cloc：统计代码行数

当想要统计某文件夹下代码的行数时，可以使用`cloc`命令。如：

```shell
$ cloc particle/

     123 text files.
     110 unique files.
      23 files ignored.

github.com/AlDanial/cloc v 1.82  T=0.22 s (494.5 files/s, 188728.2 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Python                          94           4487          15174          19605
XML                              8            101            153           1023
XSD                              1             23             15            161
Bourne Shell                     1              2             36             26
Markdown                         3             12              0             22
-------------------------------------------------------------------------------
SUM:                           107           4625          15378          20837
-------------------------------------------------------------------------------
```
