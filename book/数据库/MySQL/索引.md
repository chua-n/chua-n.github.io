## 1. 主键

对于关系表，有个很重要的约束，就是每条记录必须有一个**唯一性标识**，即通过某个字段可以区分出不同的记录，这个字段即被称为**主键(primary key)** 。

1. 选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。

   > 如果我们以学生的身份证号作为主键，似乎能唯一定位记录，然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。

2. 主键值也不能为`NULL`。

3. 一般我们把主键这个字段命名为`id`，常见的可作为`id`字段的类型有：

   - 自增**整数**类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
   - **GUID**类型：使用一种全局唯一的字符串作为主键，类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。

### 联合主键

关系数据库实际上还允许通过多个字段唯一标识记录，即将两个或更多的字段都设置为主键，这种主键被称为**联合主键**。

显然，对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：

| id_num | id_type | other columns |
| :----: | :-----: | :-----------: |
|   1    |    A    |      ...      |
|   2    |    A    |      ...      |
|   2    |    B    |      ...      |

> 1. 如果我们把上述表的`id_num`和`id_type`这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。
> 2. 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。

## 2. 外键

### 2.1 概念定义

**外键**是某个表中的一列，它包含另一个表的主键值，定义了两个表的关系。

如，当我们用主键唯一标识记录时，我们就可以在`students`表中确定任意一个学生的记录：

|  id  | name | other columns |
| :--: | :--: | :-----------: |
|  1   | 小明 |      ...      |
|  2   | 小红 |      ...      |

我们还可以在`classes`表中确定任意一个班级记录：

|  id  | name | other columns |
| :--: | :--: | :-----------: |
|  1   | 一班 |      ...      |
|  2   | 二班 |      ...      |

但是我们如何确定`students`表的一条记录，例如，`id=1`的小明，属于哪个班级呢？由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个`classes`的记录可以对应多个`students`表的记录。为了表达这种一对多的关系，我们需要在`students`表中加入一列`class_id`，让它的值与`classes`表的某条记录相对应，这样，我们就可以根据`class_id`这个列直接定位出一个`students`表的记录应该对应到`classes`的哪条记录。

| id   | class_id | name | other columns |
| ---- | -------- | ---- | ------------- |
| 1    | 1        | 小明 | ...           |
| 2    | 1        | 小红 | ...           |
| 5    | 2        | 小白 | ...           |

在`students`表中，通过`class_id`的字段，可以把数据与另一张表关联起来，这种列称为外键。

### 2.2 外键约束

外键并不是通过列名实现的，而是通过定义**外键约束**实现的：

```sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

> 其中，外键约束的名称`fk_class_id`可以任意，`FOREIGN KEY (class_id)`指定了`class_id`作为外键，`REFERENCES classes (id)`指定了这个外键将关联到`classes`表的`id`列（即`classes`表的主键）

通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果`classes`表不存在`id=99`的记录，`students`表就无法插入`class_id=99`的记录。

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，`class_id`仅仅是一个普通的列，只是它起到了外键的作用而已。

要删除一个外键约束，也是通过`ALTER TABLE`实现的：

```sql
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

> 注意：删除外键约束并没有删除外键这一列。删除列是通过`DROP COLUMN ...`实现的 。

## 3. 索引

### 3.1 概念引入

在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。

**索引**是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。例如，对于`students`表：

|  id  | class_id | name | gender | score |
| :--: | :------: | :--: | :----: | :---: |
|  1   |    1     | 小明 |   M    |  90   |
|  2   |    1     | 小红 |   F    |  95   |
|  3   |    1     | 小军 |   M    |  88   |

如果要经常根据`score`列进行查询，就可以对`score`列创建索引：

```sql
ALTER TABLE students
ADD INDEX idx_score (score);
```

- 使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`、使用列`score`的索引。

- 可以对一张表创建多个索引，其中索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：

  ```sql
  ALTER TABLE students
  ADD INDEX idx_name_score (name, score);
  ```

### 3.2 索引的影响

索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。

**索引的效率取决于索引列的值是否散列**：

- 该列的值如果越互不相同，那么索引效率越高。
- 反过来，如果记录的列存在大量相同的值，例如`gender`列，大约一半的记录值是`M`，另一半是`F`，因此，对该列创建索引就没有意义。

对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。

无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。

### 3.3 唯一性索引 vs 唯一性约束

> 某一列是索引，但并不意味着该列是的值是不能重复的。

在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。

例如，我们假设`students`表的`name`不能重复，通过下面的`UNIQUE`关键字我们就添加了一个唯一索引：

```sql
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);
```

也可以只对某一列添加一个唯一约束而不创建唯一索引，下面这种情况，`name`列没有索引，但仍然具有唯一性保证。

```sql
ALTER TABLE students
ADD CONSTRAINT uni_name UNIQUE (name);
```

## 4. 约束

一张表中的主键一定是唯一的，但约束可以有多个。

约束：

- `Default`约束
- `Check`约束
- `Unique`约束