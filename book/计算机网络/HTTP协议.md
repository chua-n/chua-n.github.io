---
title: HTTP 协议
---

> 很好的阅读资料：[HTTP | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/HTTP)

## 1. 踏入山门

### 1.1 TCP/IP

为了准确无误地将数据送达目标处，TCP 协议采用了三报文握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。

若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

![image-20221010141758665](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221010141758665.png)

### 1.2 基于 TCP/IP 的 HTTP 传输过程

![image-20221010140908985](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221010140908985.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

这种把数据信息包装起来的做法称为**封装**。

### 1.3 URI 与 URL

定义：

- URI: Uniform Resource Identifier，统一**资源标志**符，用于标识某一互联网资源
- URL: Uniform Resource Locator，统一**资源定位**符，用于标识和定位某一互联网资源

> （个人理解）上述术语中的“统一”只是说使用一个大一统的规则，千万不要将它误以为带有“唯一”的意思。

#### 白话例子

用大白话讲，URI 就是在某一规则下能把一个资源独一无二地标识出来。

拿人作例子，假设这个世界上所有人的名字都不能重复，那么名字就是 URI 的一个实例，通过名字这个字符串就可以标识出唯一的一个人；而现实当中名字当然是会重复的，所以身份证号才是 URI，通过身份证号能让我们能且仅能确定一个人。

那统一资源定位符 URL 是什么呢？

也拿人作例子然后跟 HTTP 的 URL 做类比，就可以有：`动物住址协议：//地球/中国/浙江省/杭州市/西湖区/某大学/14 号宿舍楼/525 号寝/张三。人`，于是，这相字符串同样标识出了唯一的一个人，相当于也起到了 URI 的作用。URL 是以描述人的位置来唯一确定一个人的。

所以不论是用定位的方式还是用身份证号的方式，我们都可以唯一确定一个人，这些都是 URI 的一种实现，所谓的 URL 就是用定位的方式实现的 URI 而已。

#### 谁是谁的子集？

网上很多帖子花很大力气来表达“URL 是 URI 的子集”这一概念，感觉这实在是没有必要，反而容易歧路亡羊。

实际上，从表达的内容实体来讲，由于“URL 是用定位的方式实现的 URI”，URL 确实是 URI 的子集。

但是，从用字符串表达 URI 和 URL 的方式本身来看，名子`张三`是 URI，张三的定位方式`动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人`是 URL，直观望去，为了表达这个一长串的 URL，通常要用到表示相应 URI 的`张三`，也就是说 URI 往往是 URL 的一部分。因此，直观上可以认为“URI 是 URL 的子集”。

综上，笔者认为反复强调“URL 是 URI 的子集”这一概念实在是太无聊了。建议忘记这件事吧，返璞归真，从最朴素的视角理解相关的概念即可。

#### URL 的构成

URL 一般有以下部分组成：

```
scheme:[subscheme:]//[username:password@]host:port/path?query#fragment
```

- `scheme`: 通信协议，例如 http、https 等

- `subscheme`：子协议，可选，常用于区分数据库

    > 例子：
    >
    > - `jdbc:mysql://localhost:3306/nemo?user=root&password=123456`
    > - `jdbc:oracle:thin:@localhost:1521:nemo`
    > - `jdbc:sqlserver://localhost:1433:DatabaseName=nemo`

- `username:password`：可选，用户名密码。

    > 例子，正如命令`ssh user@127.0.0.1`：
    >
    > - http://user:123@baidu.com/login
    > - ftp://user:123@127.0.0.1
    > - telnet://user:123@127.0.0.1
    > - ssh://user:123@127.0.0.1

- `host`: 服务器的域名主机名或 IP 地址

- `port`: 端口号，可选

- `path`: 目录，由`/`隔开的字符串，表示的是主机上的目录或文件地址

- `query`: 查询，可选。可以给动态网页传递参数，用`&`隔开，每个参数的名和值用`=`隔开；

- `fragment`: 信息片段 ID，字符串，可选。用于指定网络资源中的某片断

#### HTTP 协议中的请求 URI

对于 HTTP 请求而言，通常称一个 URL 中的路径部分为**请求 URI**（request-URI)。

以 `GET /myTomcat/demo2?username=zhangsan HTTP/1.1` 为示例，请求 URI 是指 `/myTomcat/demo2`。

### 1.4 网络加密方法

以加密的手段/方法来划分，加密可分为对称密钥加密和公开密钥加密方式：

> 近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。

- 对称密钥加密：加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。

    ![image-20221011181407059](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011181407059.png)

    - 以对称密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？显然，在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义，另外还得设法安全地保管接收到的密钥：

        ![image-20221011181533029](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011181533029.png)

- 非对称密钥加密：非对称密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。非对称密钥加密也叫公开密钥加密。

    - 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

    - 另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。

        ![image-20221011181951009](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011181951009.png)

### 1.5 HTTP 概览

HTTP 协议规定，请求从客户端发出，然后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。

请求报文的构成：

![image-20221011102119184](https://figure-bed.chua-n.com/杂技/计算机网络/image-20210905164945301.png)

响应报文的构成：

![image-20221011102354273](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011102354273.png)

HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存：

![image-20221011102604097](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011102604097.png)

HTTP 协议使用 URI 定位互联网上的资源，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求 URI。例如下面`OPTIONS * HTTP/1.1`可以查询 HTTP 服务器端支持的 HTTP 方法种类。

## 2. HTTP 方法

下表列出了 HTTP/1.1 支持的方法，注意方法名区分大小写，必须使用大写字母：

|  方法   |          说明          |
| :-----: | :--------------------: |
|   GET   |        获取资源        |
|  POST   |      传输实体主体      |
|   PUT   |        传输文件        |
|  HEAD   |      获取报文首部      |
| DELETE  |        删除文件        |
| OPTIONS |     询问支持的方法     |
|  TRACE  |        追踪路径        |
| CONNECT | 要求用隧道协议连接代理 |

在 HTTP/1.1 中，所有的连接默认都是持久连接（keey-alive）：

![image-20221011103345667](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011103345667.png)

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求：

![image-20221011103704035](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011103704035.png)

## 3. HTTP 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。

HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP 报文大致可分为**报文首部**和**报文主体**两块。两者由第一个出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

![image-20221011112715447](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011112715447.png)

### 3.1 请求报文及响应报文的结构

结构划分：

![image-20221011113235286](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011113235286.png)

示例：

![image-20221011113300440](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011113300440.png)

对于请求/响应报文的首部而言：

- 请求行：包含用于请求的方法，请求 URI 和 HTTP 版本
- 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本
- 首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：
    - 通用首部
    - 请求首部
    - 响应首部
    - 实体首部
- 其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

### 3.2 报文主体 vs 实体主体

- 报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
- 实体（entity）：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

> HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。

常用的内容压缩编码有以下几种：

- gzip（GNU zip）
- compress（UNIX 系统的标准压缩）
- deflate（zlib）
- identity（不进行编码）

当然，编码也可以通过将实体主体分块的形式来进行，通过分块传输编码，可以把数据分割成多块，能够让浏览器逐步显示页面：

![image-20221011142143998](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011142143998.png)

### 3.3 发送多种数据的多部分对象集合

发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为**多部分对象集合**（Multipart）的方法，来容纳多份不同类型的数据：

![image-20221011142447040](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011142447040.png)

相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。多部分对象集合包含的对象如下：

- `multipart/form-data`：在 Web 表单文件上传时使用

- `multipart/byteranges`：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用

- `multipart/form-data`

    ```http
    Content-Type: multipart/form-data; boundary=AaB03x
    　--AaB03x
    Content-Disposition: form-data; name="field1"
    　
    Joe Blow
    --AaB03x
    Content-Disposition: form-data; name="pics"; filename="file1.txt"
    Content-Type: text/plain
    　
    ...（file1.txt 的数据）...
    --AaB03x--
    ```

- `multipart/byteranges`

    ```http
    HTTP/1.1 206 Partial Content
    Date: Fri, 13 Jul 2012 02:45:26 GMT
    Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
    Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES
    
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 500-999/8000
    
    ...（范围指定的数据）...
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 7000-7999/8000
    
    ...（范围指定的数据）...
    --THIS_STRING_SEPARATES--
    ```

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上`Content-type`；同时使用 `boundary` 字符串来划分多部分对象集合指明的各类实体，在 `boundary` 字符串指定的各个实体的起始行之前插入`--`标记，而在多部分对象集合对应的字符串的最后插入`--`标记作为结束。

多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。

### 3.4 获取部分内容的范围请求

指定范围发送的请求叫做**范围请求**（Range Request），比如，对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。

![image-20221011144814387](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011144814387.png)

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围，byte 范围的指定形式如下：

- 5001~10 000 字节

    ```http
    Range: bytes=5001-10000
    ```

- 从 5001 字节之后全部的

    ```http
    Range: bytes=5001-
    ```

- 从一开始到 3000 字节和 5000~7000 字节的多重范围

    ```http
    Range: bytes=-3000, 5000-7000
    ```

针对范围请求，响应会返回状态码为 `206 Partial Content` 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 `Content-Type` 标明 `multipart/byteranges` 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 `200 OK` 和完整的实体内容。

## 4. HTTP 状态码

HTTP 状态码（HTTP Status Code）的职责是当客户端向服务器端发送请求时，描述返回的请求结果：

![image-20221011145501308](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011145501308.png)

### 4.1 状态码分类

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：

| 状态码 |               类别               |                  作用                  |
| :----: | :------------------------------: | :------------------------------------: |
|  1**   |  Informational（信息性状态码）   | 服务器收到请求，需要请求者继续执行操作 |
|  2**   |      Success（成功状态码）       |          操作被成功接收并处理          |
|  3**   |   Redirection（重定向状态码）    |       需要进一步的操作以完成请求       |
|  4**   | Client Error（客户端错误状态码） |     请求包含语法错误或无法完成请求     |
|  5**   | Server Error（服务端错误状态码） |   服务器在处理请求的过程中发生了错误   |

只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。

### 4.2 常用状态码列表

| 状态码 |         状态码英文名称          | 中文描述                                                     |
| :----: | :-----------------------------: | :----------------------------------------------------------- |
|  100   |            Continue             | 继续。客户端应继续其请求                                     |
|  101   |       Switching Protocols       | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 |
|  200   |               OK                | 请求成功。一般用于 GET 与 POST 请求                              |
|  201   |             Created             | 已创建。成功请求并创建了新的资源                             |
|  202   |            Accepted             | 已接受。已经接受请求，但未处理完成                           |
|  203   |  Non-Authoritative Information  | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本 |
|  204   |           No Content            | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
|  205   |          Reset Content          | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
|  206   |         Partial Content         | 部分内容。服务器成功处理了部分 GET 请求                        |
|  300   |        Multiple Choices         | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
|  301   |        Moved Permanently        | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
|  302   |              Found              | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI |
|  303   |            See Other            | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看               |
|  304   |          Not Modified           | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
|  305   |            Use Proxy            | 使用代理。所请求的资源必须通过代理访问                       |
|  306   |             Unused              | 已经被废弃的 HTTP 状态码                                       |
|  307   |       Temporary Redirect        | 临时重定向。与 302 类似。使用 GET 请求重定向                     |
|  400   |           Bad Request           | 客户端请求的语法错误，服务器无法理解                         |
|  401   |          Unauthorized           | 请求要求用户的身份认证                                       |
|  402   |        Payment Required         | 保留，将来使用                                               |
|  403   |            Forbidden            | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
|  404   |            Not Found            | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
|  405   |       Method Not Allowed        | 客户端请求中的方法被禁止                                     |
|  406   |         Not Acceptable          | 服务器无法根据客户端请求的内容特性完成请求                   |
|  407   |  Proxy Authentication Required  | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权 |
|  408   |        Request Time-out         | 服务器等待客户端发送的请求时间过长，超时                     |
|  409   |            Conflict             | 服务器完成客户端的  PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
|  410   |              Gone               | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置 |
|  411   |         Length Required         | 服务器无法处理客户端发送的不带 Content-Length 的请求信息       |
|  412   |       Precondition Failed       | 客户端请求信息的先决条件错误                                 |
|  413   |    Request Entity Too Large     | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 |
|  414   |      Request-URI Too Large      | 请求的 URI 过长（URI 通常为网址），服务器无法处理               |
|  415   |     Unsupported Media Type      | 服务器无法处理请求附带的媒体格式                             |
|  416   | Requested range not satisfiable | 客户端请求的范围无效                                         |
|  417   |       Expectation Failed        | 服务器无法满足 Expect 的请求头信息                             |
|  500   |      Internal Server Error      | 服务器内部错误，无法完成请求                                 |
|  501   |         Not Implemented         | 服务器不支持请求的功能，无法完成请求                         |
|  502   |           Bad Gateway           | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
|  503   |       Service Unavailable       | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 |
|  504   |        Gateway Time-out         | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
|  505   |   HTTP Version not supported    | 服务器不支持请求的 HTTP 协议的版本，无法完成处理               |

特殊说明：

- 304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

- 401 状态码表示发送的请求需要有通过 HTTP 认证的认证信息，另外若之前已进行过 1 次请求，则表示用户认证失败

    ![image-20221011150309031](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011150309031.png)

- 403 状态码表明对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述

    ![image-20221011150519798](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011150519798.png)

## 5. HTTP 首部

在客户端与服务器之间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。

使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

### 5.1 首部字段的结构

HTTP 首部字段由首部字段名和字段值构成，中间用冒号`:`分隔，如下，其中`Content-Type`为首部字段名，字符串`text/html`表示字段值：

```http
Content-Type: text/html
```

单个 HTTP 首部字段可以有多个值，用逗号`,`分隔：

```http
Keep-Alive: timeout=15, max=100
```

> 若 HTTP 首部字段重复了会如何？
>
> 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。

### 5.2 首部字段类型

#### HTTP/1.1 规范字段

HTTP 首部字段根据实际用途被分为以下 4 种类型，同时 HTTP/1.1 规范定义了如下 47 种首部字段：

- 通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部。

    |    首部字段名     |            说明            |
    | :---------------: | :------------------------: |
    |   Cache-Control   |       控制缓存的行为       |
    |    Connection     |    逐跳首部、连接的管理    |
    |       Date        |     创建报文的日期时间     |
    |      Pragma       |          报文指令          |
    |      Trailer      |     报文末端的首部一览     |
    | Transfer-Encoding | 指定报文主体的传输编码方式 |
    |      Upgrade      |       升级为其他协议       |
    |        Via        |    代理服务器的相关信息    |
    |      Warning      |          错误通知          |

- 请求首部字段（Request Header Fields）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

    |     首部字段名      |                     说明                      |
    | :-----------------: | :-------------------------------------------: |
    |       Accept        |           用户代理可处理的媒体类型            |
    |   Accept-Charset    |                 优先的字符集                  |
    |   Accept-Encoding   |                优先的内容编码                 |
    |   Accept-Language   |            优先的语言（自然语言）             |
    |    Authorization    |                  Web 认证信息                  |
    |       Expect        |             期待服务器的特定行为              |
    |        From         |              用户的电子邮箱地址               |
    |        Host         |              请求资源所在服务器               |
    |      If-Match       |             比较实体标记（ETag）              |
    |  If-Modified-Since  |              比较资源的更新时间               |
    |    If-None-Match    |       比较实体标记（与 If-Match 相反）        |
    |      If-Range       |     资源未更新时发送实体 Byte 的范围请求      |
    | If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
    |    Max-Forwards     |                最大传输逐跳数                 |
    | Proxy-Authorization |        代理服务器要求客户端的认证信息         |
    |        Range        |              实体的字节范围请求               |
    |       Referer       |           对请求中 URI 的原始获取方           |
    |         TE          |               传输编码的优先级                |
    |     User-Agent      |             HTTP 客户端程序的信息             |

- 响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

    |     首部字段名     |             说明             |
    | :----------------: | :--------------------------: |
    |   Accept-Ranges    |     是否接受字节范围请求     |
    |        Age         |     推算资源创建经过时间     |
    |        ETag        |        资源的匹配信息        |
    |      Location      |   令客户端重定向至指定 URI    |
    | Proxy-Authenticate | 代理服务器对客户端的认证信息 |
    |    Retry-After     |   对再次发起请求的时机要求   |
    |       Server       |     HTTP 服务器的安装信息     |
    |        Vary        |   代理服务器缓存的管理信息   |
    |  WWW-Authenticate  |   服务器对客户端的认证信息   |

- 实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

    |    首部字段名    |             说明             |
    | :--------------: | :--------------------------: |
    |      Allow       |     资源可支持的 HTTP 方法     |
    | Content-Encoding |    实体主体适用的编码方式    |
    | Content-Language |      实体主体的自然语言      |
    |  Content-Length  | 实体主体的大小（单位：字节） |
    | Content-Location |      替代对应资源的 URI       |
    |   Content-MD5    |      实体主体的报文摘要      |
    |  Content-Range   |      实体主体的位置范围      |
    |   Content-Type   |      实体主体的媒体类型      |
    |     Expires      |    实体主体过期的日期时间    |
    |  Last-Modified   |    资源的最后修改日期时间    |

此外，根据缓存代理和非缓存代理的行为区别，HTTP 首部字段可以分为 2 种类型：

- 逐跳首部（Hop-by-hop Header）：此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。逐跳首部字段有：
    - Connection
    - Keep-Alive
    - Proxy-Authenticate
    - Proxy-Authorization
    - Trailer
    - TE
    - Transfer-Encoding
    - Upgrade
- 端到端首部（End-to-end Header）：此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。除了上述 8 个逐跳首部字段，其他所有字段都属于端到端首部

#### 非 HTTP/1.1 首部字段

在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。

这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。

- Content-disposition：服务器告诉客户端以什么格式打开响应数据。

  - inline：默认值，在当前页面内打开
  - attachment; filename=xxx：以附件形式打开响应体，即文件下载

### 5.3 首部字段作用详情

> 参考《图解 HTTP》等资料吧。

## 6. Web 服务器的类型

一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。

HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道，它们可以配合服务器工作。

持有资源实体的服务器被称为**源服务器**。

### 6.1 单台主机绑定多个域名

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。在技术实现上，即使物理层面只有一台服务器，但只要使用虚拟主机（Virtual Host，又称虚拟服务器）的功能，则可以假想已具有多台服务器。

在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名：

![image-20221011151406872](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011151406872.png)

在相同的 IP 地址下，由于物理主机可以寄存多个不同虚拟主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

### 6.2 代理

**代理**是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。

![image-20221011151924781](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011151924781.png)

从源服务器返回的响应经过代理服务器后再传给客户端（每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息）：

![image-20221011151945029](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011151945029.png)

使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，获取访问日志等等。

代理有多种使用方法，按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文：

- 缓存/非缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
- 透明/非透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理；反之，对报文内容进行加工的代理被称为非透明代理。

### 6.3 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。

网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非 HTTP 协议服务：

![image-20221011152504827](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011152504827.png)

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

### 6.4 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器，可以认为隧道是透明的。

![image-20221011152651684](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011152651684.png)

隧道会在通信双方断开连接时结束。

## 7. 使用 Cookie 的状态管理

不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里：

![image-20221011110408327](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011110408327.png)

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

- 没有 Cookie 信息状态下的请求

  ![image-20221011110551890](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011110551890.png)

- 第 2 次以后（存有 Cookie 信息状态）的请求

  ![image-20221011110600103](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011110600103.png)

有了 Cookie 后，HTTP 请求报文和响应报文的内容发生的变化如下：

- 请求报文（没有 Cookie 信息的状态）

  ```http
  GET /reader/ HTTP/1.1
  Host: hackr.js
  * 首部字段内没有 Cookie 的相关信息
  ```

- 响应报文（服务器端生成 Cookie 信息）

  ```http
  HTTP/1.1 200 OK
  Date: Thu, 12 Jul 2012 07:12:20 GMT
  Server: Apache
  <Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT>
  Content-Type: text/plain; charset=UTF-8
  ```

- 请求报文（自动发送保存着的 Cookie 信息）

  ```http
  GET /image/ HTTP/1.1
  Host: hackr.jp
  Cookie: sid=1342077140226724
  ```

## 8. 用户身份认证

> 参考自 [HTTP authentication - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication)

### 8.1 概述

计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。

通常通过核对以下信息来核实用户信息（但是，即便对方是假冒的用户，只要能通过用户验证，那么计算机就会默认是出自本人的行为。因此，掌控机密信息的密码绝不能让他人得到，更不能轻易地就被破解出来）：

- 密码：只有本人才会知道的字符串信息
- 动态令牌：仅限本人持有的设备内显示的一次性密码
- 数字证书：仅限本人（终端）持有的信息
- 生物认证：指纹和虹膜等本人的生理信息
- IC 卡等：仅限本人持有的信息

HTTP 有 7 种最常见的用来承载用户相关信息的 HTTP 请求首部：

|    首部名称     |   首部类型   |                 描述                 |
| :-------------: | :----------: | :----------------------------------: |
|      From       |     请求     |          用户的 E-mail 地址           |
|   User-Agent    |     请求     |           用户的浏览器软件           |
|     Referer     |     请求     | 用户是从这个页面上依照链接跳转过来的 |
|  Authorization  |     请求     |             用户名和密码             |
|    Client-IP    | 扩展（请求） |           客户端的 IP 地址           |
| X-Forwarded-For | 扩展（请求） |           客户端的 IP 地址           |
|     Cookie      | 扩展（请求） |         服务器产生的 ID 标签         |

不考虑使用用户 IP 地址、email 地址等这些明显带有缺陷的方式。Web 服务器无需被动地根据用户的 IP 地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证（登录）来显式地询问用户是谁。这里边主要有两种方式（哥们自己这么总结认为的）：

- 一种是 Cookie 的方式，这里不再赘述；
- 另一种是，为了使 Web 站点的登录更加简便，HTTP 中包含了一种内建机制，可以借助 `WWW-Authenticate` 响应首部和 `Authorization` 请求首部向 Web 站点传送用户的相关信息。一旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了，这样，就总是有登录信息可用了。

这里着重阐述使用 `Authorization` 的方式。

### 8.2 HTTP 的质询/响应认证框架

[RFC 7235](https://datatracker.ietf.org/doc/html/rfc7235) 定义了一个 HTTP 身份验证框架——质询/ 响应（challenge/response）框架。服务器可以质询（challenge）客户端的请求，客户端则可以提供身份验证凭据。

质询与响应的工作流程整体可示意如下：

![img](https://figure-bed.chua-n.com/杂技/计算机网络/http-auth-sequence-diagram.png)

1. 客户端发起请求；
2. 服务器端向客户端返回 `401`（Unauthorized，未被授权的）响应状态码，并在 `WWW-Authenticate` 响应标头提供如何进行验证的信息，其中至少包含有一种质询方式；
3. 之后，想要使用服务器对自己身份进行验证的客户端，可以通过包含凭据的 `Authorization` 请求标头进行验证；
4. 通常，客户端会向用户显示密码提示，然后发送包含正确的 `Authorization` 标头的请求。

与上述同样的质询/响应原理也适用于代理认证。由于资源认证和代理认证可以并存，为了在标头和响应状态码上进行区别，对于代理，质询的状态码是 `407`（必须提供代理证书），响应标头 `Proxy-Authenticate` 至少包含一个可用的质询，并且用请求标头 `Proxy-Authorization` 向代理服务器提供凭据。

如果（代理）服务器收到无效的凭据，它应该响应 `401 Unauthorized` 或 `407 Proxy Authentication Required`，此时用户可以发送新的请求或替换 `Authorization` 标头字段；如果（代理）服务器接受的有效凭据不足以访问给定的资源，服务器将响应 `403 Forbidden` 状态码，与 `401 Unauthorized` 或 `407 Proxy Authentication Required` 不同的是，该用户无法进行身份验证并且浏览器不会提出新的的尝试。然而，很多情况下，服务器也可能返回 `404 Not Found` 状态码，以向没有足够权限或者未正确身份验证的用户隐藏页面的存在。

### 8.3 首部字段

`WWW-Authenticate` 与 `Proxy-Authenticate` 响应标头指定了为获取资源访问权限而进行身份验证的方法。它们需要明确要进行验证的方案，这样希望进行授权的客户端就知道该如何提供凭据。

这两个标头的语法形式如下：

```
WWW-Authenticate: <type> realm=<realm>
Proxy-Authenticate: <type> realm=<realm>
```

> 其中：
>
> - `<type>` 指的是验证的方案（如 `Basic`）
> - `<realm>` 用来描述进行保护的区域，或者指代保护的范围。它可以是类似于“Access to the staging site”的消息，这样用户就可以知道他们正在试图访问哪一空间。

`Authorization` 与 `Proxy-Authorization` 请求标头包含有用来向（代理）服务器证明用户代理身份的凭据。这里同样需要指明验证的 `<type>`，其后跟有凭据信息，该凭据信息可以被编码或者加密，取决于采用的是哪种认证方案。

```
Authorization: <type> <credentials>
Proxy-Authorization: <type> <credentials>
```

### 8.4 认证方案

HTTP 的质询/响应身份认证框架有多种认证方案（Authentication scheme）。不同的认证方案在安全强度以及在客户端或服务器端软件中可获得的难易程度上有所不同。常见的认证方案包括：

- `Basic`：参见 [RFC 7617](https://datatracker.ietf.org/doc/html/rfc7617)，base64 编码凭据，其实就是将由冒号`:`分隔的用户名和密码打包在一起，并用 Base-64 编码方式对其进行编码，即：$Base64(username:password)$
- `Digest`：参见 [RFC 7616](https://datatracker.ietf.org/doc/html/rfc7616)，Firefox 93 及更高版本支持 SHA-256 算法。以前的版本仅支持 MD5 散列（不建议）。
- `Bearer`：参见 [RFC 6750](https://datatracker.ietf.org/doc/html/rfc6750)，bearer 令牌通过 OAuth 2.0 保护资源。
- `HOBA`：参见 [RFC 7486](https://datatracker.ietf.org/doc/html/rfc7486)，阶段三，**H**TTP **O**rigin-**B**ound 认证，基于数字签名。
- `Mutual`：参见 [RFC 8120](https://datatracker.ietf.org/doc/html/rfc8120)
- `Negotiate / NTLM`：参见 [RFC4599](https://www.ietf.org/rfc/rfc4559.txt)
- `VAPID`：参见 [RFC 8292](https://datatracker.ietf.org/doc/html/rfc8292)
- `SCRAM`：参见 [RFC 7804](https://datatracker.ietf.org/doc/html/rfc7804)
- ...

## 9. HTTP 的不足与应对策略

### 9.1 不足

HTTP 主要有这些不足，例举如下：

> 这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。

- HTTP 通信使用明文（不加密），内容可能会被窃听——TCP/IP 是可能被窃听的网络，互联网上的任何角落都存在通信内容被窃听的风险：

    > 窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。

    ![image-20221011171033531](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011171033531.png)

- HTTP 不验证通信方的身份，因此有可能遭遇伪装——存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题：

    - 任何人都可发起请求：

        ![image-20221011171918383](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011171918383.png)

    - 类似地，无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器

    - 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）

- 无法证明报文的完整性，所以有可能已遭篡改——由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉：

    ![image-20221011172626008](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011172626008.png)

    > 这里所谓完整性是指信息的准确度。淦，那为什么不直接使用准确性这一术语呢？？？
    >
    > 像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）：
    >
    > ![image-20221011172725360](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011172725360.png)

### 9.2 应对策略之加密

以加密的目标对象来划分，加密可分为加密通信方式和加密通信内容两种：

- 加密通信方式：HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。

    ![image-20221011171329023](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011171329023.png)

- 加密通信内容：还有一种将参与通信的内容本身加密的方式，即把 HTTP 报文里所含的内容进行加密处理。但是，这种方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。

    ![image-20221011171415678](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011171415678.png)

### 9.3 应对策略之通信方身份的认证

虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。

证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。

![image-20221011172300412](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011172300412.png)

通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。

另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。

### 9.4 应对策略之完整性保护

虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。

提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查。然而，即便如此，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。

## 10. HTTPS

$$
HTTPS = HTTP + 加密 + 认证 + 完整性保护
$$

为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。

![image-20221011173848565](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011173848565.png)

### 10.1 HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP：

![image-20221011174346307](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011174346307.png)

在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。

> SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

### 10.2 加密技术

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。

若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

![image-20221011211411788](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011211411788.png)

### 10.3 证明公开密钥正确性的证书

遗憾的是，公开密钥加密方式还是存在一些问题的，那就是无法证明公开密钥本身就是货真价实的公开密钥。

#### 确认服务端的服务器端证书

比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。

为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

![image-20221011212102392](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011212102392.png)

#### 确认客户端的客户端证书

HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。

但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。

想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。

现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。

客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。

### 10.4 HTTPS 的安全通信机制

下图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程：

![image-20221011213320111](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011213001531.png)

### 10.5 HTTPS 的缺点

HTTPS 也存在一些问题，那就是由于使用了 SSL，它的处理速度变慢了。

SSL 的慢分两种：

- 通信慢：和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。
- 处理速度慢：SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。

针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。

## 11. 基于 HTTP 的追加协议

在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML 文档的协议。随着时代的发展，Web 的用途更具多样性，比如演化成在线购物网站、SNS（Social Networking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。

而这些网站所追求的功能可通过 Web 应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为 HTTP 协议上的限制以及自身性能有限。

HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。

### 11.1 HTTP 的瓶颈

若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈：

> 有的是在 HTTP/1.1 之前的版本才算问题吧。.....

- 一条连接上只可发送一个请求
- 请求只能从客户端开始，客户端不可以接收除响应以外的指令
- 请求/响应首部未经压缩就发送。首部信息越多延迟越大
- 发送冗长的首部，每次互相发送相同的首部造成的浪费较多
- 可任意选择数据压缩格式，非强制压缩发送

#### Ajax 的解决办法

Ajax（Asynchronous JavaScript and XML，异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。

Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。

和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

![image-20221011222416357](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011222416357.png)

而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。

然而无论如何，Ajax 仍未解决 HTTP 协议本身存在的问题。

#### Comet 通信

> 具体情况需要时再说吧，总之仍未解决 HTTP 协议本身存在的问题。

![image-20221011222528103](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011222528103.png)

### 11.2 SPDY 协议

SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但进展不佳，以后再说吧。.....

### 11.3 WebSocket 协议

WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可**互相**发送 JSON、XML、HTML 或图片等任意格式的据。

由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

WebSocket 协议的主要特点为：

- 推送功能：支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
- 减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。

WebSocket 连接建立的过程如下图：

![image-20221011223218218](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011223218218.png)

### 11.4 HTTP/2.0

广泛应用了再说吧。.....

## 12. Web 的攻击技术

对 Web 应用的攻击模式有两种：

- 主动攻击：主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。
    - 由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。
    - 主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。
- 被动攻击：被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。
    - 被动攻击通常的攻击模式为：
        - 步骤 1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。
        - 步骤 2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。
        - 步骤 3： 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。
        - 步骤 4： 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。
    - 被动攻击模式中具有代表性的攻击是跨站脚本攻击（Cross-Site Scripting，XSS）和跨站点请求伪造（Cross-Site Request Forgeries，CSRF）。

### 12.1 输出值转义引发的安全漏洞

实施 Web 应用的安全对策可大致分为以下两部分：

![image-20221011225017668](https://figure-bed.chua-n.com/杂技/计算机网络/image-20221011225017668.png)

- 客户端的验证
- Web 应用端（服务器端）的验证
    - 输入值验证
    - 输出值转义

#### 跨站脚本攻击

跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。

#### SQL 注入攻击

SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。

#### OS 命令注入攻击

OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。

#### HTTP 首部注入攻击

HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。

#### 邮件首部注入攻击

邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。

#### 目录遍历攻击

目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。

通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用 .../ 等相对路径定位到 /etc/passed 等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。

#### 远程文件包含漏洞

远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。

这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。但是，该功能太危险，PHP5.2.0 之后默认设定此功能无效。

### 12.2 程序设计缺陷引发的安全漏洞

#### 强制浏览

强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。

#### 不正确的错误消息处理

不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如：

- Web 应用抛出的错误消息
- 数据库等系统抛出的错误消息

Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。

#### 开放重定向

开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。

### 12.3 因会话管理疏忽引发的安全漏洞

#### 会话劫持

会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。

#### 会话固定攻击

对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。

#### 跨站点请求伪造

跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。

### 12.4 其他安全漏洞

#### 密码破解

无须多言了吧......

#### 点击劫持

点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。

已设置陷阱的 Web 页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的 iframe 页面。

#### DoS 攻击

DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。

主要有以下两种 DoS 攻击方式：

- 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态；
- 通过攻击安全漏洞使服务停止。

其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。

多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。

#### 后门程序

后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。

通常的后门程序分为以下 3 种类型：

- 开发阶段作为 Debug 调用的后门程序
- 开发者为了自身利益植入的后门程序
- 攻击者通过某种方法设置的后门程序

可通过监视进程和通信的状态发现被植入的后门程序。但设定在 Web 应用中的后门程序，由于和正常使用时区别不大，通常很难发现。
