---
title: 并发编程
---

## 进程与线程

**多任务**：现代操作系统比如 Mac OS X, UNIX, Linux, Windows 等，都是支持“多任务”的操作系统。简单地说，多任务就是操作系统可以同时运行多个任务，如，你可以边用浏览器上网，边听 MP3，边用 Word 赶作业，这里至少同时有 3 个任务正在运行，其实还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。

真正的并行任务只能在多核 CPU 上实现。但是由于任务数量远远多于 CPU 的核心数量，所以操作系统也自动把很多任务轮流调度到每个核心上执行。

进程(Process)：对于操作系统来说，一个任务就是一个进程。比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就是启动一个记事本进程，打开两个记事本就是启动了两个记事本进程。

线程(Thread)：在一个进程内部，要同时干多件事，需要运行多个子任务，这些进程内的子任务就是线程。比如 Word 可以同时进行打字、打写检查、打印等事情。

一个进程至少会有一个线程。当然，像 Word 这样复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程（多任务）是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程也是需要多核 CPU 才能实现。

## GIL

global interpreter lock(全局解释器锁)：

1. CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性；

2. 不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL；

3. 创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。

## 多任务编程

通常编写的 python 程序都是执行单任务的进程，也就是只有一个线程。

若要执行多任务：

1. 多进程模式；

2. 多线程模式；

3. 多进程+多线程模式。

通常要执行的多任务的各个任务之间不是没有关联的，需要相互通信和协调，有时任务 1 必须暂停等待任务 2 完成后才能继续执行，有时任务 3 和任务 4 又不能同时执行，所以编写多进程和多线程的程序其复杂度远远高于通常编写的单进程单线程的程序。

Python 既支持多进程，又支持多线程。
