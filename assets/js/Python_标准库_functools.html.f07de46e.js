"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[72261],{84008:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  comp: () => (/* reexport */ functools_html),\n  data: () => (/* binding */ data)\n});\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\nvar runtime_core_esm_bundler = __webpack_require__(6254);\n;// ./node_modules/.pnpm/vue-loader@17.4.2_vue@3.5.13_webpack@5.97.1/node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/.pnpm/@vuepress+bundler-webpack@2.0.0-rc.18/node_modules/@vuepress/bundler-webpack/dist/vuepress-ssr-loader.cjs!./node_modules/.pnpm/vue-loader@17.4.2_vue@3.5.13_webpack@5.97.1/node_modules/vue-loader/dist/index.js??ruleSet[0].use[1]!./book/.vuepress/.temp/pages/Python/标准库/functools.html.vue?vue&type=template&id=19b0913c\n\n\nfunction render(_ctx, _cache) {\n  return ((0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", null, _cache[0] || (_cache[0] = [\n    (0,runtime_core_esm_bundler/* createStaticVNode */.Fv)("<p>关于functools标准库：</p><blockquote><p>&gt;&gt;&gt; help(functools)</p><p>Help on module functools:</p><p>NAME</p><p>functools - <a href=\\"http://functools.py\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">functools.py</a> - Tools for working with functions and callable objects</p><p>CLASSES</p><p>builtins.object</p><p>​ partial</p><p>​ partialmethod</p><p>class partial(builtins.object)</p><p>| partial(func, *args, **keywords) - new function with partial application</p><p>| of the given arguments and keywords.</p><p>|</p><p>| Methods defined here:</p><p>|</p><p>| <strong>call</strong>(self, /, *args, **kwargs)</p><p>| Call self as a function.</p><p>|</p><p>| <strong>delattr</strong>(self, name, /)</p><p>| Implement delattr(self, name).</p><p>|</p><p>| <strong>getattribute</strong>(self, name, /)</p><p>| Return getattr(self, name).</p><p>|</p><p>| <strong>reduce</strong>(...)</p><p>| Helper for pickle.</p><p>|</p><p>| <strong>repr</strong>(self, /)</p><p>| Return repr(self).</p><p>|</p><p>| <strong>setattr</strong>(self, name, value, /)</p><p>| Implement setattr(self, name, value).</p><p>|</p><p>| <strong>setstate</strong>(...)</p><p>|</p><p>| ----------------------------------------------------------------------</p><p>| Static methods defined here:</p><p>|</p><p>| <strong>new</strong>(*args, **kwargs) from builtins.type</p><p>| Create and return a new object. See help(type) for accurate signature.</p><p>|</p><p>| ----------------------------------------------------------------------</p><p>| Data descriptors defined here:</p><p>|</p><p>| <strong>dict</strong></p><p>|</p><p>| args</p><p>| tuple of arguments to future partial calls</p><p>|</p><p>| func</p><p>| function object to use in future partial calls</p><p>|</p><p>| keywords</p><p>| dictionary of keyword arguments to future partial calls</p><p>class partialmethod(builtins.object)</p><p>| partialmethod(func, *args, **keywords)</p><p>|</p><p>| Method descriptor with partial application of the given arguments</p><p>| and keywords.</p><p>|</p><p>| Supports wrapping existing descriptors and handles non-descriptor</p><p>| callables as instance methods.</p><p>|</p><p>| Methods defined here:</p><p>|</p><p>| <strong>get</strong>(self, obj, cls)</p><p>|</p><p>| <strong>init</strong>(self, func, *args, **keywords)</p><p>| Initialize self. See help(type(self)) for accurate signature.</p><p>|</p><p>| <strong>repr</strong>(self)</p><p>| Return repr(self).</p><p>|</p><p>| ----------------------------------------------------------------------</p><p>| Data descriptors defined here:</p><p>|</p><p>| <strong>dict</strong></p><p>| dictionary for instance variables (if defined)</p><p>|</p><p>| <strong>isabstractmethod</strong></p><p>|</p><p>| <strong>weakref</strong></p><p>| list of weak references to the object (if defined)</p><p>FUNCTIONS</p><p>cmp_to_key(...)</p><p>​ Convert a cmp= function into a key= function.</p><p>lru_cache(maxsize=128, typed=False)</p><p>​ Least-recently-used cache decorator.</p><p>​ If <em>maxsize</em> is set to None, the LRU features are disabled and the cache</p><p>​ can grow without bound.</p><p>​ If <em>typed</em> is True, arguments of different types will be cached separately.</p><p>​ For example, f(3.0) and f(3) will be treated as distinct calls with</p><p>​ distinct results.</p><p>​ Arguments to the cached function must be hashable.</p><p>​ View the cache statistics named tuple (hits, misses, maxsize, currsize)</p><p>​ with f.cache_info(). Clear the cache and statistics with f.cache_clear().</p><p>​ Access the underlying function with f.<strong>wrapped</strong>.</p><p>​ See: <a href=\\"http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used</a></p><p>reduce(...)</p><p>​ reduce(function, sequence[, initial]) -&gt; value</p><p>​ Apply a function of two arguments cumulatively to the items of a sequence,</p><p>​ from left to right, so as to reduce the sequence to a single value.</p><p>​ For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates</p><p>​ ((((1+2)+3)+4)+5). If initial is present, it is placed before the items</p><p>​ of the sequence in the calculation, and serves as a default when the</p><p>​ sequence is empty.</p><p>singledispatch(func)</p><p>​ Single-dispatch generic function decorator.</p><p>​ Transforms a function into a generic function, which can have different</p><p>​ behaviours depending upon the type of its first argument. The decorated</p><p>​ function acts as the default implementation, and additional</p><p>​ implementations can be registered using the register() attribute of the</p><p>​ generic function.</p><p>total_ordering(cls)</p><p>​ Class decorator that fills in missing ordering methods</p><p>update_wrapper(wrapper, wrapped, assigned=(&#39;<strong>module</strong>&#39;, &#39;<strong>name</strong>&#39;, &#39;<strong>qualname</strong>&#39;, &#39;<strong>doc</strong>&#39;, &#39;<strong>annotations</strong>&#39;), updated=(&#39;<strong>dict</strong>&#39;,))</p><p>​ Update a wrapper function to look like the wrapped function</p><p>​ wrapper is the function to be updated</p><p>​ wrapped is the original function</p><p>​ assigned is a tuple naming the attributes assigned directly</p><p>​ from the wrapped function to the wrapper function (defaults to</p><p>​ functools.WRAPPER_ASSIGNMENTS)</p><p>​ updated is a tuple naming the attributes of the wrapper that</p><p>​ are updated with the corresponding attribute from the wrapped</p><p>​ function (defaults to functools.WRAPPER_UPDATES)</p><p>wraps(wrapped, assigned=(&#39;<strong>module</strong>&#39;, &#39;<strong>name</strong>&#39;, &#39;<strong>qualname</strong>&#39;, &#39;<strong>doc</strong>&#39;, &#39;<strong>annotations</strong>&#39;), updated=(&#39;<strong>dict</strong>&#39;,))</p><p>​ Decorator factory to apply update_wrapper() to a wrapper function</p><p>​ Returns a decorator that invokes update_wrapper() with the decorated</p><p>​ function as the wrapper argument and the arguments to wraps() as the</p><p>​ remaining arguments. Default arguments are as for update_wrapper().</p><p>​ This is a convenience function to simplify applying partial() to</p><p>​ update_wrapper().</p><p>DATA</p><p>WRAPPER_ASSIGNMENTS = (&#39;<strong>module</strong>&#39;, &#39;<strong>name</strong>&#39;, &#39;<strong>qualname</strong>&#39;, &#39;__do...</p><p>WRAPPER_UPDATES = (&#39;<strong>dict</strong>&#39;,)</p><p><strong>all</strong> = [&#39;update_wrapper&#39;, &#39;wraps&#39;, &#39;WRAPPER_ASSIGNMENTS&#39;, &#39;WRAPPER_...</p><p>FILE</p><p>d:\\\\programdata\\\\anaconda3\\\\lib\\\\functools.py</p></blockquote><p>装饰器<code>functools.total_ordering</code>可以简化实现让类支持比较的操作，见“类”页面笔记。</p><p>任何时候你定义装饰器的时候，都应该使用<code>functools</code>库中的 <code>@wraps</code> 装饰器来注解底层包装函数。见“元编程”页面笔记。</p><p><code>functools.partial()</code>函数就是帮助我们创建一个偏函数的，见“函数”页面笔记。</p>", 5)\n  ])))\n}\n// EXTERNAL MODULE: ./node_modules/.pnpm/vue-loader@17.4.2_vue@3.5.13_webpack@5.97.1/node_modules/vue-loader/dist/exportHelper.js\nvar exportHelper = __webpack_require__(81021);\n;// ./book/.vuepress/.temp/pages/Python/标准库/functools.html.vue\n\nconst script = {}\n\n;\nconst __exports__ = /*#__PURE__*/(0,exportHelper/* default */.A)(script, [[\'render\',render]])\n\n/* harmony default export */ const functools_html = (__exports__);\n;// ./book/.vuepress/.temp/pages/Python/标准库/functools.html.js\n\nconst data = JSON.parse("{\\"path\\":\\"/Python/%E6%A0%87%E5%87%86%E5%BA%93/functools.html\\",\\"title\\":\\"functools\\",\\"lang\\":\\"zh-CN\\",\\"frontmatter\\":{\\"title\\":\\"functools\\",\\"date\\":\\"2019-06-06T00:00:00.000Z\\",\\"description\\":\\"关于functools标准库： >>> help(functools) Help on module functools: NAME functools - functools.py - Tools for working with functions and callable objects CLASSES builtins.object ​ par...\\",\\"head\\":[[\\"meta\\",{\\"property\\":\\"og:url\\",\\"content\\":\\"https://chua-n.com/Python/%E6%A0%87%E5%87%86%E5%BA%93/functools.html\\"}],[\\"meta\\",{\\"property\\":\\"og:site_name\\",\\"content\\":\\"荒流的笔趣屋\\"}],[\\"meta\\",{\\"property\\":\\"og:title\\",\\"content\\":\\"functools\\"}],[\\"meta\\",{\\"property\\":\\"og:description\\",\\"content\\":\\"关于functools标准库： >>> help(functools) Help on module functools: NAME functools - functools.py - Tools for working with functions and callable objects CLASSES builtins.object ​ par...\\"}],[\\"meta\\",{\\"property\\":\\"og:type\\",\\"content\\":\\"article\\"}],[\\"meta\\",{\\"property\\":\\"og:locale\\",\\"content\\":\\"zh-CN\\"}],[\\"meta\\",{\\"property\\":\\"og:updated_time\\",\\"content\\":\\"2024-04-02T13:51:27.000Z\\"}],[\\"meta\\",{\\"property\\":\\"article:published_time\\",\\"content\\":\\"2019-06-06T00:00:00.000Z\\"}],[\\"meta\\",{\\"property\\":\\"article:modified_time\\",\\"content\\":\\"2024-04-02T13:51:27.000Z\\"}],[\\"script\\",{\\"type\\":\\"application/ld+json\\"},\\"{\\\\\\"@context\\\\\\":\\\\\\"https://schema.org\\\\\\",\\\\\\"@type\\\\\\":\\\\\\"Article\\\\\\",\\\\\\"headline\\\\\\":\\\\\\"functools\\\\\\",\\\\\\"image\\\\\\":[\\\\\\"\\\\\\"],\\\\\\"datePublished\\\\\\":\\\\\\"2019-06-06T00:00:00.000Z\\\\\\",\\\\\\"dateModified\\\\\\":\\\\\\"2024-04-02T13:51:27.000Z\\\\\\",\\\\\\"author\\\\\\":[{\\\\\\"@type\\\\\\":\\\\\\"Person\\\\\\",\\\\\\"name\\\\\\":\\\\\\"荒流\\\\\\",\\\\\\"url\\\\\\":\\\\\\"https://chua-n.com\\\\\\",\\\\\\"email\\\\\\":\\\\\\"chua_n@qq.com\\\\\\"}]}\\"]]},\\"headers\\":[],\\"git\\":{\\"createdTime\\":1642689062000,\\"updatedTime\\":1712065887000,\\"contributors\\":[{\\"name\\":\\"chua-n\\",\\"email\\":\\"chua_n@yeah.net\\",\\"commits\\":3}]},\\"readingTime\\":{\\"minutes\\":2.44,\\"words\\":732},\\"filePathRelative\\":\\"Python/标准库/functools.md\\",\\"localizedDate\\":\\"2019年6月6日\\",\\"excerpt\\":\\"<p>关于functools标准库：</p>\\\\n<blockquote>\\\\n<p>&gt;&gt;&gt; help(functools)</p>\\\\n<p>Help on module functools:</p>\\\\n<p>NAME</p>\\\\n<p>functools - <a href=\\\\\\"http://functools.py\\\\\\" target=\\\\\\"_blank\\\\\\" rel=\\\\\\"noopener noreferrer\\\\\\">functools.py</a> - Tools for working with functions and callable objects</p>\\\\n<p>CLASSES</p>\\\\n<p>builtins.object</p>\\\\n<p>​    partial</p>\\\\n<p>​    partialmethod</p>\\\\n<p>class partial(builtins.object)</p>\\\\n<p>| partial(func, *args, **keywords) - new function with partial application</p>\\\\n<p>| of the given arguments and keywords.</p>\\\\n<p>|</p>\\\\n<p>| Methods defined here:</p>\\\\n<p>|</p>\\\\n<p>| <strong>call</strong>(self, /, *args, **kwargs)</p>\\\\n<p>|   Call self as a function.</p>\\\\n<p>|</p>\\\\n<p>| <strong>delattr</strong>(self, name, /)</p>\\\\n<p>|   Implement delattr(self, name).</p>\\\\n<p>|</p>\\\\n<p>| <strong>getattribute</strong>(self, name, /)</p>\\\\n<p>|   Return getattr(self, name).</p>\\\\n<p>|</p>\\\\n<p>| <strong>reduce</strong>(...)</p>\\\\n<p>|   Helper for pickle.</p>\\\\n<p>|</p>\\\\n<p>| <strong>repr</strong>(self, /)</p>\\\\n<p>|   Return repr(self).</p>\\\\n<p>|</p>\\\\n<p>| <strong>setattr</strong>(self, name, value, /)</p>\\\\n<p>|   Implement setattr(self, name, value).</p>\\\\n<p>|</p>\\\\n<p>| <strong>setstate</strong>(...)</p>\\\\n<p>|</p>\\\\n<p>| ----------------------------------------------------------------------</p>\\\\n<p>| Static methods defined here:</p>\\\\n<p>|</p>\\\\n<p>| <strong>new</strong>(*args, **kwargs) from builtins.type</p>\\\\n<p>|   Create and return a new object. See help(type) for accurate signature.</p>\\\\n<p>|</p>\\\\n<p>| ----------------------------------------------------------------------</p>\\\\n<p>| Data descriptors defined here:</p>\\\\n<p>|</p>\\\\n<p>| <strong>dict</strong></p>\\\\n<p>|</p>\\\\n<p>| args</p>\\\\n<p>|   tuple of arguments to future partial calls</p>\\\\n<p>|</p>\\\\n<p>| func</p>\\\\n<p>|   function object to use in future partial calls</p>\\\\n<p>|</p>\\\\n<p>| keywords</p>\\\\n<p>|   dictionary of keyword arguments to future partial calls</p>\\\\n<p>class partialmethod(builtins.object)</p>\\\\n<p>| partialmethod(func, *args, **keywords)</p>\\\\n<p>|</p>\\\\n<p>| Method descriptor with partial application of the given arguments</p>\\\\n<p>| and keywords.</p>\\\\n<p>|</p>\\\\n<p>| Supports wrapping existing descriptors and handles non-descriptor</p>\\\\n<p>| callables as instance methods.</p>\\\\n<p>|</p>\\\\n<p>| Methods defined here:</p>\\\\n<p>|</p>\\\\n<p>| <strong>get</strong>(self, obj, cls)</p>\\\\n<p>|</p>\\\\n<p>| <strong>init</strong>(self, func, *args, **keywords)</p>\\\\n<p>|   Initialize self. See help(type(self)) for accurate signature.</p>\\\\n<p>|</p>\\\\n<p>| <strong>repr</strong>(self)</p>\\\\n<p>|   Return repr(self).</p>\\\\n<p>|</p>\\\\n<p>| ----------------------------------------------------------------------</p>\\\\n<p>| Data descriptors defined here:</p>\\\\n<p>|</p>\\\\n<p>| <strong>dict</strong></p>\\\\n<p>|   dictionary for instance variables (if defined)</p>\\\\n<p>|</p>\\\\n<p>| <strong>isabstractmethod</strong></p>\\\\n<p>|</p>\\\\n<p>| <strong>weakref</strong></p>\\\\n<p>|   list of weak references to the object (if defined)</p>\\\\n<p>FUNCTIONS</p>\\\\n<p>cmp_to_key(...)</p>\\\\n<p>​    Convert a cmp= function into a key= function.</p>\\\\n<p>lru_cache(maxsize=128, typed=False)</p>\\\\n<p>​    Least-recently-used cache decorator.</p>\\\\n<p>​    If <em>maxsize</em> is set to None, the LRU features are disabled and the cache</p>\\\\n<p>​    can grow without bound.</p>\\\\n<p>​    If <em>typed</em> is True, arguments of different types will be cached separately.</p>\\\\n<p>​    For example, f(3.0) and f(3) will be treated as distinct calls with</p>\\\\n<p>​    distinct results.</p>\\\\n<p>​    Arguments to the cached function must be hashable.</p>\\\\n<p>​    View the cache statistics named tuple (hits, misses, maxsize, currsize)</p>\\\\n<p>​    with f.cache_info(). Clear the cache and statistics with f.cache_clear().</p>\\\\n<p>​    Access the underlying function with f.<strong>wrapped</strong>.</p>\\\\n<p>​    See: <a href=\\\\\\"http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used\\\\\\" target=\\\\\\"_blank\\\\\\" rel=\\\\\\"noopener noreferrer\\\\\\">http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used</a></p>\\\\n<p>reduce(...)</p>\\\\n<p>​    reduce(function, sequence[, initial]) -&gt; value</p>\\\\n<p>​    Apply a function of two arguments cumulatively to the items of a sequence,</p>\\\\n<p>​    from left to right, so as to reduce the sequence to a single value.</p>\\\\n<p>​    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates</p>\\\\n<p>​    ((((1+2)+3)+4)+5). If initial is present, it is placed before the items</p>\\\\n<p>​    of the sequence in the calculation, and serves as a default when the</p>\\\\n<p>​    sequence is empty.</p>\\\\n<p>singledispatch(func)</p>\\\\n<p>​    Single-dispatch generic function decorator.</p>\\\\n<p>​    Transforms a function into a generic function, which can have different</p>\\\\n<p>​    behaviours depending upon the type of its first argument. The decorated</p>\\\\n<p>​    function acts as the default implementation, and additional</p>\\\\n<p>​    implementations can be registered using the register() attribute of the</p>\\\\n<p>​    generic function.</p>\\\\n<p>total_ordering(cls)</p>\\\\n<p>​    Class decorator that fills in missing ordering methods</p>\\\\n<p>update_wrapper(wrapper, wrapped, assigned=(\'<strong>module</strong>\', \'<strong>name</strong>\', \'<strong>qualname</strong>\', \'<strong>doc</strong>\', \'<strong>annotations</strong>\'), updated=(\'<strong>dict</strong>\',))</p>\\\\n<p>​    Update a wrapper function to look like the wrapped function</p>\\\\n<p>​    wrapper is the function to be updated</p>\\\\n<p>​    wrapped is the original function</p>\\\\n<p>​    assigned is a tuple naming the attributes assigned directly</p>\\\\n<p>​    from the wrapped function to the wrapper function (defaults to</p>\\\\n<p>​    functools.WRAPPER_ASSIGNMENTS)</p>\\\\n<p>​    updated is a tuple naming the attributes of the wrapper that</p>\\\\n<p>​    are updated with the corresponding attribute from the wrapped</p>\\\\n<p>​    function (defaults to functools.WRAPPER_UPDATES)</p>\\\\n<p>wraps(wrapped, assigned=(\'<strong>module</strong>\', \'<strong>name</strong>\', \'<strong>qualname</strong>\', \'<strong>doc</strong>\', \'<strong>annotations</strong>\'), updated=(\'<strong>dict</strong>\',))</p>\\\\n<p>​    Decorator factory to apply update_wrapper() to a wrapper function</p>\\\\n<p>​    Returns a decorator that invokes update_wrapper() with the decorated</p>\\\\n<p>​    function as the wrapper argument and the arguments to wraps() as the</p>\\\\n<p>​    remaining arguments. Default arguments are as for update_wrapper().</p>\\\\n<p>​    This is a convenience function to simplify applying partial() to</p>\\\\n<p>​    update_wrapper().</p>\\\\n<p>DATA</p>\\\\n<p>WRAPPER_ASSIGNMENTS = (\'<strong>module</strong>\', \'<strong>name</strong>\', \'<strong>qualname</strong>\', \'__do...</p>\\\\n<p>WRAPPER_UPDATES = (\'<strong>dict</strong>\',)</p>\\\\n<p><strong>all</strong> = [\'update_wrapper\', \'wraps\', \'WRAPPER_ASSIGNMENTS\', \'WRAPPER_...</p>\\\\n<p>FILE</p>\\\\n<p>d:\\\\\\\\programdata\\\\\\\\anaconda3\\\\\\\\lib\\\\\\\\functools.py</p>\\\\n</blockquote>\\",\\"autoDesc\\":true}")\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwMDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OzREQUFVLHdEQStJSjtJQS9JTjs7Ozs7O0FDQTJFO0FBQzNFOztBQUVBLENBQTJKO0FBQzNKLGlDQUFpQywrQkFBZSxvQkFBb0IsTUFBTTs7QUFFMUUscURBQWU7O0FDTmdIO0FBQy9ILDBCQUEwQiw0SEFBNEgsNFJBQTRSLDZHQUE2RyxhQUFhLHFEQUFxRCxhQUFhLG9EQUFvRCxhQUFhLHFPQUFxTyxhQUFhLGlEQUFpRCxhQUFhLGlEQUFpRCxhQUFhLDBFQUEwRSxhQUFhLGlGQUFpRixhQUFhLGdGQUFnRixlQUFlLGlDQUFpQyxJQUFJLG9RQUFvUSxnSUFBZ0ksRUFBRSxLQUFLLHlCQUF5QiwrRUFBK0UsZ0VBQWdFLEVBQUUsa0JBQWtCLCtCQUErQiwrSUFBK0ksSUFBSSxLQUFLLGluSUFBaW5JLG96RkFBb3pGO0FBQ3ArUiIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGVib29rLy4vYm9vay8udnVlcHJlc3MvLnRlbXAvcGFnZXMvUHl0aG9uL+agh+WHhuW6ky9mdW5jdG9vbHMuaHRtbC52dWU/MTZkMCIsIndlYnBhY2s6Ly9ub3RlYm9vay8uL2Jvb2svLnZ1ZXByZXNzLy50ZW1wL3BhZ2VzL1B5dGhvbi/moIflh4blupMvZnVuY3Rvb2xzLmh0bWwudnVlP2NkNmUiLCJ3ZWJwYWNrOi8vbm90ZWJvb2svLi9ib29rLy52dWVwcmVzcy8udGVtcC9wYWdlcy9QeXRob24v5qCH5YeG5bqTL2Z1bmN0b29scy5odG1sLmpzP2YxYTYiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPjxkaXY+PHA+5YWz5LqOZnVuY3Rvb2xz5qCH5YeG5bqT77yaPC9wPlxuPGJsb2NrcXVvdGU+XG48cD4mZ3Q7Jmd0OyZndDsgaGVscChmdW5jdG9vbHMpPC9wPlxuPHA+SGVscCBvbiBtb2R1bGUgZnVuY3Rvb2xzOjwvcD5cbjxwPk5BTUU8L3A+XG48cD5mdW5jdG9vbHMgLSA8YSBocmVmPVwiaHR0cDovL2Z1bmN0b29scy5weVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5mdW5jdG9vbHMucHk8L2E+IC0gVG9vbHMgZm9yIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgYW5kIGNhbGxhYmxlIG9iamVjdHM8L3A+XG48cD5DTEFTU0VTPC9wPlxuPHA+YnVpbHRpbnMub2JqZWN0PC9wPlxuPHA+4oCLICAgIHBhcnRpYWw8L3A+XG48cD7igIsgICAgcGFydGlhbG1ldGhvZDwvcD5cbjxwPmNsYXNzIHBhcnRpYWwoYnVpbHRpbnMub2JqZWN0KTwvcD5cbjxwPnwgcGFydGlhbChmdW5jLCAqYXJncywgKiprZXl3b3JkcykgLSBuZXcgZnVuY3Rpb24gd2l0aCBwYXJ0aWFsIGFwcGxpY2F0aW9uPC9wPlxuPHA+fCBvZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFuZCBrZXl3b3Jkcy48L3A+XG48cD58PC9wPlxuPHA+fCBNZXRob2RzIGRlZmluZWQgaGVyZTo8L3A+XG48cD58PC9wPlxuPHA+fCA8c3Ryb25nPmNhbGw8L3N0cm9uZz4oc2VsZiwgLywgKmFyZ3MsICoqa3dhcmdzKTwvcD5cbjxwPnwgICBDYWxsIHNlbGYgYXMgYSBmdW5jdGlvbi48L3A+XG48cD58PC9wPlxuPHA+fCA8c3Ryb25nPmRlbGF0dHI8L3N0cm9uZz4oc2VsZiwgbmFtZSwgLyk8L3A+XG48cD58ICAgSW1wbGVtZW50IGRlbGF0dHIoc2VsZiwgbmFtZSkuPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5nZXRhdHRyaWJ1dGU8L3N0cm9uZz4oc2VsZiwgbmFtZSwgLyk8L3A+XG48cD58ICAgUmV0dXJuIGdldGF0dHIoc2VsZiwgbmFtZSkuPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5yZWR1Y2U8L3N0cm9uZz4oLi4uKTwvcD5cbjxwPnwgICBIZWxwZXIgZm9yIHBpY2tsZS48L3A+XG48cD58PC9wPlxuPHA+fCA8c3Ryb25nPnJlcHI8L3N0cm9uZz4oc2VsZiwgLyk8L3A+XG48cD58ICAgUmV0dXJuIHJlcHIoc2VsZikuPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5zZXRhdHRyPC9zdHJvbmc+KHNlbGYsIG5hbWUsIHZhbHVlLCAvKTwvcD5cbjxwPnwgICBJbXBsZW1lbnQgc2V0YXR0cihzZWxmLCBuYW1lLCB2YWx1ZSkuPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5zZXRzdGF0ZTwvc3Ryb25nPiguLi4pPC9wPlxuPHA+fDwvcD5cbjxwPnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTwvcD5cbjxwPnwgU3RhdGljIG1ldGhvZHMgZGVmaW5lZCBoZXJlOjwvcD5cbjxwPnw8L3A+XG48cD58IDxzdHJvbmc+bmV3PC9zdHJvbmc+KCphcmdzLCAqKmt3YXJncykgZnJvbSBidWlsdGlucy50eXBlPC9wPlxuPHA+fCAgIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG9iamVjdC4gU2VlIGhlbHAodHlwZSkgZm9yIGFjY3VyYXRlIHNpZ25hdHVyZS48L3A+XG48cD58PC9wPlxuPHA+fCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPC9wPlxuPHA+fCBEYXRhIGRlc2NyaXB0b3JzIGRlZmluZWQgaGVyZTo8L3A+XG48cD58PC9wPlxuPHA+fCA8c3Ryb25nPmRpY3Q8L3N0cm9uZz48L3A+XG48cD58PC9wPlxuPHA+fCBhcmdzPC9wPlxuPHA+fCAgIHR1cGxlIG9mIGFyZ3VtZW50cyB0byBmdXR1cmUgcGFydGlhbCBjYWxsczwvcD5cbjxwPnw8L3A+XG48cD58IGZ1bmM8L3A+XG48cD58ICAgZnVuY3Rpb24gb2JqZWN0IHRvIHVzZSBpbiBmdXR1cmUgcGFydGlhbCBjYWxsczwvcD5cbjxwPnw8L3A+XG48cD58IGtleXdvcmRzPC9wPlxuPHA+fCAgIGRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgdG8gZnV0dXJlIHBhcnRpYWwgY2FsbHM8L3A+XG48cD5jbGFzcyBwYXJ0aWFsbWV0aG9kKGJ1aWx0aW5zLm9iamVjdCk8L3A+XG48cD58IHBhcnRpYWxtZXRob2QoZnVuYywgKmFyZ3MsICoqa2V5d29yZHMpPC9wPlxuPHA+fDwvcD5cbjxwPnwgTWV0aG9kIGRlc2NyaXB0b3Igd2l0aCBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIHRoZSBnaXZlbiBhcmd1bWVudHM8L3A+XG48cD58IGFuZCBrZXl3b3Jkcy48L3A+XG48cD58PC9wPlxuPHA+fCBTdXBwb3J0cyB3cmFwcGluZyBleGlzdGluZyBkZXNjcmlwdG9ycyBhbmQgaGFuZGxlcyBub24tZGVzY3JpcHRvcjwvcD5cbjxwPnwgY2FsbGFibGVzIGFzIGluc3RhbmNlIG1ldGhvZHMuPC9wPlxuPHA+fDwvcD5cbjxwPnwgTWV0aG9kcyBkZWZpbmVkIGhlcmU6PC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5nZXQ8L3N0cm9uZz4oc2VsZiwgb2JqLCBjbHMpPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5pbml0PC9zdHJvbmc+KHNlbGYsIGZ1bmMsICphcmdzLCAqKmtleXdvcmRzKTwvcD5cbjxwPnwgICBJbml0aWFsaXplIHNlbGYuIFNlZSBoZWxwKHR5cGUoc2VsZikpIGZvciBhY2N1cmF0ZSBzaWduYXR1cmUuPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5yZXByPC9zdHJvbmc+KHNlbGYpPC9wPlxuPHA+fCAgIFJldHVybiByZXByKHNlbGYpLjwvcD5cbjxwPnw8L3A+XG48cD58IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS08L3A+XG48cD58IERhdGEgZGVzY3JpcHRvcnMgZGVmaW5lZCBoZXJlOjwvcD5cbjxwPnw8L3A+XG48cD58IDxzdHJvbmc+ZGljdDwvc3Ryb25nPjwvcD5cbjxwPnwgICBkaWN0aW9uYXJ5IGZvciBpbnN0YW5jZSB2YXJpYWJsZXMgKGlmIGRlZmluZWQpPC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz5pc2Fic3RyYWN0bWV0aG9kPC9zdHJvbmc+PC9wPlxuPHA+fDwvcD5cbjxwPnwgPHN0cm9uZz53ZWFrcmVmPC9zdHJvbmc+PC9wPlxuPHA+fCAgIGxpc3Qgb2Ygd2VhayByZWZlcmVuY2VzIHRvIHRoZSBvYmplY3QgKGlmIGRlZmluZWQpPC9wPlxuPHA+RlVOQ1RJT05TPC9wPlxuPHA+Y21wX3RvX2tleSguLi4pPC9wPlxuPHA+4oCLICAgIENvbnZlcnQgYSBjbXA9IGZ1bmN0aW9uIGludG8gYSBrZXk9IGZ1bmN0aW9uLjwvcD5cbjxwPmxydV9jYWNoZShtYXhzaXplPTEyOCwgdHlwZWQ9RmFsc2UpPC9wPlxuPHA+4oCLICAgIExlYXN0LXJlY2VudGx5LXVzZWQgY2FjaGUgZGVjb3JhdG9yLjwvcD5cbjxwPuKAiyAgICBJZiA8ZW0+bWF4c2l6ZTwvZW0+IGlzIHNldCB0byBOb25lLCB0aGUgTFJVIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCBhbmQgdGhlIGNhY2hlPC9wPlxuPHA+4oCLICAgIGNhbiBncm93IHdpdGhvdXQgYm91bmQuPC9wPlxuPHA+4oCLICAgIElmIDxlbT50eXBlZDwvZW0+IGlzIFRydWUsIGFyZ3VtZW50cyBvZiBkaWZmZXJlbnQgdHlwZXMgd2lsbCBiZSBjYWNoZWQgc2VwYXJhdGVseS48L3A+XG48cD7igIsgICAgRm9yIGV4YW1wbGUsIGYoMy4wKSBhbmQgZigzKSB3aWxsIGJlIHRyZWF0ZWQgYXMgZGlzdGluY3QgY2FsbHMgd2l0aDwvcD5cbjxwPuKAiyAgICBkaXN0aW5jdCByZXN1bHRzLjwvcD5cbjxwPuKAiyAgICBBcmd1bWVudHMgdG8gdGhlIGNhY2hlZCBmdW5jdGlvbiBtdXN0IGJlIGhhc2hhYmxlLjwvcD5cbjxwPuKAiyAgICBWaWV3IHRoZSBjYWNoZSBzdGF0aXN0aWNzIG5hbWVkIHR1cGxlIChoaXRzLCBtaXNzZXMsIG1heHNpemUsIGN1cnJzaXplKTwvcD5cbjxwPuKAiyAgICB3aXRoIGYuY2FjaGVfaW5mbygpLiBDbGVhciB0aGUgY2FjaGUgYW5kIHN0YXRpc3RpY3Mgd2l0aCBmLmNhY2hlX2NsZWFyKCkuPC9wPlxuPHA+4oCLICAgIEFjY2VzcyB0aGUgdW5kZXJseWluZyBmdW5jdGlvbiB3aXRoIGYuPHN0cm9uZz53cmFwcGVkPC9zdHJvbmc+LjwvcD5cbjxwPuKAiyAgICBTZWU6IDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMjTGVhc3RfUmVjZW50bHlfVXNlZFwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMjTGVhc3RfUmVjZW50bHlfVXNlZDwvYT48L3A+XG48cD5yZWR1Y2UoLi4uKTwvcD5cbjxwPuKAiyAgICByZWR1Y2UoZnVuY3Rpb24sIHNlcXVlbmNlWywgaW5pdGlhbF0pIC0mZ3Q7IHZhbHVlPC9wPlxuPHA+4oCLICAgIEFwcGx5IGEgZnVuY3Rpb24gb2YgdHdvIGFyZ3VtZW50cyBjdW11bGF0aXZlbHkgdG8gdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2UsPC9wPlxuPHA+4oCLICAgIGZyb20gbGVmdCB0byByaWdodCwgc28gYXMgdG8gcmVkdWNlIHRoZSBzZXF1ZW5jZSB0byBhIHNpbmdsZSB2YWx1ZS48L3A+XG48cD7igIsgICAgRm9yIGV4YW1wbGUsIHJlZHVjZShsYW1iZGEgeCwgeTogeCt5LCBbMSwgMiwgMywgNCwgNV0pIGNhbGN1bGF0ZXM8L3A+XG48cD7igIsgICAgKCgoKDErMikrMykrNCkrNSkuIElmIGluaXRpYWwgaXMgcHJlc2VudCwgaXQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgaXRlbXM8L3A+XG48cD7igIsgICAgb2YgdGhlIHNlcXVlbmNlIGluIHRoZSBjYWxjdWxhdGlvbiwgYW5kIHNlcnZlcyBhcyBhIGRlZmF1bHQgd2hlbiB0aGU8L3A+XG48cD7igIsgICAgc2VxdWVuY2UgaXMgZW1wdHkuPC9wPlxuPHA+c2luZ2xlZGlzcGF0Y2goZnVuYyk8L3A+XG48cD7igIsgICAgU2luZ2xlLWRpc3BhdGNoIGdlbmVyaWMgZnVuY3Rpb24gZGVjb3JhdG9yLjwvcD5cbjxwPuKAiyAgICBUcmFuc2Zvcm1zIGEgZnVuY3Rpb24gaW50byBhIGdlbmVyaWMgZnVuY3Rpb24sIHdoaWNoIGNhbiBoYXZlIGRpZmZlcmVudDwvcD5cbjxwPuKAiyAgICBiZWhhdmlvdXJzIGRlcGVuZGluZyB1cG9uIHRoZSB0eXBlIG9mIGl0cyBmaXJzdCBhcmd1bWVudC4gVGhlIGRlY29yYXRlZDwvcD5cbjxwPuKAiyAgICBmdW5jdGlvbiBhY3RzIGFzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbmQgYWRkaXRpb25hbDwvcD5cbjxwPuKAiyAgICBpbXBsZW1lbnRhdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdGhlIHJlZ2lzdGVyKCkgYXR0cmlidXRlIG9mIHRoZTwvcD5cbjxwPuKAiyAgICBnZW5lcmljIGZ1bmN0aW9uLjwvcD5cbjxwPnRvdGFsX29yZGVyaW5nKGNscyk8L3A+XG48cD7igIsgICAgQ2xhc3MgZGVjb3JhdG9yIHRoYXQgZmlsbHMgaW4gbWlzc2luZyBvcmRlcmluZyBtZXRob2RzPC9wPlxuPHA+dXBkYXRlX3dyYXBwZXIod3JhcHBlciwgd3JhcHBlZCwgYXNzaWduZWQ9KCc8c3Ryb25nPm1vZHVsZTwvc3Ryb25nPicsICc8c3Ryb25nPm5hbWU8L3N0cm9uZz4nLCAnPHN0cm9uZz5xdWFsbmFtZTwvc3Ryb25nPicsICc8c3Ryb25nPmRvYzwvc3Ryb25nPicsICc8c3Ryb25nPmFubm90YXRpb25zPC9zdHJvbmc+JyksIHVwZGF0ZWQ9KCc8c3Ryb25nPmRpY3Q8L3N0cm9uZz4nLCkpPC9wPlxuPHA+4oCLICAgIFVwZGF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gdG8gbG9vayBsaWtlIHRoZSB3cmFwcGVkIGZ1bmN0aW9uPC9wPlxuPHA+4oCLICAgIHdyYXBwZXIgaXMgdGhlIGZ1bmN0aW9uIHRvIGJlIHVwZGF0ZWQ8L3A+XG48cD7igIsgICAgd3JhcHBlZCBpcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb248L3A+XG48cD7igIsgICAgYXNzaWduZWQgaXMgYSB0dXBsZSBuYW1pbmcgdGhlIGF0dHJpYnV0ZXMgYXNzaWduZWQgZGlyZWN0bHk8L3A+XG48cD7igIsgICAgZnJvbSB0aGUgd3JhcHBlZCBmdW5jdGlvbiB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiAoZGVmYXVsdHMgdG88L3A+XG48cD7igIsgICAgZnVuY3Rvb2xzLldSQVBQRVJfQVNTSUdOTUVOVFMpPC9wPlxuPHA+4oCLICAgIHVwZGF0ZWQgaXMgYSB0dXBsZSBuYW1pbmcgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHdyYXBwZXIgdGhhdDwvcD5cbjxwPuKAiyAgICBhcmUgdXBkYXRlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBmcm9tIHRoZSB3cmFwcGVkPC9wPlxuPHA+4oCLICAgIGZ1bmN0aW9uIChkZWZhdWx0cyB0byBmdW5jdG9vbHMuV1JBUFBFUl9VUERBVEVTKTwvcD5cbjxwPndyYXBzKHdyYXBwZWQsIGFzc2lnbmVkPSgnPHN0cm9uZz5tb2R1bGU8L3N0cm9uZz4nLCAnPHN0cm9uZz5uYW1lPC9zdHJvbmc+JywgJzxzdHJvbmc+cXVhbG5hbWU8L3N0cm9uZz4nLCAnPHN0cm9uZz5kb2M8L3N0cm9uZz4nLCAnPHN0cm9uZz5hbm5vdGF0aW9uczwvc3Ryb25nPicpLCB1cGRhdGVkPSgnPHN0cm9uZz5kaWN0PC9zdHJvbmc+JywpKTwvcD5cbjxwPuKAiyAgICBEZWNvcmF0b3IgZmFjdG9yeSB0byBhcHBseSB1cGRhdGVfd3JhcHBlcigpIHRvIGEgd3JhcHBlciBmdW5jdGlvbjwvcD5cbjxwPuKAiyAgICBSZXR1cm5zIGEgZGVjb3JhdG9yIHRoYXQgaW52b2tlcyB1cGRhdGVfd3JhcHBlcigpIHdpdGggdGhlIGRlY29yYXRlZDwvcD5cbjxwPuKAiyAgICBmdW5jdGlvbiBhcyB0aGUgd3JhcHBlciBhcmd1bWVudCBhbmQgdGhlIGFyZ3VtZW50cyB0byB3cmFwcygpIGFzIHRoZTwvcD5cbjxwPuKAiyAgICByZW1haW5pbmcgYXJndW1lbnRzLiBEZWZhdWx0IGFyZ3VtZW50cyBhcmUgYXMgZm9yIHVwZGF0ZV93cmFwcGVyKCkuPC9wPlxuPHA+4oCLICAgIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzaW1wbGlmeSBhcHBseWluZyBwYXJ0aWFsKCkgdG88L3A+XG48cD7igIsgICAgdXBkYXRlX3dyYXBwZXIoKS48L3A+XG48cD5EQVRBPC9wPlxuPHA+V1JBUFBFUl9BU1NJR05NRU5UUyA9ICgnPHN0cm9uZz5tb2R1bGU8L3N0cm9uZz4nLCAnPHN0cm9uZz5uYW1lPC9zdHJvbmc+JywgJzxzdHJvbmc+cXVhbG5hbWU8L3N0cm9uZz4nLCAnX19kby4uLjwvcD5cbjxwPldSQVBQRVJfVVBEQVRFUyA9ICgnPHN0cm9uZz5kaWN0PC9zdHJvbmc+JywpPC9wPlxuPHA+PHN0cm9uZz5hbGw8L3N0cm9uZz4gPSBbJ3VwZGF0ZV93cmFwcGVyJywgJ3dyYXBzJywgJ1dSQVBQRVJfQVNTSUdOTUVOVFMnLCAnV1JBUFBFUl8uLi48L3A+XG48cD5GSUxFPC9wPlxuPHA+ZDpcXHByb2dyYW1kYXRhXFxhbmFjb25kYTNcXGxpYlxcZnVuY3Rvb2xzLnB5PC9wPlxuPC9ibG9ja3F1b3RlPlxuPHA+6KOF6aWw5ZmoPGNvZGUgdi1wcmU+ZnVuY3Rvb2xzLnRvdGFsX29yZGVyaW5nPC9jb2RlPuWPr+S7peeugOWMluWunueOsOiuqeexu+aUr+aMgeavlOi+g+eahOaTjeS9nO+8jOingeKAnOexu+KAnemhtemdoueslOiusOOAgjwvcD5cbjxwPuS7u+S9leaXtuWAmeS9oOWumuS5ieijhemlsOWZqOeahOaXtuWAme+8jOmDveW6lOivpeS9v+eUqDxjb2RlIHYtcHJlPmZ1bmN0b29sczwvY29kZT7lupPkuK3nmoQgPGNvZGUgdi1wcmU+QHdyYXBzPC9jb2RlPiDoo4XppbDlmajmnaXms6jop6PlupXlsYLljIXoo4Xlh73mlbDjgILop4HigJzlhYPnvJbnqIvigJ3pobXpnaLnrJTorrDjgII8L3A+XG48cD48Y29kZSB2LXByZT5mdW5jdG9vbHMucGFydGlhbCgpPC9jb2RlPuWHveaVsOWwseaYr+W4ruWKqeaIkeS7rOWIm+W7uuS4gOS4quWBj+WHveaVsOeahO+8jOingeKAnOWHveaVsOKAnemhtemdoueslOiusOOAgjwvcD5cbjwvZGl2PjwvdGVtcGxhdGU+XG5cblxuIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vZnVuY3Rvb2xzLmh0bWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE5YjA5MTNjXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE3LjQuMl92dWVAMy41LjEzX3dlYnBhY2tANS45Ny4xL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiaW1wb3J0IGNvbXAgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2NodWEtbi5naXRodWIuaW8vY2h1YS1uLmdpdGh1Yi5pby9ib29rLy52dWVwcmVzcy8udGVtcC9wYWdlcy9QeXRob24v5qCH5YeG5bqTL2Z1bmN0b29scy5odG1sLnZ1ZVwiXG5jb25zdCBkYXRhID0gSlNPTi5wYXJzZShcIntcXFwicGF0aFxcXCI6XFxcIi9QeXRob24vJUU2JUEwJTg3JUU1JTg3JTg2JUU1JUJBJTkzL2Z1bmN0b29scy5odG1sXFxcIixcXFwidGl0bGVcXFwiOlxcXCJmdW5jdG9vbHNcXFwiLFxcXCJsYW5nXFxcIjpcXFwiemgtQ05cXFwiLFxcXCJmcm9udG1hdHRlclxcXCI6e1xcXCJ0aXRsZVxcXCI6XFxcImZ1bmN0b29sc1xcXCIsXFxcImRhdGVcXFwiOlxcXCIyMDE5LTA2LTA2VDAwOjAwOjAwLjAwMFpcXFwiLFxcXCJkZXNjcmlwdGlvblxcXCI6XFxcIuWFs+S6jmZ1bmN0b29sc+agh+WHhuW6k++8miA+Pj4gaGVscChmdW5jdG9vbHMpIEhlbHAgb24gbW9kdWxlIGZ1bmN0b29sczogTkFNRSBmdW5jdG9vbHMgLSBmdW5jdG9vbHMucHkgLSBUb29scyBmb3Igd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBhbmQgY2FsbGFibGUgb2JqZWN0cyBDTEFTU0VTIGJ1aWx0aW5zLm9iamVjdCDigIsgcGFyLi4uXFxcIixcXFwiaGVhZFxcXCI6W1tcXFwibWV0YVxcXCIse1xcXCJwcm9wZXJ0eVxcXCI6XFxcIm9nOnVybFxcXCIsXFxcImNvbnRlbnRcXFwiOlxcXCJodHRwczovL2NodWEtbi5jb20vUHl0aG9uLyVFNiVBMCU4NyVFNSU4NyU4NiVFNSVCQSU5My9mdW5jdG9vbHMuaHRtbFxcXCJ9XSxbXFxcIm1ldGFcXFwiLHtcXFwicHJvcGVydHlcXFwiOlxcXCJvZzpzaXRlX25hbWVcXFwiLFxcXCJjb250ZW50XFxcIjpcXFwi6I2S5rWB55qE56yU6Laj5bGLXFxcIn1dLFtcXFwibWV0YVxcXCIse1xcXCJwcm9wZXJ0eVxcXCI6XFxcIm9nOnRpdGxlXFxcIixcXFwiY29udGVudFxcXCI6XFxcImZ1bmN0b29sc1xcXCJ9XSxbXFxcIm1ldGFcXFwiLHtcXFwicHJvcGVydHlcXFwiOlxcXCJvZzpkZXNjcmlwdGlvblxcXCIsXFxcImNvbnRlbnRcXFwiOlxcXCLlhbPkuo5mdW5jdG9vbHPmoIflh4blupPvvJogPj4+IGhlbHAoZnVuY3Rvb2xzKSBIZWxwIG9uIG1vZHVsZSBmdW5jdG9vbHM6IE5BTUUgZnVuY3Rvb2xzIC0gZnVuY3Rvb2xzLnB5IC0gVG9vbHMgZm9yIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgYW5kIGNhbGxhYmxlIG9iamVjdHMgQ0xBU1NFUyBidWlsdGlucy5vYmplY3Qg4oCLIHBhci4uLlxcXCJ9XSxbXFxcIm1ldGFcXFwiLHtcXFwicHJvcGVydHlcXFwiOlxcXCJvZzp0eXBlXFxcIixcXFwiY29udGVudFxcXCI6XFxcImFydGljbGVcXFwifV0sW1xcXCJtZXRhXFxcIix7XFxcInByb3BlcnR5XFxcIjpcXFwib2c6bG9jYWxlXFxcIixcXFwiY29udGVudFxcXCI6XFxcInpoLUNOXFxcIn1dLFtcXFwibWV0YVxcXCIse1xcXCJwcm9wZXJ0eVxcXCI6XFxcIm9nOnVwZGF0ZWRfdGltZVxcXCIsXFxcImNvbnRlbnRcXFwiOlxcXCIyMDI0LTA0LTAyVDEzOjUxOjI3LjAwMFpcXFwifV0sW1xcXCJtZXRhXFxcIix7XFxcInByb3BlcnR5XFxcIjpcXFwiYXJ0aWNsZTpwdWJsaXNoZWRfdGltZVxcXCIsXFxcImNvbnRlbnRcXFwiOlxcXCIyMDE5LTA2LTA2VDAwOjAwOjAwLjAwMFpcXFwifV0sW1xcXCJtZXRhXFxcIix7XFxcInByb3BlcnR5XFxcIjpcXFwiYXJ0aWNsZTptb2RpZmllZF90aW1lXFxcIixcXFwiY29udGVudFxcXCI6XFxcIjIwMjQtMDQtMDJUMTM6NTE6MjcuMDAwWlxcXCJ9XSxbXFxcInNjcmlwdFxcXCIse1xcXCJ0eXBlXFxcIjpcXFwiYXBwbGljYXRpb24vbGQranNvblxcXCJ9LFxcXCJ7XFxcXFxcXCJAY29udGV4dFxcXFxcXFwiOlxcXFxcXFwiaHR0cHM6Ly9zY2hlbWEub3JnXFxcXFxcXCIsXFxcXFxcXCJAdHlwZVxcXFxcXFwiOlxcXFxcXFwiQXJ0aWNsZVxcXFxcXFwiLFxcXFxcXFwiaGVhZGxpbmVcXFxcXFxcIjpcXFxcXFxcImZ1bmN0b29sc1xcXFxcXFwiLFxcXFxcXFwiaW1hZ2VcXFxcXFxcIjpbXFxcXFxcXCJcXFxcXFxcIl0sXFxcXFxcXCJkYXRlUHVibGlzaGVkXFxcXFxcXCI6XFxcXFxcXCIyMDE5LTA2LTA2VDAwOjAwOjAwLjAwMFpcXFxcXFxcIixcXFxcXFxcImRhdGVNb2RpZmllZFxcXFxcXFwiOlxcXFxcXFwiMjAyNC0wNC0wMlQxMzo1MToyNy4wMDBaXFxcXFxcXCIsXFxcXFxcXCJhdXRob3JcXFxcXFxcIjpbe1xcXFxcXFwiQHR5cGVcXFxcXFxcIjpcXFxcXFxcIlBlcnNvblxcXFxcXFwiLFxcXFxcXFwibmFtZVxcXFxcXFwiOlxcXFxcXFwi6I2S5rWBXFxcXFxcXCIsXFxcXFxcXCJ1cmxcXFxcXFxcIjpcXFxcXFxcImh0dHBzOi8vY2h1YS1uLmNvbVxcXFxcXFwiLFxcXFxcXFwiZW1haWxcXFxcXFxcIjpcXFxcXFxcImNodWFfbkBxcS5jb21cXFxcXFxcIn1dfVxcXCJdXX0sXFxcImhlYWRlcnNcXFwiOltdLFxcXCJnaXRcXFwiOntcXFwiY3JlYXRlZFRpbWVcXFwiOjE2NDI2ODkwNjIwMDAsXFxcInVwZGF0ZWRUaW1lXFxcIjoxNzEyMDY1ODg3MDAwLFxcXCJjb250cmlidXRvcnNcXFwiOlt7XFxcIm5hbWVcXFwiOlxcXCJjaHVhLW5cXFwiLFxcXCJlbWFpbFxcXCI6XFxcImNodWFfbkB5ZWFoLm5ldFxcXCIsXFxcImNvbW1pdHNcXFwiOjN9XX0sXFxcInJlYWRpbmdUaW1lXFxcIjp7XFxcIm1pbnV0ZXNcXFwiOjIuNDQsXFxcIndvcmRzXFxcIjo3MzJ9LFxcXCJmaWxlUGF0aFJlbGF0aXZlXFxcIjpcXFwiUHl0aG9uL+agh+WHhuW6ky9mdW5jdG9vbHMubWRcXFwiLFxcXCJsb2NhbGl6ZWREYXRlXFxcIjpcXFwiMjAxOeW5tDbmnIg25pelXFxcIixcXFwiZXhjZXJwdFxcXCI6XFxcIjxwPuWFs+S6jmZ1bmN0b29sc+agh+WHhuW6k++8mjwvcD5cXFxcbjxibG9ja3F1b3RlPlxcXFxuPHA+Jmd0OyZndDsmZ3Q7IGhlbHAoZnVuY3Rvb2xzKTwvcD5cXFxcbjxwPkhlbHAgb24gbW9kdWxlIGZ1bmN0b29sczo8L3A+XFxcXG48cD5OQU1FPC9wPlxcXFxuPHA+ZnVuY3Rvb2xzIC0gPGEgaHJlZj1cXFxcXFxcImh0dHA6Ly9mdW5jdG9vbHMucHlcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiByZWw9XFxcXFxcXCJub29wZW5lciBub3JlZmVycmVyXFxcXFxcXCI+ZnVuY3Rvb2xzLnB5PC9hPiAtIFRvb2xzIGZvciB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGFuZCBjYWxsYWJsZSBvYmplY3RzPC9wPlxcXFxuPHA+Q0xBU1NFUzwvcD5cXFxcbjxwPmJ1aWx0aW5zLm9iamVjdDwvcD5cXFxcbjxwPuKAiyAgICBwYXJ0aWFsPC9wPlxcXFxuPHA+4oCLICAgIHBhcnRpYWxtZXRob2Q8L3A+XFxcXG48cD5jbGFzcyBwYXJ0aWFsKGJ1aWx0aW5zLm9iamVjdCk8L3A+XFxcXG48cD58IHBhcnRpYWwoZnVuYywgKmFyZ3MsICoqa2V5d29yZHMpIC0gbmV3IGZ1bmN0aW9uIHdpdGggcGFydGlhbCBhcHBsaWNhdGlvbjwvcD5cXFxcbjxwPnwgb2YgdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQga2V5d29yZHMuPC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgTWV0aG9kcyBkZWZpbmVkIGhlcmU6PC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgPHN0cm9uZz5jYWxsPC9zdHJvbmc+KHNlbGYsIC8sICphcmdzLCAqKmt3YXJncyk8L3A+XFxcXG48cD58ICAgQ2FsbCBzZWxmIGFzIGEgZnVuY3Rpb24uPC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgPHN0cm9uZz5kZWxhdHRyPC9zdHJvbmc+KHNlbGYsIG5hbWUsIC8pPC9wPlxcXFxuPHA+fCAgIEltcGxlbWVudCBkZWxhdHRyKHNlbGYsIG5hbWUpLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+Z2V0YXR0cmlidXRlPC9zdHJvbmc+KHNlbGYsIG5hbWUsIC8pPC9wPlxcXFxuPHA+fCAgIFJldHVybiBnZXRhdHRyKHNlbGYsIG5hbWUpLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+cmVkdWNlPC9zdHJvbmc+KC4uLik8L3A+XFxcXG48cD58ICAgSGVscGVyIGZvciBwaWNrbGUuPC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgPHN0cm9uZz5yZXByPC9zdHJvbmc+KHNlbGYsIC8pPC9wPlxcXFxuPHA+fCAgIFJldHVybiByZXByKHNlbGYpLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+c2V0YXR0cjwvc3Ryb25nPihzZWxmLCBuYW1lLCB2YWx1ZSwgLyk8L3A+XFxcXG48cD58ICAgSW1wbGVtZW50IHNldGF0dHIoc2VsZiwgbmFtZSwgdmFsdWUpLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+c2V0c3RhdGU8L3N0cm9uZz4oLi4uKTwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS08L3A+XFxcXG48cD58IFN0YXRpYyBtZXRob2RzIGRlZmluZWQgaGVyZTo8L3A+XFxcXG48cD58PC9wPlxcXFxuPHA+fCA8c3Ryb25nPm5ldzwvc3Ryb25nPigqYXJncywgKiprd2FyZ3MpIGZyb20gYnVpbHRpbnMudHlwZTwvcD5cXFxcbjxwPnwgICBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3QuIFNlZSBoZWxwKHR5cGUpIGZvciBhY2N1cmF0ZSBzaWduYXR1cmUuPC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTwvcD5cXFxcbjxwPnwgRGF0YSBkZXNjcmlwdG9ycyBkZWZpbmVkIGhlcmU6PC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgPHN0cm9uZz5kaWN0PC9zdHJvbmc+PC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgYXJnczwvcD5cXFxcbjxwPnwgICB0dXBsZSBvZiBhcmd1bWVudHMgdG8gZnV0dXJlIHBhcnRpYWwgY2FsbHM8L3A+XFxcXG48cD58PC9wPlxcXFxuPHA+fCBmdW5jPC9wPlxcXFxuPHA+fCAgIGZ1bmN0aW9uIG9iamVjdCB0byB1c2UgaW4gZnV0dXJlIHBhcnRpYWwgY2FsbHM8L3A+XFxcXG48cD58PC9wPlxcXFxuPHA+fCBrZXl3b3JkczwvcD5cXFxcbjxwPnwgICBkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHRvIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzPC9wPlxcXFxuPHA+Y2xhc3MgcGFydGlhbG1ldGhvZChidWlsdGlucy5vYmplY3QpPC9wPlxcXFxuPHA+fCBwYXJ0aWFsbWV0aG9kKGZ1bmMsICphcmdzLCAqKmtleXdvcmRzKTwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IE1ldGhvZCBkZXNjcmlwdG9yIHdpdGggcGFydGlhbCBhcHBsaWNhdGlvbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnRzPC9wPlxcXFxuPHA+fCBhbmQga2V5d29yZHMuPC9wPlxcXFxuPHA+fDwvcD5cXFxcbjxwPnwgU3VwcG9ydHMgd3JhcHBpbmcgZXhpc3RpbmcgZGVzY3JpcHRvcnMgYW5kIGhhbmRsZXMgbm9uLWRlc2NyaXB0b3I8L3A+XFxcXG48cD58IGNhbGxhYmxlcyBhcyBpbnN0YW5jZSBtZXRob2RzLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IE1ldGhvZHMgZGVmaW5lZCBoZXJlOjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+Z2V0PC9zdHJvbmc+KHNlbGYsIG9iaiwgY2xzKTwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+aW5pdDwvc3Ryb25nPihzZWxmLCBmdW5jLCAqYXJncywgKiprZXl3b3Jkcyk8L3A+XFxcXG48cD58ICAgSW5pdGlhbGl6ZSBzZWxmLiBTZWUgaGVscCh0eXBlKHNlbGYpKSBmb3IgYWNjdXJhdGUgc2lnbmF0dXJlLjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+cmVwcjwvc3Ryb25nPihzZWxmKTwvcD5cXFxcbjxwPnwgICBSZXR1cm4gcmVwcihzZWxmKS48L3A+XFxcXG48cD58PC9wPlxcXFxuPHA+fCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPC9wPlxcXFxuPHA+fCBEYXRhIGRlc2NyaXB0b3JzIGRlZmluZWQgaGVyZTo8L3A+XFxcXG48cD58PC9wPlxcXFxuPHA+fCA8c3Ryb25nPmRpY3Q8L3N0cm9uZz48L3A+XFxcXG48cD58ICAgZGljdGlvbmFyeSBmb3IgaW5zdGFuY2UgdmFyaWFibGVzIChpZiBkZWZpbmVkKTwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+aXNhYnN0cmFjdG1ldGhvZDwvc3Ryb25nPjwvcD5cXFxcbjxwPnw8L3A+XFxcXG48cD58IDxzdHJvbmc+d2Vha3JlZjwvc3Ryb25nPjwvcD5cXFxcbjxwPnwgICBsaXN0IG9mIHdlYWsgcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0IChpZiBkZWZpbmVkKTwvcD5cXFxcbjxwPkZVTkNUSU9OUzwvcD5cXFxcbjxwPmNtcF90b19rZXkoLi4uKTwvcD5cXFxcbjxwPuKAiyAgICBDb252ZXJ0IGEgY21wPSBmdW5jdGlvbiBpbnRvIGEga2V5PSBmdW5jdGlvbi48L3A+XFxcXG48cD5scnVfY2FjaGUobWF4c2l6ZT0xMjgsIHR5cGVkPUZhbHNlKTwvcD5cXFxcbjxwPuKAiyAgICBMZWFzdC1yZWNlbnRseS11c2VkIGNhY2hlIGRlY29yYXRvci48L3A+XFxcXG48cD7igIsgICAgSWYgPGVtPm1heHNpemU8L2VtPiBpcyBzZXQgdG8gTm9uZSwgdGhlIExSVSBmZWF0dXJlcyBhcmUgZGlzYWJsZWQgYW5kIHRoZSBjYWNoZTwvcD5cXFxcbjxwPuKAiyAgICBjYW4gZ3JvdyB3aXRob3V0IGJvdW5kLjwvcD5cXFxcbjxwPuKAiyAgICBJZiA8ZW0+dHlwZWQ8L2VtPiBpcyBUcnVlLCBhcmd1bWVudHMgb2YgZGlmZmVyZW50IHR5cGVzIHdpbGwgYmUgY2FjaGVkIHNlcGFyYXRlbHkuPC9wPlxcXFxuPHA+4oCLICAgIEZvciBleGFtcGxlLCBmKDMuMCkgYW5kIGYoMykgd2lsbCBiZSB0cmVhdGVkIGFzIGRpc3RpbmN0IGNhbGxzIHdpdGg8L3A+XFxcXG48cD7igIsgICAgZGlzdGluY3QgcmVzdWx0cy48L3A+XFxcXG48cD7igIsgICAgQXJndW1lbnRzIHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24gbXVzdCBiZSBoYXNoYWJsZS48L3A+XFxcXG48cD7igIsgICAgVmlldyB0aGUgY2FjaGUgc3RhdGlzdGljcyBuYW1lZCB0dXBsZSAoaGl0cywgbWlzc2VzLCBtYXhzaXplLCBjdXJyc2l6ZSk8L3A+XFxcXG48cD7igIsgICAgd2l0aCBmLmNhY2hlX2luZm8oKS4gQ2xlYXIgdGhlIGNhY2hlIGFuZCBzdGF0aXN0aWNzIHdpdGggZi5jYWNoZV9jbGVhcigpLjwvcD5cXFxcbjxwPuKAiyAgICBBY2Nlc3MgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24gd2l0aCBmLjxzdHJvbmc+d3JhcHBlZDwvc3Ryb25nPi48L3A+XFxcXG48cD7igIsgICAgU2VlOiA8YSBocmVmPVxcXFxcXFwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9hbGdvcml0aG1zI0xlYXN0X1JlY2VudGx5X1VzZWRcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiByZWw9XFxcXFxcXCJub29wZW5lciBub3JlZmVycmVyXFxcXFxcXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9hbGdvcml0aG1zI0xlYXN0X1JlY2VudGx5X1VzZWQ8L2E+PC9wPlxcXFxuPHA+cmVkdWNlKC4uLik8L3A+XFxcXG48cD7igIsgICAgcmVkdWNlKGZ1bmN0aW9uLCBzZXF1ZW5jZVssIGluaXRpYWxdKSAtJmd0OyB2YWx1ZTwvcD5cXFxcbjxwPuKAiyAgICBBcHBseSBhIGZ1bmN0aW9uIG9mIHR3byBhcmd1bWVudHMgY3VtdWxhdGl2ZWx5IHRvIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlLDwvcD5cXFxcbjxwPuKAiyAgICBmcm9tIGxlZnQgdG8gcmlnaHQsIHNvIGFzIHRvIHJlZHVjZSB0aGUgc2VxdWVuY2UgdG8gYSBzaW5nbGUgdmFsdWUuPC9wPlxcXFxuPHA+4oCLICAgIEZvciBleGFtcGxlLCByZWR1Y2UobGFtYmRhIHgsIHk6IHgreSwgWzEsIDIsIDMsIDQsIDVdKSBjYWxjdWxhdGVzPC9wPlxcXFxuPHA+4oCLICAgICgoKCgxKzIpKzMpKzQpKzUpLiBJZiBpbml0aWFsIGlzIHByZXNlbnQsIGl0IGlzIHBsYWNlZCBiZWZvcmUgdGhlIGl0ZW1zPC9wPlxcXFxuPHA+4oCLICAgIG9mIHRoZSBzZXF1ZW5jZSBpbiB0aGUgY2FsY3VsYXRpb24sIGFuZCBzZXJ2ZXMgYXMgYSBkZWZhdWx0IHdoZW4gdGhlPC9wPlxcXFxuPHA+4oCLICAgIHNlcXVlbmNlIGlzIGVtcHR5LjwvcD5cXFxcbjxwPnNpbmdsZWRpc3BhdGNoKGZ1bmMpPC9wPlxcXFxuPHA+4oCLICAgIFNpbmdsZS1kaXNwYXRjaCBnZW5lcmljIGZ1bmN0aW9uIGRlY29yYXRvci48L3A+XFxcXG48cD7igIsgICAgVHJhbnNmb3JtcyBhIGZ1bmN0aW9uIGludG8gYSBnZW5lcmljIGZ1bmN0aW9uLCB3aGljaCBjYW4gaGF2ZSBkaWZmZXJlbnQ8L3A+XFxcXG48cD7igIsgICAgYmVoYXZpb3VycyBkZXBlbmRpbmcgdXBvbiB0aGUgdHlwZSBvZiBpdHMgZmlyc3QgYXJndW1lbnQuIFRoZSBkZWNvcmF0ZWQ8L3A+XFxcXG48cD7igIsgICAgZnVuY3Rpb24gYWN0cyBhcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgYW5kIGFkZGl0aW9uYWw8L3A+XFxcXG48cD7igIsgICAgaW1wbGVtZW50YXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHVzaW5nIHRoZSByZWdpc3RlcigpIGF0dHJpYnV0ZSBvZiB0aGU8L3A+XFxcXG48cD7igIsgICAgZ2VuZXJpYyBmdW5jdGlvbi48L3A+XFxcXG48cD50b3RhbF9vcmRlcmluZyhjbHMpPC9wPlxcXFxuPHA+4oCLICAgIENsYXNzIGRlY29yYXRvciB0aGF0IGZpbGxzIGluIG1pc3Npbmcgb3JkZXJpbmcgbWV0aG9kczwvcD5cXFxcbjxwPnVwZGF0ZV93cmFwcGVyKHdyYXBwZXIsIHdyYXBwZWQsIGFzc2lnbmVkPSgnPHN0cm9uZz5tb2R1bGU8L3N0cm9uZz4nLCAnPHN0cm9uZz5uYW1lPC9zdHJvbmc+JywgJzxzdHJvbmc+cXVhbG5hbWU8L3N0cm9uZz4nLCAnPHN0cm9uZz5kb2M8L3N0cm9uZz4nLCAnPHN0cm9uZz5hbm5vdGF0aW9uczwvc3Ryb25nPicpLCB1cGRhdGVkPSgnPHN0cm9uZz5kaWN0PC9zdHJvbmc+JywpKTwvcD5cXFxcbjxwPuKAiyAgICBVcGRhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRvIGxvb2sgbGlrZSB0aGUgd3JhcHBlZCBmdW5jdGlvbjwvcD5cXFxcbjxwPuKAiyAgICB3cmFwcGVyIGlzIHRoZSBmdW5jdGlvbiB0byBiZSB1cGRhdGVkPC9wPlxcXFxuPHA+4oCLICAgIHdyYXBwZWQgaXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uPC9wPlxcXFxuPHA+4oCLICAgIGFzc2lnbmVkIGlzIGEgdHVwbGUgbmFtaW5nIHRoZSBhdHRyaWJ1dGVzIGFzc2lnbmVkIGRpcmVjdGx5PC9wPlxcXFxuPHA+4oCLICAgIGZyb20gdGhlIHdyYXBwZWQgZnVuY3Rpb24gdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gKGRlZmF1bHRzIHRvPC9wPlxcXFxuPHA+4oCLICAgIGZ1bmN0b29scy5XUkFQUEVSX0FTU0lHTk1FTlRTKTwvcD5cXFxcbjxwPuKAiyAgICB1cGRhdGVkIGlzIGEgdHVwbGUgbmFtaW5nIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSB3cmFwcGVyIHRoYXQ8L3A+XFxcXG48cD7igIsgICAgYXJlIHVwZGF0ZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgZnJvbSB0aGUgd3JhcHBlZDwvcD5cXFxcbjxwPuKAiyAgICBmdW5jdGlvbiAoZGVmYXVsdHMgdG8gZnVuY3Rvb2xzLldSQVBQRVJfVVBEQVRFUyk8L3A+XFxcXG48cD53cmFwcyh3cmFwcGVkLCBhc3NpZ25lZD0oJzxzdHJvbmc+bW9kdWxlPC9zdHJvbmc+JywgJzxzdHJvbmc+bmFtZTwvc3Ryb25nPicsICc8c3Ryb25nPnF1YWxuYW1lPC9zdHJvbmc+JywgJzxzdHJvbmc+ZG9jPC9zdHJvbmc+JywgJzxzdHJvbmc+YW5ub3RhdGlvbnM8L3N0cm9uZz4nKSwgdXBkYXRlZD0oJzxzdHJvbmc+ZGljdDwvc3Ryb25nPicsKSk8L3A+XFxcXG48cD7igIsgICAgRGVjb3JhdG9yIGZhY3RvcnkgdG8gYXBwbHkgdXBkYXRlX3dyYXBwZXIoKSB0byBhIHdyYXBwZXIgZnVuY3Rpb248L3A+XFxcXG48cD7igIsgICAgUmV0dXJucyBhIGRlY29yYXRvciB0aGF0IGludm9rZXMgdXBkYXRlX3dyYXBwZXIoKSB3aXRoIHRoZSBkZWNvcmF0ZWQ8L3A+XFxcXG48cD7igIsgICAgZnVuY3Rpb24gYXMgdGhlIHdyYXBwZXIgYXJndW1lbnQgYW5kIHRoZSBhcmd1bWVudHMgdG8gd3JhcHMoKSBhcyB0aGU8L3A+XFxcXG48cD7igIsgICAgcmVtYWluaW5nIGFyZ3VtZW50cy4gRGVmYXVsdCBhcmd1bWVudHMgYXJlIGFzIGZvciB1cGRhdGVfd3JhcHBlcigpLjwvcD5cXFxcbjxwPuKAiyAgICBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2ltcGxpZnkgYXBwbHlpbmcgcGFydGlhbCgpIHRvPC9wPlxcXFxuPHA+4oCLICAgIHVwZGF0ZV93cmFwcGVyKCkuPC9wPlxcXFxuPHA+REFUQTwvcD5cXFxcbjxwPldSQVBQRVJfQVNTSUdOTUVOVFMgPSAoJzxzdHJvbmc+bW9kdWxlPC9zdHJvbmc+JywgJzxzdHJvbmc+bmFtZTwvc3Ryb25nPicsICc8c3Ryb25nPnF1YWxuYW1lPC9zdHJvbmc+JywgJ19fZG8uLi48L3A+XFxcXG48cD5XUkFQUEVSX1VQREFURVMgPSAoJzxzdHJvbmc+ZGljdDwvc3Ryb25nPicsKTwvcD5cXFxcbjxwPjxzdHJvbmc+YWxsPC9zdHJvbmc+ID0gWyd1cGRhdGVfd3JhcHBlcicsICd3cmFwcycsICdXUkFQUEVSX0FTU0lHTk1FTlRTJywgJ1dSQVBQRVJfLi4uPC9wPlxcXFxuPHA+RklMRTwvcD5cXFxcbjxwPmQ6XFxcXFxcXFxwcm9ncmFtZGF0YVxcXFxcXFxcYW5hY29uZGEzXFxcXFxcXFxsaWJcXFxcXFxcXGZ1bmN0b29scy5weTwvcD5cXFxcbjwvYmxvY2txdW90ZT5cXFwiLFxcXCJhdXRvRGVzY1xcXCI6dHJ1ZX1cIilcbmV4cG9ydCB7IGNvbXAsIGRhdGEgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///84008\n')},81021:(__unused_webpack_module,exports)=>{eval("var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.A = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEwMjEuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsNkJBQTZDLEVBQUUsYUFBYSxDQUFDO0FBQzdEO0FBQ0E7QUFDQSxTQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90ZWJvb2svLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNy40LjJfdnVlQDMuNS4xM193ZWJwYWNrQDUuOTcuMS9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcz8yNmM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcnVudGltZSBoZWxwZXIgZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBjb21wb25lbnRzXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XG5leHBvcnRzLmRlZmF1bHQgPSAoc2ZjLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHNmYy5fX3ZjY09wdHMgfHwgc2ZjO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81021\n")}}]);