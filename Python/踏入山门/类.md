## Python类的概念

基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。

根据类来创建对象被称为**实例化**，创建的对象叫做**实例对象**。实例对象的唯一操作是属性引用，有两种有效的**属性**名称：数据属性和方法。

1. **数据属性**对应于 C++中的数据成员；

2. **方法**是从属于对象的函数。

当一个类定义了`__init__()`方法时，类的实例化操作会自动为新创建的类实例发起调用`__init__()`。

用 C++术语来讲，python 中的类成员，包括数据成员，都是 `public` 的（私有变量除外），所有成员函数都是 `virtual` 的。

类定义与函数定义一样，必须被执行才会起作用。

## 实例属性和类属性

> 这里的属性其实概括了数据属性和方法......

在类声明中指定的属性称为**类属性**，类变量也可以被实例所访问，但其**仅限**在类的层级上修改，而不能在类的实例中修改。

> 另外，任何一个作为类属性的函数都为该类的实例定义了一个相应方法（这也就是为什么`@classmethod` 也可以用实例来访问的原因，猜的）。

![](../../resources/images/notebooks/Python/71.png)

给实例绑定属性的方法是通过实例变量，或者通过 `self` 变量：

![](../../resources/images/notebooks/Python/72.png)

> 值得注意的是，有时你不自觉地希望从实例中更改类属性，于是你写了那样的一个语句，但综合以上两点，其实你写的语句并不是在修改类属性，而只是创建了一个和类属性同名的实例属性！

特点：

- 从设计理念上来说，实例变量用于作为每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法。

- 相同名称的实例属性将屏蔽掉类属性；但将实例属性删除后可访问对应的类属性。

    ![](../../resources/images/notebooks/Python/73.png)

python 中没有任何东西能**强制隐藏数据**，它是完全基于约定的；不过，用 C 语言编写的 python 实现则可以隐藏实现细节，并在必要时控制对象的访问，此特性可以通过用 C 编写 python 扩展来使用。

### 彼此依赖的属性

一些属性之间彼此依赖，此时修改被依赖的属性时其相关属性不会自动更新。针对这种情况，可定义一个在属性更改时执行的方法。

## 方法

关于`self`:

1. 在（实例）方法的定义中，形参 `self` 必不可少，还必须位于其他形参的前面。每个与类相关联的方法调用都自动传递实参 `self`，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。

2. 以 `self` 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。

函数定义的文本并非必须包含于类定义之内，将一个函数对象赋值给一个局部变量也是可以的，如：

![](../../resources/images/notebooks/Python/70.png)

一般方法通过使用第一个参数来引用一个实例，而**类方法**第一个参数是引用该类的本身。按照约定，第一个参数分别称为 `self` (用于标准方法) 和 `cls` (用于类方法)。另外，类方法需在其定义前加上`@classmethod`

- 一般方法

    ```python
    class A:
        def fun(self, *args):
            ...
    ```

- 类方法

    ```python
    class B:
        def fun(cls, *args):
            ...
    ```

## 继承

子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。

1. 创建子类的实例时，Python 首先需要完成的任务是给父类的所有属性赋值。

    ![](../../resources/images/notebooks/Python/74.png)

2. 创建子类时，父类必须包含在当前文件中，且位于子类前面。父类也称为超类（superclass），名称 super 因此而得名。

    > Python 3.x 和 Python 2.x 的一个区别就是 Python 3 可以直接使用 super().xxx 代替 super(Class, self).xxx
    >
    > - Python 3.x 实例
    >
    >     ```python
    >     class A:
    >     	def add(self, x):
    >     		y = x+1
    >     		print(y)
    >     class B(A):
    >     	def add(self, x):
    >     		super().add(x)
    >     b = B()
    >     b.add(2)    # 3
    >     ```
    >
    > - Python 2.x 实例
    >
    >     ```python
    >     class A(object): # Python2.x 记得继承 object
    >     	def add(self, x):
    >     		y = x+1
    >     		print(y)
    >     class B(A):
    >     	def add(self, x):
    >     		super(B, self).add(x)
    >     b = B()
    >     b.add(2)    # 3
    >     ```

3. 对于派生类，如果请求的属性在类中找不到，搜索将转往基类中进行查找；如果基类本身也派生自其他某个类，则此规则将被递归地应用。

4. 对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python 将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。

python 有两个内置函数可被用于检查继承机制：

1. 使用`isinstance()`来检查一个实例的类型，`isinstance(obj, int)`

2. 使用`issubclass()`来检查类的继承关系：`issubclass(bool, int)`

### 继承解析

1. 对于多数应用来说，在最简单的情况下，可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结果中存在重叠时不会在同一个类中搜索两次；

2. 真实情况实际上更复杂一些，方法解析顺序会动态改变以支持对 super()的协同调用；

3. 动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。例如，所有类都是继承自 object，因此任何多重继承的情况都提供了一条以上的路径可以通向 object。为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化，保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。

