## 文本文件与二进制文件

文件有两种展现形态：文本文件和二进制文件。

1. 文本文件和二进制文件只是文件的展式方式；

2. 本质上，所有文本文件都是二进制形式存储；

3. 形式上，所有文件采用这两种方式展式。

**文本文件**：由单一特定编码组成的文件，如 UTF-8 编码。由于存在编码，也被看作是存储着的长字符串。

-   适用于.txt 文件，.py 文件等。

-   读取文本文件时，Python 将其中的所有文本都解读为字符串；同时，Python 只能将字符串写入文本文件，故写入数值时也不能直接写入，要写用 `str()`函数转换为字符串。

    |       原文本        |        读取后         |
    | :-----------------: | :-------------------: |
    | 中国是个伟大的国家! | "中国是个伟大的国家!" |

**二进制文件**：

-   直接由比特 0 和 1 组成，没有统一字符编码。一般存在二进制 0 和 1 的组织结构，即文件格式。

-   适用于.png 文件，.avi 文件等。

    |       原文本        |                            读取后                            |
    | :-----------------: | :----------------------------------------------------------: |
    | 中国是个伟大的国家! | `b'\xd6\xd0\xb9\xfa\xca\xc7\xb8\xf6\xce\xb0\xb4\xf3\xb5\xc4\xb9\xfa\xbc\xd2\xa3\xa1'` |

## 文件的打开与关闭

打开文件：

-   语句格式：`<变量名> = open (<文件名>, <打开模式>)`
-   变量名：文件句柄
-   文件名：文件路径和名称；源文件同目录可省略
-   打开模式：文本 or 二进制；读 or 写

文件打开的模式有如下几种，若不指定模式实参，则默认为只读模式。

| 模式代码 |        模式         |                      说明                      |
| :------: | :-----------------: | :--------------------------------------------: |
|   'r'    |      只读模式       | 默认值，若文件不存在返回 File Not Found Error  |
|   'w'    |     覆盖写模式      |     文件不存在则创建，存在则完全覆盖原文件     |
|   'x'    |     创建写模式      | 文件不存在则创建，存在则返回 File Exists Error |
|   'a'    |     追加写模式      |   文件不存在则创建，存在则在文件末尾追加内容   |
|   '+'    | 与 r/w/x/a 搭配使用 |         在原功能基础上增加同时读写功能         |
|   't'    |    文本文件模式     |                     默认值                     |
|   'b'    |   二进制文件模式    |                                                |

关闭文件：

-   语句格式：`<变量名>.close()`
-   变量名：即文件句柄

其实打开文件更好且更 pythonic 的方式是用`with`关键字，其有如下好处：

```python
with open('pi_digits.txt') as file_object:
    contents = file_object.read()
    print(contents)
```

-   关键字`with`在不需要访问文件后将其关闭。
-   也可以调用`open()`和`close()`来打开和关闭文件，但这样做时，如果程序存在 bug，导致`close()`语句未执行，文件将不会关闭。

> 注意：`with` 打开的文件只在由 `with` 缩进的代码块中可用。

## 文件读写

### 文件路径

路径有**相对文件路径**和**绝对文件路径**。

在 Windows 系统中，在文件路径中使用反斜杠（\）而不是斜杠（/）：

```python
with open('text_files\filename.txt') as file_object:
    pass
```

### 文件句柄的方法

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `.read()`            | 1) 读入全部内容；<br />2) 如果给出参数，读入前 size 长度的内容 |
| `.readline()`        | 1) 读入一行内容；<br />2) 如果给出参数，读入该行前 size 长度内容 |
| `.readlines()`       | 1) 读入文件所有行，以每行为元素存入列表，列表作为返回值；<br />2) 若给出参数，读入前 hint 行。 |
| `.write(s)`          | 向文件写入一个字符串或字节流                                 |
| `.writelines(lines)` | 将一个元素全为字符串的列表写入文件                           |
| `.tell()`            | 返回一个整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节数，以及文本模式下的不透明数字 |
| `.seek(offset)`      | 1) 改变当前文件操作的指针；<br />2) offset 的含义如下：0-文件开头；1-当前位置；2-文件结尾。 |

- `read()`到达文件末尾时会返回一个空字符串，当把这个空字符串显示出来时就是一个空行。要删除多出来的空行可在 `print()`语句中使用 `rstrip()`。

- 逐行读取：

    ```python
    filename = 'pi_digits.txt'
    with open(filename) as file_object:
        for line in file_object:
            print(line)
    ```

    > 此时我们打印每一行时，发现空白行更多了：
    >
    > 因为在这个文件中，每行的末尾都有一个看不见的换行符，而 print 语句也会加上下个换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自 print 语句。

- 函数 `write()`不会在你写入的文本末尾添加换行符：

    > 要让每个字符串都单独占一行，需要在 `write()`语句中包含换行符：
    >
    > ```python
    > filename = 'programming.txt'
    > 
    > with open(filename, 'w') as file_object:
    > file_object.write("I love programming.\n")
    > file_object.write("I love creating new game.\n")
    > ```


当混合使用 I/O 操作和字符串连接操作的时候，有时需要仔细研究你的程序：

-   如果两个字符串很小，那么第一个版本性能会更好些，因为 I/O 糸统调用天生就慢。另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效，因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。还是那句话，有时候是需要根据你的应用程序特点来决足应该使用哪种方案。

![](https://chua-n.gitee.io/blog-images/notebooks/Python/75.png)

-   如果你准备编写构建大量小字符串的输出代码，你最好考虑使用生成器函数，利用 `yield` 语句产生输出片段

![](https://chua-n.gitee.io/blog-images/notebooks/Python/76.png)

### json与pickle

模块`json`让你能够将简单的 Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用 `json` 在 Python 程序之间分享数据。

> **JSON(JavaScript Object Notation)** 格式最初是为 JavaScript 开发的，但随后成了一种常见格式，被包括 Python 在内的众多语言采用。

![](https://chua-n.gitee.io/blog-images/notebooks/Python/77.png)

![](https://chua-n.gitee.io/blog-images/notebooks/Python/78.png)

与 JSON 不同，`pickle` 是一种允许对任意复杂 Python 对象进行序列化的协议。因此，它为 Python 所特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果数据是由熟练的攻击者精心设计的，则反序列化来自不受信任来源的 `pickle` 数据可以执行任意代码。

